<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","kaladin","rust","mpc_core","mpc_core","benches","circuits.rs"],"content":"use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};\nuse mpc_core::{Circuit, Gate};\n\nfn and(iterations: u32) -\u003e Result\u003c(), mpc_core::Error\u003e {\n    let mut gates = vec![Gate::InContrib];\n    let output_gates = vec![iterations * 2];\n    for i in 0..iterations {\n        gates.append(\u0026mut vec![Gate::InEval, Gate::And(i * 2, i * 2 + 1)]);\n    }\n\n    let program = Circuit::new(gates, output_gates);\n\n    let input_a = vec![true];\n    let input_b = vec![true; iterations as usize];\n\n    let result = mpc_core::simulate(\u0026program, \u0026input_a, \u0026input_b).unwrap();\n\n    assert_eq!(result, vec![true]);\n\n    Ok(())\n}\n\nfn xor(iterations: u32) -\u003e Result\u003c(), mpc_core::Error\u003e {\n    let mut gates = vec![Gate::InContrib];\n    let output_gates = vec![iterations * 2];\n    for i in 0..iterations {\n        gates.append(\u0026mut vec![Gate::InEval, Gate::And(i * 2, i * 2 + 1)]);\n    }\n\n    let program = Circuit::new(gates, output_gates);\n\n    let input_a = vec![true];\n    let input_b = vec![true; iterations as usize];\n\n    let result = mpc_core::simulate(\u0026program, \u0026input_a, \u0026input_b).unwrap();\n\n    let expected = vec![iterations % 2 == 0];\n\n    assert_eq!(result, expected);\n\n    Ok(())\n}\n\nfn circuits_benchmarks(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"AND gates mpc_core\");\n    for iterations in [10, 100, 1_000, 10_000].iter() {\n        group.bench_with_input(\n            BenchmarkId::from_parameter(iterations),\n            iterations,\n            |b, \u0026iterations| {\n                b.iter(|| and(iterations));\n            },\n        );\n    }\n    group.finish();\n\n    let mut group = c.benchmark_group(\"XOR gates mpc_core\");\n    for iterations in [10, 100, 1_000, 10_000].iter() {\n        group.bench_with_input(\n            BenchmarkId::from_parameter(iterations),\n            iterations,\n            |b, \u0026iterations| {\n                b.iter(|| xor(iterations));\n            },\n        );\n    }\n    group.finish();\n}\n\ncriterion_group! {\n  name = benches;\n  config = Criterion::default();\n  targets = circuits_benchmarks\n}\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","benches","credit_scoring.rs"],"content":"use std::time::Instant;\n\nuse criterion::{criterion_group, criterion_main, Criterion};\n\nuse mpc_garble_interop::{check_program, compile_program, serialize_input, Role};\n\nfn credit_scoring_benchmark(c: \u0026mut Criterion) {\n    let credit_scoring = include_str!(\"../tests/credit_scoring_setup/credit_scoring.garble.rs\");\n\n    let typed_prg = check_program(credit_scoring).unwrap();\n\n    let compilation_start = Instant::now();\n\n    let circuit = compile_program(\u0026typed_prg, \"compute_score\").unwrap();\n\n    println!(\"Garble compilation took {:?}\", compilation_start.elapsed());\n    println!(\"Circuit has {}\", circuit.info_about_gates);\n\n    let credit_scorer_input = serialize_input(\n        Role::Contributor,\n        \u0026typed_prg,\n        \u0026circuit.fn_def,\n        SCORING_ALGORITHM,\n    )\n    .unwrap();\n\n    let user_input = serialize_input(Role::Evaluator, \u0026typed_prg, \u0026circuit.fn_def, USER).unwrap();\n\n    c.bench_function(\"credit scoring mpc\", |b| {\n        b.iter(|| {\n            mpc_core::simulate(\u0026circuit.gates, \u0026credit_scorer_input, \u0026user_input).unwrap();\n        })\n    });\n}\n\ncriterion_group!(benches, credit_scoring_benchmark);\ncriterion_main!(benches);\n\nconst SCORING_ALGORITHM: \u0026str = \"\nScoringAlgorithm {\n    age_score: [\n        MatchClause::Range(\n            Range {\n                min: 0i64,\n                max: 18i64,\n            },\n            Points { inc: 0i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 18i64,\n                max: 35i64,\n            },\n            Points { inc: 50i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 35i64,\n                max: 65i64,\n            },\n            Points { inc: 100i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 65i64,\n                max: 120i64,\n            },\n            Points { inc: 50i32 },\n        ),\n    ],\n    income_score: [\n        MatchClause::Range(\n            Range {\n                min: 2000i64,\n                max: 5000i64,\n            },\n            Points { inc: 50i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 5000i64,\n                max: 10000i64,\n            },\n            Points { inc: 100i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 10000i64,\n                max: 999999999i64,\n            },\n            Points { inc: 200i32 },\n        ),\n        MatchClause::None,\n    ],\n    account_balance_score: [\n        MatchClause::Range(\n            Range {\n                min: -999999999i64,\n                max: 0i64,\n            },\n            Points { inc: -100i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 0i64,\n                max: 5000i64,\n            },\n            Points { inc: 0i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 5000i64,\n                max: 10000i64,\n            },\n            Points { inc: 50i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 10000i64,\n                max: 999999999i64,\n            },\n            Points { inc: 200i32 },\n        ),\n    ],\n    current_loans_score: [\n        MatchClause::Range(\n            Range {\n                min: 500000i64,\n                max: 100000000i64,\n            },\n            Points { inc: 0i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 100000i64,\n                max: 500000i64,\n            },\n            Points { inc: 150i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 0i64,\n                max: 100000i64,\n            },\n            Points { inc: 300i32 },\n        ),\n        MatchClause::None,\n    ],\n    credit_card_score: [\n        MatchClause::Range(\n            Range {\n                min: 0i64,\n                max: 10000i64,\n            },\n            Points { inc: 100i32 },\n        ),\n        MatchClause::None,\n        MatchClause::None,\n        MatchClause::None,\n    ],\n    bankruptcy_score: [\n        MatchClause::Bool(true, Points { inc: -100i32 }),\n        MatchClause::Bool(false, Points { inc: 50i32 }),\n    ],\n    loan_payment_history_score: [\n        MatchClause::Range(\n            Range {\n                min: 0i64,\n                max: 3i64,\n            },\n            Points { inc: 0i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 3i64,\n                max: 6i64,\n            },\n            Points { inc: -100i32 },\n        ),\n        MatchClause::None,\n        MatchClause::None,\n    ],\n    credit_payment_history_score: [\n        MatchClause::Range(\n            Range {\n                min: 0i64,\n                max: 1i64,\n            },\n            Points { inc: 0i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 1i64,\n                max: 3i64,\n            },\n            Points { inc: -100i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 3i64,\n                max: 6i64,\n            },\n            Points { inc: -200i32 },\n        ),\n        MatchClause::None,\n    ],\n    surety_income_score: [\n        MatchClause::Range(\n            Range {\n                min: 0i64,\n                max: 1000i64,\n            },\n            Points { inc: -50i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 1000i64,\n                max: 5000i64,\n            },\n            Points { inc: 0i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 5000i64,\n                max: 10000i64,\n            },\n            Points { inc: 100i32 },\n        ),\n        MatchClause::None,\n    ],\n    score_limits: ScoreLimits {\n        min: 0i32,\n        max: 1000i32,\n    },\n}\";\n\nconst USER: \u0026str = \"\nUser {\n    age: 37u8,\n    income: 5500u32,\n    account_balance: 25000i64,\n    current_loans: 60000u64,\n    credit_card_limit: 1000u32,\n    ever_bankrupt: false,\n    loan_payment_failures: 0u8,\n    credit_payment_failures: 2u8,\n    surety_income: 5000u32,\n}\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","benches","multiplications.rs"],"content":"use std::time::Instant;\n\nuse criterion::{criterion_group, criterion_main, Criterion};\n\nuse mpc_garble_interop::{check_program, compile_program, serialize_input, Role};\n\nfn multiplications_benchmark(c: \u0026mut Criterion) {\n    mul(1, MUL_1, c);\n    mul(10, MUL_10, c)\n}\n\ncriterion_group!(benches, multiplications_benchmark);\ncriterion_main!(benches);\n\nfn mul(num_mul: u64, garble_prg: \u0026str, c: \u0026mut Criterion) {\n    let typed_prg = check_program(garble_prg).unwrap();\n\n    let compilation_start = Instant::now();\n\n    let function = format!(\"mul_{num_mul}\");\n\n    let circuit = compile_program(\u0026typed_prg, \u0026function).unwrap();\n\n    let input_a = serialize_input(Role::Contributor, \u0026typed_prg, \u0026circuit.fn_def, \"42u64\").unwrap();\n    let input_b = serialize_input(Role::Evaluator, \u0026typed_prg, \u0026circuit.fn_def, \"42u64\").unwrap();\n\n    println!(\"Garble compilation took {:?}\", compilation_start.elapsed());\n\n    println!(\"Circuit has {}\", circuit.info_about_gates);\n\n    let bench_id = format!(\"mul_{num_mul} mpc\");\n\n    c.bench_function(\u0026bench_id, |b| {\n        b.iter(|| mpc_core::simulate(\u0026circuit.gates, \u0026input_a, \u0026input_b).unwrap())\n    });\n}\n\nconst MUL_1: \u0026str = \"\npub fn mul_1(a: u64, b: u64) -\u003e u64 {\n  a * b\n}\n\";\n\nconst MUL_10: \u0026str = \"\npub fn mul_10(a: u64, b: u64) -\u003e u64 {\n  a * b * b * b * b * b * b * b * b * b * b\n}\n\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","src","circuit.rs"],"content":"use blake3::Hasher;\n\nuse crate::Error;\n\n/// The index of the gate in the circuit, representing its output wire.\npub type GateIndex = u32;\n\n/// A circuit of AND, XOR and NOT gates for secure computation.\n#[derive(Clone, Debug)]\npub struct Circuit {\n    /// A collection of connected gates, each implicitly identified by its index in the vector.\n    gates: Vec\u003cGate\u003e,\n    /// The output wires of the gates that are exposed as outputs of the whole circuit.\n    output_gates: Vec\u003cGateIndex\u003e,\n\n    /// total number of AND gates in the circuit\n    and_gates: usize,\n    /// number of evaluator input bits\n    eval_inputs: usize,\n    /// number of contributor input bits\n    contrib_inputs: usize,\n}\n\n/// A blake3 hash that can be used to compare circuits for equality.\npub type CircuitBlake3Hash = [u8; 32];\n\nconst MAX_GATES: usize = (u32::MAX \u003e\u003e 4) as usize;\nconst MAX_AND_GATES: usize = (u32::MAX \u003e\u003e 8) as usize;\n\nimpl Circuit {\n    /// the gates of the circuit\n    pub fn gates(\u0026self) -\u003e \u0026Vec\u003cGate\u003e {\n        \u0026self.gates\n    }\n    /// indexes of the gates that are exposed as outputs of the circuit\n    pub fn output_gates(\u0026self) -\u003e \u0026Vec\u003cGateIndex\u003e {\n        \u0026self.output_gates\n    }\n    /// number of and gates in the circuit\n    pub fn and_gates(\u0026self) -\u003e usize {\n        self.and_gates\n    }\n    /// number of input bits by the evaluator party\n    pub fn eval_inputs(\u0026self) -\u003e usize {\n        self.eval_inputs\n    }\n    /// number of input bits by the contributor party\n    pub fn contrib_inputs(\u0026self) -\u003e usize {\n        self.contrib_inputs\n    }\n\n    /// create new circuit from a collection of gates and a collection of output gate indexes\n    pub fn new(gates: Vec\u003cGate\u003e, output_gates: Vec\u003cGateIndex\u003e) -\u003e Self {\n        let mut and_gates = 0;\n        let mut eval_inputs = 0;\n        let mut contrib_inputs = 0;\n\n        for gate in \u0026gates {\n            match gate {\n                Gate::And(_, _) =\u003e and_gates += 1,\n                Gate::InEval =\u003e eval_inputs += 1,\n                Gate::InContrib =\u003e contrib_inputs += 1,\n                _ =\u003e {}\n            }\n        }\n\n        Self {\n            gates,\n            output_gates,\n            and_gates,\n            eval_inputs,\n            contrib_inputs,\n        }\n    }\n\n    /// Calculates the blake3 hash of the circuit.\n    pub fn blake3_hash(\u0026self) -\u003e CircuitBlake3Hash {\n        let mut hasher = blake3::Hasher::new();\n        for gate in self.gates.iter() {\n            gate.update_hash(\u0026mut hasher);\n        }\n        for output_gate in self.output_gates.iter() {\n            hasher.update(\u0026output_gate.to_be_bytes());\n        }\n        *hasher.finalize().as_bytes()\n    }\n\n    /// Performs a syntax check of the circuit.\n    ///\n    /// A circuit is invalid if any of the following is true:\n    ///   - it contains cycles (by referring to a wire larger than its own index)\n    ///   - it does not contain any output gates\n    ///   - the output gate indexes do not occur in the circuit\n    ///   - the number of gates exceeds the maximum number supported\n    ///   - the number of AND gates exceeds the maximum number supported\n    pub fn validate(\u0026self) -\u003e Result\u003c(), Error\u003e {\n        let mut num_and_gates = 0;\n        for (i, g) in self.gates.iter().enumerate() {\n            let i = i as u32;\n            match g {\n                Gate::InContrib | Gate::InEval =\u003e {}\n                \u0026Gate::Xor(x, y) =\u003e {\n                    if x \u003e= i || y \u003e= i {\n                        return Err(Error::InvalidCircuit);\n                    }\n                }\n                \u0026Gate::And(x, y) =\u003e {\n                    if x \u003e= i || y \u003e= i {\n                        return Err(Error::InvalidCircuit);\n                    }\n                    num_and_gates += 1;\n                }\n                \u0026Gate::Not(x) =\u003e {\n                    if x \u003e= i {\n                        return Err(Error::InvalidCircuit);\n                    }\n                }\n            }\n        }\n        if self.output_gates.is_empty() {\n            return Err(Error::InvalidCircuit);\n        }\n        for \u0026o in self.output_gates.iter() {\n            if o \u003e= self.gates.len() as u32 {\n                return Err(Error::InvalidCircuit);\n            }\n        }\n        if num_and_gates \u003e MAX_AND_GATES {\n            return Err(Error::MaxCircuitSizeExceeded);\n        }\n        if self.gates.len() \u003e MAX_GATES {\n            return Err(Error::MaxCircuitSizeExceeded);\n        }\n        Ok(())\n    }\n\n    pub(crate) fn validate_contributor_input(\u0026self, input: \u0026[bool]) -\u003e Result\u003c(), Error\u003e {\n        if self\n            .gates\n            .iter()\n            .filter(|g| matches!(g, Gate::InContrib))\n            .count()\n            == input.len()\n        {\n            Ok(())\n        } else {\n            Err(Error::InsufficientInput)\n        }\n    }\n\n    pub(crate) fn validate_evaluator_input(\u0026self, input: \u0026[bool]) -\u003e Result\u003c(), Error\u003e {\n        if self\n            .gates\n            .iter()\n            .filter(|g| matches!(g, Gate::InEval))\n            .count()\n            == input.len()\n        {\n            Ok(())\n        } else {\n            Err(Error::InsufficientInput)\n        }\n    }\n}\n\n/// A single gate in a larger [`Circuit`].\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum Gate {\n    /// A single input bit coming from the circuit contributor.\n    InContrib,\n    /// A single input bit coming from the circuit evaluator.\n    InEval,\n    /// A gate computing the XOR of the two specified gates.\n    Xor(GateIndex, GateIndex),\n    /// A gate computing the AND of the two specified gates.\n    And(GateIndex, GateIndex),\n    /// A gate computing the NOT of the specified gate.\n    Not(GateIndex),\n}\n\nimpl Gate {\n    #[inline]\n    pub(crate) fn is_and(\u0026self) -\u003e bool {\n        matches!(self, Gate::And { .. })\n    }\n\n    pub(crate) fn update_hash(\u0026self, hasher: \u0026mut Hasher) {\n        let type_byte = match self {\n            Gate::InContrib =\u003e 0,\n            Gate::InEval =\u003e 1,\n            Gate::Xor(x, y) =\u003e {\n                hasher.update(\u0026x.to_be_bytes());\n                hasher.update(\u0026y.to_be_bytes());\n                2\n            }\n            Gate::And(x, y) =\u003e {\n                hasher.update(\u0026x.to_be_bytes());\n                hasher.update(\u0026y.to_be_bytes());\n                3\n            }\n            Gate::Not(x) =\u003e {\n                hasher.update(\u0026x.to_be_bytes());\n                4\n            }\n        };\n        hasher.update(\u0026[type_byte]);\n    }\n}\n","traces":[{"line":32,"address":[724784],"length":1,"stats":{"Line":4}},{"line":36,"address":[669552],"length":1,"stats":{"Line":6}},{"line":37,"address":[724808],"length":1,"stats":{"Line":3}},{"line":40,"address":[669568],"length":1,"stats":{"Line":4}},{"line":41,"address":[724821],"length":1,"stats":{"Line":3}},{"line":44,"address":[669584],"length":1,"stats":{"Line":4}},{"line":45,"address":[724837],"length":1,"stats":{"Line":4}},{"line":48,"address":[724848],"length":1,"stats":{"Line":3}},{"line":49,"address":[724853],"length":1,"stats":{"Line":3}},{"line":53,"address":[724864,725507,725529],"length":1,"stats":{"Line":6}},{"line":54,"address":[287891],"length":1,"stats":{"Line":8}},{"line":55,"address":[287900],"length":1,"stats":{"Line":6}},{"line":56,"address":[287909],"length":1,"stats":{"Line":3}},{"line":58,"address":[669678,669750],"length":1,"stats":{"Line":19}},{"line":59,"address":[725092],"length":1,"stats":{"Line":7}},{"line":60,"address":[670231,670137],"length":1,"stats":{"Line":7}},{"line":61,"address":[288348,288430],"length":1,"stats":{"Line":11}},{"line":62,"address":[725411,725343],"length":1,"stats":{"Line":9}},{"line":77,"address":[670304,671026,671032],"length":1,"stats":{"Line":0}},{"line":78,"address":[725585],"length":1,"stats":{"Line":0}},{"line":79,"address":[725697,725610],"length":1,"stats":{"Line":0}},{"line":80,"address":[288827,289229],"length":1,"stats":{"Line":0}},{"line":82,"address":[670637],"length":1,"stats":{"Line":0}},{"line":83,"address":[726082,726211],"length":1,"stats":{"Line":0}},{"line":85,"address":[670847],"length":1,"stats":{"Line":0}},{"line":96,"address":[726304],"length":1,"stats":{"Line":7}},{"line":97,"address":[671076],"length":1,"stats":{"Line":5}},{"line":98,"address":[289376,289293],"length":1,"stats":{"Line":8}},{"line":99,"address":[289477],"length":1,"stats":{"Line":8}},{"line":100,"address":[726529],"length":1,"stats":{"Line":5}},{"line":102,"address":[726878],"length":1,"stats":{"Line":5}},{"line":103,"address":[289855,289940],"length":1,"stats":{"Line":9}},{"line":104,"address":[726995],"length":1,"stats":{"Line":1}},{"line":107,"address":[671669],"length":1,"stats":{"Line":2}},{"line":108,"address":[289894,289980],"length":1,"stats":{"Line":4}},{"line":109,"address":[727031],"length":1,"stats":{"Line":1}},{"line":111,"address":[727055,727089],"length":1,"stats":{"Line":4}},{"line":113,"address":[726956],"length":1,"stats":{"Line":2}},{"line":114,"address":[289919],"length":1,"stats":{"Line":2}},{"line":115,"address":[290055],"length":1,"stats":{"Line":1}},{"line":120,"address":[289517],"length":1,"stats":{"Line":4}},{"line":121,"address":[726633],"length":1,"stats":{"Line":1}},{"line":123,"address":[671333,671409],"length":1,"stats":{"Line":8}},{"line":124,"address":[289691],"length":1,"stats":{"Line":5}},{"line":125,"address":[726846],"length":1,"stats":{"Line":1}},{"line":128,"address":[671507],"length":1,"stats":{"Line":2}},{"line":129,"address":[671539],"length":1,"stats":{"Line":1}},{"line":131,"address":[671523],"length":1,"stats":{"Line":3}},{"line":132,"address":[289768],"length":1,"stats":{"Line":1}},{"line":134,"address":[726808],"length":1,"stats":{"Line":4}},{"line":137,"address":[727136],"length":1,"stats":{"Line":8}},{"line":138,"address":[290103,290163],"length":1,"stats":{"Line":6}},{"line":141,"address":[749424,749434],"length":1,"stats":{"Line":13}},{"line":145,"address":[727225],"length":1,"stats":{"Line":8}},{"line":147,"address":[727210],"length":1,"stats":{"Line":1}},{"line":151,"address":[290192],"length":1,"stats":{"Line":2}},{"line":152,"address":[290215,290275],"length":1,"stats":{"Line":7}},{"line":155,"address":[749456,749466],"length":1,"stats":{"Line":10}},{"line":159,"address":[290277],"length":1,"stats":{"Line":3}},{"line":161,"address":[672074],"length":1,"stats":{"Line":1}},{"line":183,"address":[672112],"length":1,"stats":{"Line":2}},{"line":184,"address":[290309],"length":1,"stats":{"Line":4}},{"line":187,"address":[727392],"length":1,"stats":{"Line":0}},{"line":188,"address":[672171],"length":1,"stats":{"Line":0}},{"line":189,"address":[290393],"length":1,"stats":{"Line":0}},{"line":190,"address":[672211],"length":1,"stats":{"Line":0}},{"line":191,"address":[672226],"length":1,"stats":{"Line":0}},{"line":192,"address":[672250],"length":1,"stats":{"Line":0}},{"line":193,"address":[727544],"length":1,"stats":{"Line":0}},{"line":194,"address":[290529],"length":1,"stats":{"Line":0}},{"line":196,"address":[672352],"length":1,"stats":{"Line":0}},{"line":197,"address":[727624],"length":1,"stats":{"Line":0}},{"line":198,"address":[727670],"length":1,"stats":{"Line":0}},{"line":199,"address":[672463],"length":1,"stats":{"Line":0}},{"line":201,"address":[672475],"length":1,"stats":{"Line":0}},{"line":202,"address":[672487],"length":1,"stats":{"Line":0}},{"line":203,"address":[672534],"length":1,"stats":{"Line":0}},{"line":206,"address":[672544],"length":1,"stats":{"Line":0}}],"covered":55,"coverable":78},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","src","hash.rs"],"content":"//! Non-optimized hashing based on [`blake3::Hasher`].\nuse std::io::Read;\n\n\nuse crate::types::{KeyType, MacType};\n\n/// Hashing for building garbled tables.\npub(crate) mod garbling_hash {\n    use crate::{\n        types::{BitShare, KeyType, MacType, WireLabel},\n        GateIndex,\n    };\n    use std::io::Read;\n\n    /// Computes a garbled table share.\n    pub(crate) fn new(\n        label_x: \u0026WireLabel,\n        label_y: \u0026WireLabel,\n        gate: GateIndex,\n        row: u8,\n    ) -\u003e BitShare {\n        let mut hasher = blake3::Hasher::new();\n        hasher.update(\u0026label_x.0.to_le_bytes());\n        hasher.update(\u0026label_y.0.to_le_bytes());\n        hasher.update(\u0026gate.to_le_bytes());\n        hasher.update(\u0026[row]);\n        let mut output_reader = hasher.finalize_xof();\n\n        let mut mac_buffer: [u8; 16] = [0; 16];\n        let mut label_buffer: [u8; 16] = [0; 16];\n        let mut bit_buffer: [u8; 1] = [0];\n\n        let r = output_reader.read(\u0026mut mac_buffer);\n        assert!(r.is_ok());\n        let r = output_reader.read(\u0026mut label_buffer);\n        assert!(r.is_ok());\n        let r = output_reader.read(\u0026mut bit_buffer);\n        assert!(r.is_ok());\n\n        assert_ne!(mac_buffer, [0; 16]);\n        assert_ne!(label_buffer, [0; 16]);\n\n        BitShare {\n            mac: MacType(u128::from_le_bytes(mac_buffer)),\n            key: KeyType(u128::from_le_bytes(label_buffer)),\n            bit: (bit_buffer[0] \u0026 1) == 1,\n        }\n    }\n\n    #[test]\n    fn test_new() {\n        let h0 = new(\u0026WireLabel(0), \u0026WireLabel(1), 0, 0);\n        let h1 = new(\u0026WireLabel(0), \u0026WireLabel(1), 0, 1);\n        assert_ne!(h0, h1);\n    }\n}\n\npub(crate) fn hash(mac: MacType) -\u003e MacType {\n    hash_u128(mac.0)\n}\n\npub(crate) fn hash_key(key: KeyType) -\u003e MacType {\n    hash_u128(key.0)\n}\n\npub(crate) fn hash_keys(key1: KeyType, key2: KeyType) -\u003e MacType {\n    let mut hasher = blake3::Hasher::new();\n    hasher.update(\u0026key1.0.to_le_bytes());\n    hasher.update(\u0026key2.0.to_le_bytes());\n    let mut output_reader = hasher.finalize_xof();\n    let mut buffer = [0u8; 16];\n    let r = output_reader.read(\u0026mut buffer);\n    assert!(r.is_ok());\n    MacType(u128::from_le_bytes(buffer))\n}\n\nfn hash_u128(value: u128) -\u003e MacType {\n    let mut hasher = blake3::Hasher::new();\n    hasher.update(\u0026value.to_le_bytes());\n    let mut output_reader = hasher.finalize_xof();\n    let mut buffer = [0u8; 16];\n    let r = output_reader.read(\u0026mut buffer);\n    assert!(r.is_ok());\n    MacType(u128::from_le_bytes(buffer))\n}\n\n#[test]\nfn test_hash_keys() {\n    let h0 = hash_keys(KeyType(0), KeyType(1));\n    let h1 = hash_keys(KeyType(0), KeyType(1));\n    assert_eq!(h0, h1);\n    let h2 = hash_keys(KeyType(1), KeyType(0));\n    assert_ne!(h0, h2);\n}\n\n#[test]\nfn test_hash_values() {\n    let r0 = 164479851121213158701332959497568687214_u128;\n    let r1 = 32869993993155099816536977414117934351_u128;\n\n    assert_eq!(252301825721988224801639279640745335827, hash(MacType(r0)).0);\n    assert_eq!(19881579897213927600698344798095172587, hash(MacType(r1)).0);\n    assert_eq!(\n        265242760764573362325515364989468422452,\n        hash_keys(KeyType(r0), KeyType(r1)).0\n    );\n}\n\n#[test]\nfn test_random_hash() {\n    let r: u128 = rand::random();\n    let ref_0 = blake3::hash(\u0026r.to_le_bytes());\n    assert_eq!(\u0026ref_0.as_bytes()[..16], hash(MacType(r)).0.to_ne_bytes());\n}\n","traces":[{"line":16,"address":[1182624,1184054,1184060],"length":1,"stats":{"Line":3}},{"line":22,"address":[1182701],"length":1,"stats":{"Line":5}},{"line":23,"address":[1109288,1109222],"length":1,"stats":{"Line":8}},{"line":24,"address":[1109325],"length":1,"stats":{"Line":3}},{"line":25,"address":[1182887],"length":1,"stats":{"Line":4}},{"line":26,"address":[1182962],"length":1,"stats":{"Line":4}},{"line":27,"address":[1109497],"length":1,"stats":{"Line":4}},{"line":29,"address":[1109524],"length":1,"stats":{"Line":4}},{"line":30,"address":[1183039],"length":1,"stats":{"Line":5}},{"line":31,"address":[1109543],"length":1,"stats":{"Line":5}},{"line":33,"address":[286644],"length":1,"stats":{"Line":5}},{"line":34,"address":[1109686,1109615],"length":1,"stats":{"Line":8}},{"line":35,"address":[1183247],"length":1,"stats":{"Line":4}},{"line":36,"address":[1109859,1109788],"length":1,"stats":{"Line":8}},{"line":37,"address":[1183423],"length":1,"stats":{"Line":4}},{"line":38,"address":[287034,287093],"length":1,"stats":{"Line":8}},{"line":40,"address":[1110080,1110174],"length":1,"stats":{"Line":4}},{"line":41,"address":[1183801,1183640,1183754],"length":1,"stats":{"Line":8}},{"line":44,"address":[1183760],"length":1,"stats":{"Line":6}},{"line":45,"address":[1183873],"length":1,"stats":{"Line":4}},{"line":46,"address":[1110409],"length":1,"stats":{"Line":3}},{"line":58,"address":[1132032],"length":1,"stats":{"Line":6}},{"line":59,"address":[293533],"length":1,"stats":{"Line":4}},{"line":62,"address":[1132064],"length":1,"stats":{"Line":3}},{"line":63,"address":[293565],"length":1,"stats":{"Line":3}},{"line":66,"address":[1210544,1210016,1210538],"length":1,"stats":{"Line":4}},{"line":67,"address":[1210075],"length":1,"stats":{"Line":4}},{"line":68,"address":[1132187,1132235],"length":1,"stats":{"Line":7}},{"line":69,"address":[1210202],"length":1,"stats":{"Line":3}},{"line":70,"address":[1210238],"length":1,"stats":{"Line":5}},{"line":71,"address":[1210262],"length":1,"stats":{"Line":3}},{"line":72,"address":[1210294],"length":1,"stats":{"Line":5}},{"line":73,"address":[1210337,1210408],"length":1,"stats":{"Line":8}},{"line":74,"address":[1210444],"length":1,"stats":{"Line":3}},{"line":77,"address":[1211008,1210560,1211002],"length":1,"stats":{"Line":5}},{"line":78,"address":[1132673],"length":1,"stats":{"Line":5}},{"line":79,"address":[1132705,1132753],"length":1,"stats":{"Line":10}},{"line":80,"address":[1132782],"length":1,"stats":{"Line":5}},{"line":81,"address":[1132806],"length":1,"stats":{"Line":5}},{"line":82,"address":[1132838],"length":1,"stats":{"Line":5}},{"line":83,"address":[1132881,1132952],"length":1,"stats":{"Line":10}},{"line":84,"address":[1132988],"length":1,"stats":{"Line":5}}],"covered":42,"coverable":42},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","src","leakyand.rs"],"content":"//! Implementation of secure AND computation sub-protocols.\nuse crate::{\n    hash::hash,\n    types::{Delta, KeyType, MacType, K},\n};\n\npub(crate) type AndHashes = [[MacType; 2]];\n\n/// Computes hashes for each secret value to be sent to the other party.\n///\n/// Parameters:\n/// - `keys[i]` is the key for authenticated bit at index `i`\n/// - `random_bits` are the random values used in the protocol\n/// - `delta` is the local delta value\npub(crate) fn compute_leaky_and_hashes(\n    out: \u0026mut AndHashes,\n    delta: \u0026Delta,\n    random_bits: u128,\n    authenticated_bits_y: u128,\n    keys: \u0026[KeyType],\n) {\n    assert!(keys.len() \u003e= K);\n    assert!(out.len() \u003e= K);\n\n    for i in 0..K {\n        let random_bit = u128::from(random_bits \u0026 (1 \u003c\u003c i) != 0);\n        let y_bit = u128::from((authenticated_bits_y \u0026 (1 \u003c\u003c i)) != 0);\n        out[i][0] = MacType(hash(MacType(keys[i].0)).0 ^ random_bit);\n        out[i][1] = MacType(hash(delta.xor(MacType(keys[i].0))).0 ^ random_bit ^ y_bit);\n    }\n}\n\n/// Derives AND shares from the received hashes.\n///\n/// Takes K-many `and_hashes` from the other party which were computed through\n/// [compute_leaky_and_hashes] and outputs K-many shares.\npub(crate) fn derive_and_shares(\n    random_bits: u128,\n    authenticated_bits: u128,\n    macs: \u0026[MacType],\n    and_hashes: \u0026AndHashes,\n) -\u003e MacType {\n    assert!(macs.len() \u003e= K);\n    assert!(and_hashes.len() \u003e= K);\n\n    let mut result = 0;\n\n    for i in 0..K {\n        let idx = usize::from((authenticated_bits \u0026 (1 \u003c\u003c i)) != 0);\n        let is_set = (and_hashes[i][idx].0 ^ hash(macs[i]).0) != 0;\n        result |= (u128::from(is_set)) \u003c\u003c i;\n    }\n\n    MacType(result ^ random_bits)\n}\n\n// #[test]\n// fn test_leaky_and() {\n//     use rand_core::SeedableRng;\n//     use rand_chacha::ChaCha20Rng;\n\n//     let mut rng = ChaCha20Rng::from_entropy();\n//     let x = rng.next_u64() as u128 | ((rng.next_u64() as u128) \u003c\u003c 64);\n//     let y = rng.next_u64() as u128 | ((rng.next_u64() as u128) \u003c\u003c 64);\n//     let delta = Delta(rng.next_u64() as u128 | ((rng.next_u64() as u128) \u003c\u003c 64));\n\n//     let mut keys = [KeyType(0); K];\n//     let mut macs = [MacType(0); K];\n//     for i in 0..K {\n//         keys[i] = KeyType(rng.next_u64() as u128 | ((rng.next_u64() as u128) \u003c\u003c 64));\n//         macs[i] = MacType(rng.next_u64() as u128 | ((rng.next_u64() as u128) \u003c\u003c 64));\n//     }\n\n//     let mut hashes = [[MacType(0), MacType(0)]; K];\n//     compute_leaky_and_hashes(\u0026mut hashes, \u0026delta, x, y, \u0026keys);\n\n//     let result = derive_and_shares(x, y, \u0026macs, \u0026hashes);\n//     assert_eq!(result.0, x \u0026 y);\n// }\n\n/// Generates K-many authenticated bits for testing.\n#[cfg(test)]\nfn gen_abits() -\u003e (\n    Delta,\n    KeyType,\n    [KeyType; 128],\n    [MacType; 128],\n    Delta,\n    KeyType,\n    [KeyType; 128],\n    [MacType; 128],\n) {\n    use rand::{random, SeedableRng};\n    use rand_chacha::ChaCha20Rng;\n\n    let mut rng = ChaCha20Rng::from_entropy();\n    let delta_a = Delta::gen_random(\u0026mut rng);\n    let delta_b: Delta = Delta::gen_random(\u0026mut rng);\n\n    let bits_a = KeyType(random());\n    let bits_b = KeyType(random());\n\n    let mut keys_a = [KeyType(0); 128];\n    for k in keys_a.iter_mut() {\n        *k = KeyType(random());\n    }\n    let mut keys_b = [KeyType(0); 128];\n    for k in keys_b.iter_mut() {\n        *k = KeyType(random());\n    }\n    let mut macs_a = [MacType(0); 128];\n    for (i, m) in macs_a.iter_mut().enumerate() {\n        *m = if bits_a.0 \u0026 1 \u003c\u003c i != 0 {\n            delta_b.xor(MacType(keys_b[i].0))\n        } else {\n            MacType(keys_b[i].0)\n        };\n    }\n    let mut macs_b = [MacType(0); 128];\n    for (i, m) in macs_b.iter_mut().enumerate() {\n        *m = if bits_b.0 \u0026 1 \u003c\u003c i != 0 {\n            delta_a.xor(MacType(keys_a[i].0))\n        } else {\n            MacType(keys_a[i].0)\n        };\n    }\n    (\n        delta_a, bits_a, keys_a, macs_a, delta_b, bits_b, keys_b, macs_b,\n    )\n}\n","traces":[{"line":15,"address":[419088],"length":1,"stats":{"Line":2}},{"line":22,"address":[1141731],"length":1,"stats":{"Line":4}},{"line":23,"address":[1141769],"length":1,"stats":{"Line":2}},{"line":25,"address":[1220058,1220851],"length":1,"stats":{"Line":6}},{"line":26,"address":[1141932,1142053,1141898],"length":1,"stats":{"Line":4}},{"line":27,"address":[1220471,1220296,1220335],"length":1,"stats":{"Line":5}},{"line":28,"address":[1220464,1220661,1220494],"length":1,"stats":{"Line":5}},{"line":29,"address":[1142385,1142433,1142610],"length":1,"stats":{"Line":5}},{"line":37,"address":[1142624],"length":1,"stats":{"Line":2}},{"line":43,"address":[1221039],"length":1,"stats":{"Line":3}},{"line":44,"address":[1221081],"length":1,"stats":{"Line":2}},{"line":46,"address":[1221114],"length":1,"stats":{"Line":3}},{"line":48,"address":[1143513,1142882],"length":1,"stats":{"Line":5}},{"line":49,"address":[1142978,1143041,1143145],"length":1,"stats":{"Line":6}},{"line":50,"address":[1143138,1143413,1143163],"length":1,"stats":{"Line":5}},{"line":51,"address":[1143518,1143364,1143441],"length":1,"stats":{"Line":6}},{"line":54,"address":[1143001],"length":1,"stats":{"Line":2}},{"line":83,"address":[421040],"length":1,"stats":{"Line":0}},{"line":96,"address":[421117],"length":1,"stats":{"Line":0}},{"line":97,"address":[421144],"length":1,"stats":{"Line":0}},{"line":98,"address":[421170],"length":1,"stats":{"Line":0}},{"line":100,"address":[421191],"length":1,"stats":{"Line":0}},{"line":101,"address":[421228],"length":1,"stats":{"Line":0}},{"line":103,"address":[421271],"length":1,"stats":{"Line":0}},{"line":104,"address":[421291,421429],"length":1,"stats":{"Line":0}},{"line":105,"address":[421409],"length":1,"stats":{"Line":0}},{"line":107,"address":[421431],"length":1,"stats":{"Line":0}},{"line":108,"address":[421451,421589],"length":1,"stats":{"Line":0}},{"line":109,"address":[421569],"length":1,"stats":{"Line":0}},{"line":111,"address":[421591],"length":1,"stats":{"Line":0}},{"line":112,"address":[421611,422953],"length":1,"stats":{"Line":0}},{"line":113,"address":[422930,422755,422900,421816],"length":1,"stats":{"Line":0}},{"line":114,"address":[422846,422963],"length":1,"stats":{"Line":0}},{"line":116,"address":[422864,422831,422907],"length":1,"stats":{"Line":0}},{"line":119,"address":[421833],"length":1,"stats":{"Line":0}},{"line":120,"address":[422661,421853],"length":1,"stats":{"Line":0}},{"line":121,"address":[422638,422460,422058,422608],"length":1,"stats":{"Line":0}},{"line":122,"address":[422671,422554],"length":1,"stats":{"Line":0}},{"line":124,"address":[422539,422615,422572],"length":1,"stats":{"Line":0}},{"line":128,"address":[422118],"length":1,"stats":{"Line":0}}],"covered":17,"coverable":40},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","src","leakydelta_ot.rs"],"content":"use crate::{\n    ot_base::message::Init as BaseOTInit,\n    ot_base::{OtMessage, Receiver as BaseReceiver, Sender as BaseSender},\n    types::{Delta, KeyType, MacType, K},\n};\nuse rand_core::{RngCore, SeedableRng};\nuse rand_chacha::ChaCha20Rng;\n\npub(crate) const BLOCK_SIZE: usize = K;\n\npub(crate) mod message {\n    use serde::{Deserialize, Serialize};\n\n    use crate::{ot_base::message::Init, ot_base::message::InitReply, Error};\n\n    #[derive(Debug, Clone, PartialEq)]\n    pub struct OtInit(pub(super) Box\u003c[Init; super::K]\u003e);\n\n    #[derive(Debug, Clone, PartialEq)]\n    pub struct OtInitReply(pub(super) Box\u003c[InitReply; super::K]\u003e);\n\n    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n    pub struct SerializedOtInit(Vec\u003cu8\u003e);\n\n    impl OtInit {\n        pub fn serialize(\u0026self) -\u003e SerializedOtInit {\n            let mut buffer = Vec::with_capacity(32 * super::K);\n            for init in self.0.iter() {\n                init.serialize_to_buffer(\u0026mut buffer);\n            }\n            SerializedOtInit(buffer)\n        }\n    }\n\n    impl SerializedOtInit {\n        pub fn deserialize(\u0026self) -\u003e Result\u003cOtInit, Error\u003e {\n            let mut buffer = self.0.iter();\n            let mut init = Box::new([Init::default(); super::K]);\n            for init in init.iter_mut().take(super::K) {\n                *init = Init::deserialize_from_buffer(\u0026mut buffer)?;\n            }\n            Ok(OtInit(init))\n        }\n    }\n\n    impl OtInitReply {\n        pub fn serialize(\u0026self) -\u003e Vec\u003cu8\u003e {\n            let mut buffer = Vec::with_capacity(crate::ot_base::MSG_LEN * 2 * super::K);\n            for init_reply in self.0.iter() {\n                init_reply.serialize_to_buffer(\u0026mut buffer);\n            }\n            buffer\n        }\n\n        pub fn deserialize(buffer: Vec\u003cu8\u003e) -\u003e Result\u003cSelf, Error\u003e {\n            if buffer.len() != crate::ot_base::MSG_LEN * 2 * super::K {\n                return Err(Error::OtInitDeserializationError);\n            }\n\n            let mut buffer = buffer.iter();\n            let mut init_reply =\n                Box::new([crate::ot_base::message::InitReply::default(); super::K]);\n\n            for init in init_reply.iter_mut().take(super::K) {\n                *init = crate::ot_base::message::InitReply::deserialize_from_buffer(\u0026mut buffer)?;\n            }\n\n            Ok(OtInitReply(init_reply))\n        }\n    }\n}\n\n#[derive(Clone)]\npub(crate) struct ReceiverInitializer {\n    senders: Box\u003c[BaseSender; K]\u003e,\n    ot_messages: Box\u003c[[OtMessage; 2]; K]\u003e,\n}\n\n#[derive(Clone)]\npub(crate) struct SenderInitializer {\n    delta: Delta,\n    receivers: Box\u003c[BaseReceiver; K]\u003e,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct LeakyOtReceiver {\n    otg0: Box\u003c[ChaCha20Rng; K]\u003e,\n    otg1: Box\u003c[ChaCha20Rng; K]\u003e,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct LeakyOtSender {\n    delta: Delta,\n    otg: Box\u003c[ChaCha20Rng; K]\u003e,\n}\n\nimpl ReceiverInitializer {\n    pub(crate) fn init(rng: \u0026mut ChaCha20Rng) -\u003e (Self, message::OtInit) {\n        let senders = Box::new([(); K].map(|_| BaseSender::new(rng)));\n        let mut idxs = [0; K];\n        for (i, idx) in idxs.iter_mut().enumerate().take(K) {\n            *idx = i;\n        }\n        let msgs = Box::new(idxs.map(|i| BaseSender::init_message(\u0026senders[i])));\n\n        let ot_messages = Box::new({\n            idxs.map(|_| {\n                let mut ot_messages = [OtMessage::default(); 2];\n                rng.fill_bytes(\u0026mut ot_messages[0]);\n                rng.fill_bytes(\u0026mut ot_messages[1]);\n                ot_messages\n            })\n        });\n\n        let s = Self {\n            senders,\n            ot_messages,\n        };\n\n        (s, message::OtInit(msgs))\n    }\n\n    pub(crate) fn recv(\u0026self, m: \u0026message::OtInit) -\u003e (LeakyOtReceiver, message::OtInitReply) {\n        let mut idxs = [0; K];\n        for (i, idx) in idxs.iter_mut().enumerate().take(K) {\n            *idx = i;\n        }\n\n        let replies =\n            Box::new(idxs.map(|idx| {\n                BaseSender::send(\u0026self.senders[idx], \u0026m.0[idx], \u0026self.ot_messages[idx])\n            }));\n\n        let otg0: Box\u003c[ChaCha20Rng; K]\u003e =\n            Box::new(idxs.map(|idx| ChaCha20Rng::from_seed(self.ot_messages[idx][0])));\n        let otg1: Box\u003c[ChaCha20Rng; K]\u003e =\n            Box::new(idxs.map(|idx| ChaCha20Rng::from_seed(self.ot_messages[idx][1])));\n\n        (\n            LeakyOtReceiver { otg0, otg1 },\n            message::OtInitReply(replies),\n        )\n    }\n}\n\nimpl SenderInitializer {\n    pub(crate) fn init(\n        rng: \u0026mut ChaCha20Rng,\n        delta: Delta,\n        m: \u0026message::OtInit,\n    ) -\u003e (Self, message::OtInit) {\n        let mut idxs: [usize; K] = [0; K];\n        for (i, idx) in idxs.iter_mut().enumerate().take(K) {\n            *idx = i;\n        }\n\n        let mut msgs: Box\u003c[BaseOTInit; K]\u003e = Box::new([BaseOTInit::default(); K]);\n        let receivers: Box\u003c[BaseReceiver; K]\u003e = Box::new(idxs.map(|i| {\n            let chosen = (delta.0 \u0026 (1 \u003c\u003c i)) != 0;\n            let (msg, r) = BaseReceiver::init(rng, \u0026m.0[i], chosen);\n            msgs[i] = msg;\n            r\n        }));\n\n        (Self { delta, receivers }, message::OtInit(msgs))\n    }\n\n    pub(crate) fn recv(self, m: \u0026message::OtInitReply) -\u003e LeakyOtSender {\n        let mut idxs = [0; K];\n        for (i, idx) in idxs.iter_mut().enumerate().take(K) {\n            *idx = i;\n        }\n\n        let mut idx = 0;\n        let otg = Box::new(self.receivers.map(|r| {\n            let seed = r.recv(m.0[idx]);\n            idx += 1;\n            ChaCha20Rng::from_seed(seed)\n        }));\n\n        LeakyOtSender {\n            delta: self.delta,\n            otg,\n        }\n    }\n}\n\nimpl LeakyOtSender {\n    pub(crate) fn send(\u0026mut self, ot_rx: \u0026[MacType], keys_out: \u0026mut [MacType]) {\n        let mut q_i = [KeyType(0); BLOCK_SIZE];\n        for (i, q_i) in q_i.iter_mut().enumerate() {\n            let k = (self.otg[i].next_u64() as u128 | ((self.otg[i].next_u64() as u128) \u003c\u003c 64))\n                ^ if (self.delta.0 \u0026 (1 \u003c\u003c i)) != 0 {\n                    ot_rx[i].0\n                } else {\n                    0\n                };\n            *q_i = KeyType(k)\n        }\n\n        matrix_transpose(keys_out, \u0026q_i);\n    }\n}\n\nimpl LeakyOtReceiver {\n    pub(crate) fn new_batch(\n        \u0026mut self,\n        random_bits: u128,\n        macs_out: \u0026mut [MacType],\n        ot_out: \u0026mut [MacType],\n    ) {\n        assert!(ot_out.len() \u003e= BLOCK_SIZE);\n        assert!(macs_out.len() \u003e= BLOCK_SIZE);\n\n        let mut t_i: [KeyType; BLOCK_SIZE] = [KeyType(0); BLOCK_SIZE];\n        for (i, t_i) in t_i.iter_mut().enumerate() {\n            *t_i = KeyType(self.otg0[i].next_u64() as u128 | ((self.otg0[i].next_u64() as u128) \u003c\u003c 64));\n        }\n\n        for i in 0..BLOCK_SIZE {\n            ot_out[i] = MacType(t_i[i].0 ^ (self.otg1[i].next_u64() as u128 | ((self.otg1[i].next_u64() as u128) \u003c\u003c 64)) ^ random_bits);\n        }\n\n        matrix_transpose(macs_out, \u0026t_i);\n    }\n}\n\n#[inline]\nfn matrix_transpose(macs_out: \u0026mut [MacType], t_i: \u0026[KeyType]) {\n    for (i, mac_out) in macs_out.iter_mut().enumerate().take(BLOCK_SIZE) {\n        *mac_out = transpose_column(t_i, 1 \u003c\u003c i);\n    }\n}\n\n#[inline]\nfn transpose_column(t_i: \u0026[KeyType], test_bit: u128) -\u003e MacType {\n    let mut key = 0;\n\n    for (i, t_i) in t_i.iter().enumerate().take(BLOCK_SIZE) {\n        let bit_from_ot = u128::from((t_i.0 \u0026 test_bit) != 0);\n        key |= bit_from_ot \u003c\u003c i;\n    }\n    MacType(key)\n}\n\n#[test]\nfn test_serialization() {\n    use rand_core::SeedableRng;\n    use rand_chacha::ChaCha20Rng;\n\n    let mut rng_send = ChaCha20Rng::from_seed([42; 32]);\n    let delta = Delta(rng_send.next_u64() as u128 | ((rng_send.next_u64() as u128) \u003c\u003c 64));\n\n    let (r, r_msg) = ReceiverInitializer::init(\u0026mut rng_send);\n    let (_, s_msg) = SenderInitializer::init(\u0026mut rng_send, delta, \u0026r_msg);\n    let (_, reply) = r.recv(\u0026s_msg);\n\n    assert_eq!(r_msg, r_msg.serialize().deserialize().unwrap());\n    assert_eq!(s_msg, s_msg.serialize().deserialize().unwrap());\n    assert_eq!(\n        reply,\n        message::OtInitReply::deserialize(reply.serialize()).unwrap()\n    );\n}\n","traces":[{"line":26,"address":[385419,384992,385413],"length":1,"stats":{"Line":4}},{"line":27,"address":[385097,385022],"length":1,"stats":{"Line":6}},{"line":28,"address":[1138380,1138470,1138337],"length":1,"stats":{"Line":15}},{"line":29,"address":[1138685,1138586],"length":1,"stats":{"Line":10}},{"line":31,"address":[1138603],"length":1,"stats":{"Line":6}},{"line":36,"address":[1138720,1139497,1139491],"length":1,"stats":{"Line":7}},{"line":37,"address":[1138833],"length":1,"stats":{"Line":4}},{"line":38,"address":[385673,385581],"length":1,"stats":{"Line":10}},{"line":39,"address":[1139470,1138969,1139091],"length":1,"stats":{"Line":14}},{"line":40,"address":[1139292,1139329],"length":1,"stats":{"Line":10}},{"line":42,"address":[1217560],"length":1,"stats":{"Line":5}},{"line":47,"address":[1139953,1139520,1139959],"length":1,"stats":{"Line":3}},{"line":48,"address":[1139664,1139550],"length":1,"stats":{"Line":8}},{"line":49,"address":[386326,386374,386455],"length":1,"stats":{"Line":18}},{"line":50,"address":[386572,386623],"length":1,"stats":{"Line":16}},{"line":52,"address":[1139914],"length":1,"stats":{"Line":3}},{"line":55,"address":[1141025,1139984],"length":1,"stats":{"Line":3}},{"line":56,"address":[1140107,1140047],"length":1,"stats":{"Line":9}},{"line":57,"address":[1218500],"length":1,"stats":{"Line":0}},{"line":60,"address":[1218474,1218536],"length":1,"stats":{"Line":8}},{"line":61,"address":[387003],"length":1,"stats":{"Line":4}},{"line":64,"address":[387621,387124,387257],"length":1,"stats":{"Line":13}},{"line":65,"address":[1219047,1219101],"length":1,"stats":{"Line":9}},{"line":68,"address":[387452],"length":1,"stats":{"Line":3}},{"line":98,"address":[578528,579288,579294],"length":1,"stats":{"Line":7}},{"line":99,"address":[1124828],"length":1,"stats":{"Line":14}},{"line":100,"address":[578645],"length":1,"stats":{"Line":3}},{"line":101,"address":[578968,578729,578657],"length":1,"stats":{"Line":15}},{"line":102,"address":[578965],"length":1,"stats":{"Line":4}},{"line":104,"address":[1202970],"length":1,"stats":{"Line":15}},{"line":106,"address":[579205],"length":1,"stats":{"Line":5}},{"line":107,"address":[784208],"length":1,"stats":{"Line":9}},{"line":108,"address":[784246],"length":1,"stats":{"Line":5}},{"line":109,"address":[983728],"length":1,"stats":{"Line":5}},{"line":110,"address":[983751],"length":1,"stats":{"Line":5}},{"line":111,"address":[784402],"length":1,"stats":{"Line":5}},{"line":120,"address":[1203281],"length":1,"stats":{"Line":6}},{"line":123,"address":[1204314,1204320,1203328],"length":1,"stats":{"Line":3}},{"line":124,"address":[1203401],"length":1,"stats":{"Line":3}},{"line":125,"address":[579402,579639],"length":1,"stats":{"Line":16}},{"line":126,"address":[579636],"length":1,"stats":{"Line":3}},{"line":129,"address":[983808],"length":1,"stats":{"Line":9}},{"line":131,"address":[983842,984021],"length":1,"stats":{"Line":4}},{"line":134,"address":[580029,579961,579873],"length":1,"stats":{"Line":30}},{"line":136,"address":[1204232,1204089],"length":1,"stats":{"Line":21}},{"line":140,"address":[1204279],"length":1,"stats":{"Line":3}},{"line":141,"address":[1204287],"length":1,"stats":{"Line":8}},{"line":147,"address":[1204336,1205128,1205122],"length":1,"stats":{"Line":5}},{"line":152,"address":[1126691],"length":1,"stats":{"Line":4}},{"line":153,"address":[580388,580625],"length":1,"stats":{"Line":9}},{"line":154,"address":[1126947],"length":1,"stats":{"Line":4}},{"line":157,"address":[1126952,1127047],"length":1,"stats":{"Line":8}},{"line":158,"address":[915680],"length":1,"stats":{"Line":12}},{"line":159,"address":[915723,915861],"length":1,"stats":{"Line":4}},{"line":160,"address":[984549,984652,984495],"length":1,"stats":{"Line":9}},{"line":161,"address":[916024,915981,916068],"length":1,"stats":{"Line":11}},{"line":165,"address":[581015],"length":1,"stats":{"Line":7}},{"line":168,"address":[581789,581088,581795],"length":1,"stats":{"Line":6}},{"line":169,"address":[581190],"length":1,"stats":{"Line":2}},{"line":170,"address":[581513,581202,581274],"length":1,"stats":{"Line":10}},{"line":171,"address":[1127870],"length":1,"stats":{"Line":6}},{"line":174,"address":[1127875],"length":1,"stats":{"Line":2}},{"line":175,"address":[984752],"length":1,"stats":{"Line":5}},{"line":176,"address":[984893,984787],"length":1,"stats":{"Line":3}},{"line":177,"address":[916269,916354,916208],"length":1,"stats":{"Line":7}},{"line":178,"address":[785556],"length":1,"stats":{"Line":5}},{"line":182,"address":[1128113],"length":1,"stats":{"Line":7}},{"line":189,"address":[1205920],"length":1,"stats":{"Line":4}},{"line":190,"address":[581880],"length":1,"stats":{"Line":4}},{"line":191,"address":[581900,582614],"length":1,"stats":{"Line":6}},{"line":192,"address":[1128544,1128805,1128957,1128493],"length":1,"stats":{"Line":11}},{"line":193,"address":[1128828,1128923,1129046,1128778],"length":1,"stats":{"Line":14}},{"line":194,"address":[1129058,1128935,1129017],"length":1,"stats":{"Line":5}},{"line":196,"address":[1206627],"length":1,"stats":{"Line":3}},{"line":198,"address":[1128995],"length":1,"stats":{"Line":2}},{"line":201,"address":[1206241],"length":1,"stats":{"Line":2}},{"line":206,"address":[1206800],"length":1,"stats":{"Line":5}},{"line":212,"address":[582812],"length":1,"stats":{"Line":3}},{"line":213,"address":[582853],"length":1,"stats":{"Line":5}},{"line":215,"address":[1129270],"length":1,"stats":{"Line":3}},{"line":216,"address":[582906,583953],"length":1,"stats":{"Line":8}},{"line":217,"address":[583728,583111,583958],"length":1,"stats":{"Line":8}},{"line":220,"address":[1207244,1207805],"length":1,"stats":{"Line":8}},{"line":221,"address":[583707,583281,583224],"length":1,"stats":{"Line":6}},{"line":224,"address":[583250],"length":1,"stats":{"Line":4}},{"line":229,"address":[1130368],"length":1,"stats":{"Line":4}},{"line":230,"address":[584033,584341],"length":1,"stats":{"Line":7}},{"line":231,"address":[1208357,1208390,1208463],"length":1,"stats":{"Line":16}},{"line":236,"address":[1208480],"length":1,"stats":{"Line":8}},{"line":237,"address":[1130801],"length":1,"stats":{"Line":8}},{"line":239,"address":[1130819,1131212],"length":1,"stats":{"Line":10}},{"line":240,"address":[1131042],"length":1,"stats":{"Line":6}},{"line":241,"address":[1131217,1131152,1131109],"length":1,"stats":{"Line":12}},{"line":243,"address":[1131119],"length":1,"stats":{"Line":5}}],"covered":93,"coverable":94},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","src","lib.rs"],"content":"//! Secure Multi-Party Computation (SMPC) using Garbled Circuits for 2 parties.\n//!\n//! This crate implements secure two-party computation based on Yao's Garbled Circuits protocol (1986).\n//! It allows two parties to jointly compute functions over their private inputs without revealing\n//! the inputs to each other. The implementation follows the semi-honest security model.\n//!\n//! # Architecture\n//!\n//! The implementation is structured into several key components:\n//! \n//! - Circuit representation and manipulation (`circuit.rs`)\n//! - Cryptographic primitives and hashing (`hash.rs`)\n//! - Oblivious Transfer protocols (`ot_base.rs`, `leakydelta_ot.rs`)\n//! - Core protocol implementation (`protocol.rs`)\n//! - State machine for protocol execution (`states.rs`)\n//!\n//! Communication channels are deliberately _not_ part of this crate. The sending and receiving of\n//! messages needs to be handled by the user of this crate, which allows the protocol to be used\n//! both in sync and async environments.\n//!\n//! # Examples\n//!\n//! ```\n//! use mpc_core::{\n//!     states::{Contributor, Evaluator, Msg},\n//!     Circuit, Error, Gate,\n//! };\n//! use rand::SeedableRng;\n//! use rand_chacha::ChaCha20Rng;\n//! use std::{\n//!     sync::{mpsc::channel, Arc},\n//!     thread,\n//! };\n//!\n//! fn main() -\u003e Result\u003c(), Error\u003e {\n//!     // Create a simple circuit with 2 input bits, calculate their AND and output it:\n//!     let simple_circuit = Circuit::new(\n//!         vec![Gate::InContrib, Gate::InEval, Gate::And(0, 1)],\n//!         vec![2],\n//!     );\n//!\n//!     let (to_eval, from_contrib) = channel::\u003cMsg\u003e();\n//!     let (to_contrib, from_eval) = channel::\u003cMsg\u003e();\n//!\n//!     // Spawn a contributor as a new thread, with the evaluator remaining on the main thread:\n//!     let circuit_for_contrib_thread = simple_circuit.clone();\n//!     thread::spawn(move || -\u003e Result\u003c(), Error\u003e {\n//!         let contributor_input = vec![true];\n//!\n//!         // Create a contributor and the initial message for the evaluator:\n//!         let (mut contributor, msg) = Contributor::new(\n//!             \u0026circuit_for_contrib_thread,\n//!             contributor_input,\n//!             ChaCha20Rng::from_entropy(),\n//!         )?;\n//!\n//!         // Send initial message to start protocol:\n//!         to_eval.send(msg).unwrap();\n//!\n//!         for _ in 0..contributor.steps() {\n//!             let msg = from_eval.recv().expect(\"failed to get msg\");\n//!\n//!             // Based on the message from the evaluator, the contributor transitions to a new state:\n//!             let (next_state, reply) = contributor.run(\u0026msg)?;\n//!             to_eval.send(reply).expect(\"failed to send reply\");\n//!             contributor = next_state;\n//!         }\n//!         Ok(())\n//!     });\n//!\n//!     let evaluator_input = vec![false];\n//!\n//!     let mut evaluator = Evaluator::new(\n//!         \u0026simple_circuit,\n//!         evaluator_input,\n//!         ChaCha20Rng::from_entropy(),\n//!     )?;\n//!\n//!     for _ in 0..evaluator.steps() {\n//!         let msg = from_contrib.recv().expect(\"failed to get msg\");\n//!\n//!         // Based on the message from the contributor, the evaluator transitions to a new state:\n//!         let (next_state, reply) = evaluator.run(\u0026msg)?;\n//!         to_contrib.send(reply).expect(\"failed to send reply\");\n//!         evaluator = next_state\n//!     }\n//!\n//!     // The final message from the contributor allows the evaluator to decrypt the output:\n//!     let final_msg = from_contrib.recv().expect(\"failed to get final msg\");\n//!     let output = evaluator.output(\u0026final_msg)?;\n//!     assert_eq!(output, vec![false]);\n//!\n//!     Ok(())\n//! }\n//! ```\n\n#![deny(unsafe_code)]\n#![deny(missing_docs)]\n#![deny(rustdoc::broken_intra_doc_links)]\n\nmod circuit;\nmod hash;\nmod leakyand;\nmod leakydelta_ot;\nmod ot_base;\nmod protocol;\nmod simulator;\npub mod states;\nmod types;\n\npub use circuit::*;\npub use simulator::*;\n\n/// Errors occurring during the validation or the execution of the protocol.\n#[derive(Debug, PartialEq, Eq)]\npub enum Error {\n    /// A different message was expected from the other party at this point in the protocol.\n    UnexpectedMessageType,\n    /// The AND shares received did not match the number of gates.\n    InsufficientAndShares,\n    /// The garbled table share does not belong to an AND gate.\n    UnexpectedGarbledTableShare,\n    /// Not enough input bits were provided as user input.\n    InsufficientInput,\n    /// A MAC checking error occurred, due to an accidental or deliberate data corruption.\n    MacError,\n    /// The authenticated AND triples did not pass the equality check.\n    LeakyAndNotEqual,\n    /// The provided circuit contains invalid gate connections.\n    InvalidCircuit,\n    /// The provided circuit has too many gates to be processed.\n    MaxCircuitSizeExceeded,\n    /// The provided byte buffer could not be deserialized into an OT init message.\n    OtInitDeserializationError,\n    /// The provided byte buffer could not be deserialized into an OT block message.\n    OtBlockDeserializationError,\n    /// The provided byte buffer could not be deserialized into the expected type.\n    BincodeError,\n    /// The protocol has already ended, no further messages can be processed.\n    ProtocolEnded,\n    /// The protocol is still in progress and does not yet have any output.\n    ProtocolStillInProgress,\n}\n\nimpl std::error::Error for Error {}\n\nimpl std::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Error::UnexpectedMessageType =\u003e f.write_str(\"Unexpected message kind\"),\n            Error::InsufficientAndShares =\u003e {\n                f.write_str(\"Insufficient number of AND shares received from upstream\")\n            }\n            Error::UnexpectedGarbledTableShare =\u003e {\n                f.write_str(\"Received a table share for an unsupported gate\")\n            }\n            Error::InsufficientInput =\u003e f.write_str(\"Not enough or too many input bits provided\"),\n            Error::MacError =\u003e f.write_str(\"At least 1 MAC check failed\"),\n            Error::LeakyAndNotEqual =\u003e {\n                f.write_str(\"The equality check of the authenticated AND triples failed\")\n            }\n            Error::InvalidCircuit =\u003e {\n                f.write_str(\"The provided circuit is invalid and cannot be executed\")\n            }\n            Error::MaxCircuitSizeExceeded =\u003e f.write_str(\n                \"The number of gates in the circuit exceed the maximum that can be processed\",\n            ),\n            Error::OtInitDeserializationError =\u003e f.write_str(\n                \"The message buffer could not be deserialized into a proper OT init message\",\n            ),\n            Error::OtBlockDeserializationError =\u003e f.write_str(\n                \"The message buffer could not be deserialized into a proper OT block message\",\n            ),\n            Error::BincodeError =\u003e {\n                f.write_str(\"The message could not be serialized to / deserialized from bincode\")\n            }\n            Error::ProtocolEnded =\u003e {\n                f.write_str(\"The protocol has already ended, no further messages can be processed.\")\n            }\n            Error::ProtocolStillInProgress =\u003e {\n                f.write_str(\"The protocol is still in progress and does not yet have any output.\")\n            }\n        }\n    }\n}\n\nimpl From\u003cbincode::Error\u003e for Error {\n    fn from(_: bincode::Error) -\u003e Self {\n        Self::BincodeError\n    }\n}\n","traces":[{"line":148,"address":[476544],"length":1,"stats":{"Line":0}},{"line":149,"address":[759762],"length":1,"stats":{"Line":0}},{"line":150,"address":[759797],"length":1,"stats":{"Line":0}},{"line":152,"address":[810998],"length":1,"stats":{"Line":0}},{"line":155,"address":[759863],"length":1,"stats":{"Line":0}},{"line":157,"address":[811064],"length":1,"stats":{"Line":0}},{"line":158,"address":[811097],"length":1,"stats":{"Line":0}},{"line":160,"address":[759962],"length":1,"stats":{"Line":0}},{"line":163,"address":[759995],"length":1,"stats":{"Line":0}},{"line":165,"address":[811196],"length":1,"stats":{"Line":0}},{"line":168,"address":[811229],"length":1,"stats":{"Line":0}},{"line":171,"address":[811259],"length":1,"stats":{"Line":0}},{"line":175,"address":[760121],"length":1,"stats":{"Line":0}},{"line":178,"address":[760151],"length":1,"stats":{"Line":0}},{"line":181,"address":[760181],"length":1,"stats":{"Line":0}},{"line":188,"address":[760224],"length":1,"stats":{"Line":0}},{"line":189,"address":[760233],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","src","ot_base.rs"],"content":"use curve25519_dalek_ng::constants::RISTRETTO_BASEPOINT_TABLE;\nuse curve25519_dalek_ng::ristretto::RistrettoPoint;\nuse curve25519_dalek_ng::scalar::Scalar;\nuse rand_core::{RngCore, CryptoRng};\n\npub(crate) const MSG_LEN: usize = 32;\n\n/// The type of (random) message exchanged via the Base OT Protocol.\npub(crate) type OtMessage = [u8; MSG_LEN];\n\n/// The party sending data to a [`Receiver`].\n#[derive(Clone)]\npub(crate) struct Sender {\n    private_key: Scalar,\n    pub_key: RistrettoPoint,\n    pub_key_squared: RistrettoPoint,\n}\n\n/// The party choosing 1-out-of-2 pieces of data.\n#[derive(Clone)]\npub(crate) struct Receiver {\n    private_key: Scalar,\n    upstream_pub_key: RistrettoPoint,\n    choice: bool,\n}\n\n/// The kind of messages exchanged between a [`Sender`] and a [`Receiver`].\npub(crate) mod message {\n    use std::slice;\n\n    use curve25519_dalek_ng::ristretto::{CompressedRistretto, RistrettoPoint};\n\n    use crate::Error;\n\n    use super::OtMessage;\n\n    /// Message to initiate the protocol.\n    #[derive(Debug, Copy, Clone, Default, PartialEq)]\n    pub(crate) struct Init(pub(crate) RistrettoPoint);\n\n    /// Reply to the [`Init`] message.\n    #[derive(Default, Debug, Clone, Copy, PartialEq)]\n    pub(crate) struct InitReply(pub(super) [OtMessage; 2]);\n\n    impl Init {\n        pub(crate) fn serialize_to_buffer(\u0026self, buffer: \u0026mut Vec\u003cu8\u003e) {\n            buffer.extend(self.0.compress().as_bytes());\n        }\n\n        pub(crate) fn deserialize_from_buffer(buffer: \u0026mut slice::Iter\u003cu8\u003e) -\u003e Result\u003cSelf, Error\u003e {\n            let key_bytes = read_key_from_buffer(buffer)?;\n            let point = CompressedRistretto(key_bytes)\n                .decompress()\n                .ok_or(Error::OtInitDeserializationError)?;\n\n            Ok(Self(point))\n        }\n    }\n\n    impl InitReply {\n        pub(crate) fn serialize_to_buffer(\u0026self, buffer: \u0026mut Vec\u003cu8\u003e) {\n            buffer.extend(self.0[0]);\n            buffer.extend(self.0[1]);\n        }\n\n        pub(crate) fn deserialize_from_buffer(buffer: \u0026mut slice::Iter\u003cu8\u003e) -\u003e Result\u003cSelf, Error\u003e {\n            let blinding_keys = [read_key_from_buffer(buffer)?, read_key_from_buffer(buffer)?];\n            Ok(Self(blinding_keys))\n        }\n    }\n\n    fn read_key_from_buffer(buffer: \u0026mut slice::Iter\u003cu8\u003e) -\u003e Result\u003cOtMessage, Error\u003e {\n        let mut key = [0u8; super::MSG_LEN];\n        for b in \u0026mut key {\n            *b = *buffer.next().ok_or(Error::OtInitDeserializationError)?;\n        }\n        Ok(key)\n    }\n}\n\nimpl Sender {\n    /// Creates a new OT protocol sender.\n    pub(crate) fn new\u003cRNG\u003e(rng: \u0026mut RNG) -\u003e Self\n    where\n        RNG: RngCore + CryptoRng,\n    {\n        let private_key = Scalar::random(rng);\n        let pub_key = \u0026RISTRETTO_BASEPOINT_TABLE * \u0026private_key;\n        let pub_key_squared = pub_key * private_key;\n\n        Self {\n            private_key,\n            pub_key,\n            pub_key_squared,\n        }\n    }\n\n    /// Creates an [`message::Init`] message.\n    pub(crate) fn init_message(\u0026self) -\u003e message::Init {\n        message::Init(self.pub_key)\n    }\n\n    /// The logical \"send\" part of the protocol.\n    pub(crate) fn send(\n        \u0026self,\n        upstream_init: \u0026message::Init,\n        messages: \u0026[OtMessage; 2],\n    ) -\u003e message::InitReply {\n        let upstream_pub_key = upstream_init.0;\n        let my_pub_key_bytes = self.pub_key.compress().to_bytes();\n\n        let mut hasher = blake3::Hasher::new();\n\n        let key0 = {\n            hasher.update(\u0026my_pub_key_bytes);\n            let upstream_bytes = (upstream_pub_key * self.private_key).compress().to_bytes();\n            hasher.update(\u0026upstream_bytes);\n            let hash = hasher.finalize();\n            Self::xor_keys(hash.as_bytes(), \u0026messages[0])\n        };\n        hasher.reset();\n\n        let key1 = {\n            hasher.update(\u0026my_pub_key_bytes);\n            let upstream_bytes = ((upstream_pub_key * self.private_key) - self.pub_key_squared)\n                .compress()\n                .to_bytes();\n            hasher.update(\u0026upstream_bytes);\n            let hash = hasher.finalize();\n            Self::xor_keys(hash.as_bytes(), \u0026messages[1])\n        };\n\n        message::InitReply([key0, key1])\n    }\n\n    #[inline]\n    fn xor_keys(lhs: \u0026OtMessage, rhs: \u0026OtMessage) -\u003e OtMessage {\n        let mut result = [0u8; MSG_LEN];\n        for idx in 0..MSG_LEN {\n            result[idx] = lhs[idx] ^ rhs[idx];\n        }\n        result\n    }\n}\n\nimpl Receiver {\n    /// Base OT Receiving function.\n    pub(crate) fn init\u003cRNG\u003e(\n        rng: \u0026mut RNG,\n        upstream_init: \u0026message::Init,\n        choice: bool,\n    ) -\u003e (message::Init, Receiver)\n    where\n        RNG: RngCore + CryptoRng,\n    {\n        let private_key = Scalar::random(rng);\n\n        let upstream_pub_key = upstream_init.0;\n        let my_pub_key = \u0026RISTRETTO_BASEPOINT_TABLE * \u0026private_key;\n\n        let chosen_pub_key = {\n            let choices = [my_pub_key, upstream_pub_key + my_pub_key];\n            choices[usize::from(choice)]\n        };\n\n        let init_msg = message::Init(chosen_pub_key);\n        let receiver = Receiver {\n            private_key,\n            upstream_pub_key,\n            choice,\n        };\n\n        (init_msg, receiver)\n    }\n\n    /// The logical \"receive\" part of the protocol.\n    pub(crate) fn recv(self, upstream_init_reply: message::InitReply) -\u003e OtMessage {\n        let mut hasher = blake3::Hasher::new();\n        hasher.update(\u0026self.upstream_pub_key.compress().to_bytes());\n        hasher.update(\n            \u0026(self.upstream_pub_key * self.private_key)\n                .compress()\n                .to_bytes(),\n        );\n        let hash = hasher.finalize();\n\n        let upstream_blinding_keys = upstream_init_reply.0;\n        let blinding_key = upstream_blinding_keys[self.choice as usize];\n        let mut result = [0u8; MSG_LEN];\n        for idx in 0..MSG_LEN {\n            result[idx] = hash.as_bytes()[idx] ^ blinding_key[idx];\n        }\n\n        result\n    }\n}\n\n#[test]\nfn test_protocol() {\n    use rand_core::{RngCore, SeedableRng};\n    use rand_chacha::ChaCha20Rng;\n\n    let mut rng_send = ChaCha20Rng::from_entropy();\n    let mut rng_recv = ChaCha20Rng::from_entropy();\n\n    for choice in [false, true] {\n        let mut messages = [OtMessage::default(); 2];\n        rng_send.fill_bytes(\u0026mut messages[0]);\n        rng_send.fill_bytes(\u0026mut messages[1]);\n\n        let s = Sender::new(\u0026mut rng_send);\n        let init = Sender::init_message(\u0026s);\n        let (msg, r) = Receiver::init(\u0026mut rng_recv, \u0026init, choice);\n        let reply = s.send(\u0026msg, \u0026messages);\n\n        let key = r.recv(reply);\n\n        assert_eq!(key, messages[choice as usize]);\n        assert_ne!(key, messages[if choice { 0 } else { 1 }]);\n    }\n}\n","traces":[{"line":46,"address":[1211680],"length":1,"stats":{"Line":5}},{"line":47,"address":[1211704],"length":1,"stats":{"Line":6}},{"line":50,"address":[535072],"length":1,"stats":{"Line":5}},{"line":51,"address":[535096],"length":1,"stats":{"Line":5}},{"line":52,"address":[1133729,1133647,1133810],"length":1,"stats":{"Line":10}},{"line":54,"address":[1133799,1133721],"length":1,"stats":{"Line":6}},{"line":56,"address":[535418],"length":1,"stats":{"Line":6}},{"line":61,"address":[535504],"length":1,"stats":{"Line":3}},{"line":62,"address":[1133971],"length":1,"stats":{"Line":8}},{"line":63,"address":[535601],"length":1,"stats":{"Line":3}},{"line":66,"address":[535664],"length":1,"stats":{"Line":5}},{"line":67,"address":[1212382],"length":1,"stats":{"Line":3}},{"line":68,"address":[1212788],"length":1,"stats":{"Line":6}},{"line":72,"address":[1212864],"length":1,"stats":{"Line":5}},{"line":73,"address":[1212894],"length":1,"stats":{"Line":5}},{"line":74,"address":[1212911,1213250],"length":1,"stats":{"Line":10}},{"line":75,"address":[1213199,1212999],"length":1,"stats":{"Line":5}},{"line":77,"address":[1213078],"length":1,"stats":{"Line":5}},{"line":83,"address":[1120848],"length":1,"stats":{"Line":6}},{"line":87,"address":[475720],"length":1,"stats":{"Line":4}},{"line":88,"address":[1120883],"length":1,"stats":{"Line":7}},{"line":89,"address":[1120906],"length":1,"stats":{"Line":4}},{"line":99,"address":[985024],"length":1,"stats":{"Line":4}},{"line":100,"address":[1055736],"length":1,"stats":{"Line":7}},{"line":104,"address":[1056831,1055792,1056837],"length":1,"stats":{"Line":7}},{"line":109,"address":[1055873],"length":1,"stats":{"Line":3}},{"line":110,"address":[1055880],"length":1,"stats":{"Line":7}},{"line":112,"address":[985245],"length":1,"stats":{"Line":4}},{"line":115,"address":[1055965],"length":1,"stats":{"Line":7}},{"line":116,"address":[985342],"length":1,"stats":{"Line":4}},{"line":117,"address":[1056171],"length":1,"stats":{"Line":7}},{"line":118,"address":[1056203],"length":1,"stats":{"Line":4}},{"line":119,"address":[325246],"length":1,"stats":{"Line":7}},{"line":121,"address":[985589],"length":1,"stats":{"Line":5}},{"line":124,"address":[325304],"length":1,"stats":{"Line":4}},{"line":125,"address":[985645],"length":1,"stats":{"Line":5}},{"line":128,"address":[985857],"length":1,"stats":{"Line":4}},{"line":129,"address":[985889],"length":1,"stats":{"Line":5}},{"line":130,"address":[985924],"length":1,"stats":{"Line":4}},{"line":133,"address":[325666],"length":1,"stats":{"Line":4}},{"line":137,"address":[325872],"length":1,"stats":{"Line":4}},{"line":138,"address":[1056901],"length":1,"stats":{"Line":7}},{"line":139,"address":[1056918,1057169],"length":1,"stats":{"Line":8}},{"line":140,"address":[986491,986376,986305],"length":1,"stats":{"Line":11}},{"line":142,"address":[1057011],"length":1,"stats":{"Line":4}},{"line":148,"address":[475968],"length":1,"stats":{"Line":4}},{"line":156,"address":[1198900],"length":1,"stats":{"Line":5}},{"line":158,"address":[1198916],"length":1,"stats":{"Line":5}},{"line":159,"address":[1198931],"length":1,"stats":{"Line":5}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[1121229],"length":1,"stats":{"Line":5}},{"line":163,"address":[1199099,1199353],"length":1,"stats":{"Line":6}},{"line":166,"address":[1121438],"length":1,"stats":{"Line":4}},{"line":173,"address":[1199288],"length":1,"stats":{"Line":7}},{"line":177,"address":[1057200,1058131],"length":1,"stats":{"Line":3}},{"line":178,"address":[1057227],"length":1,"stats":{"Line":5}},{"line":179,"address":[1057246,1057310],"length":1,"stats":{"Line":8}},{"line":180,"address":[1057516],"length":1,"stats":{"Line":5}},{"line":181,"address":[1057371],"length":1,"stats":{"Line":3}},{"line":185,"address":[986857],"length":1,"stats":{"Line":4}},{"line":187,"address":[986886],"length":1,"stats":{"Line":4}},{"line":188,"address":[986909,987026],"length":1,"stats":{"Line":4}},{"line":189,"address":[986972],"length":1,"stats":{"Line":3}},{"line":190,"address":[986991,987407,987061],"length":1,"stats":{"Line":13}},{"line":191,"address":[987268,987175,987417],"length":1,"stats":{"Line":10}},{"line":194,"address":[987192],"length":1,"stats":{"Line":4}}],"covered":65,"coverable":66},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","src","protocol","cointossing.rs"],"content":"//! Implements a secure coin tossing protocol between two parties.\n//!\n//! This protocol allows 2 parties to generate the same random values that can be used\n//! to seed their RNGs with the same seed.\n//!\n//! Protocol steps:\n//! 1. Initialize with [`init`] to get a commitment message\n//! 2. Use [`serialize`] on the coin share\n//! 3. Finish with [`finish`] using the other party's commitment and share messages\n\nuse crate::Error;\nuse serde::{Serialize, Deserialize};\n\n/// Number of bits for a coin.\npub(crate) const COIN_LEN: usize = 32;\n/// Number of bits for a commitment.\nconst HASH_LEN: usize = blake3::OUT_LEN;\n\n#[derive(Clone, Serialize, Deserialize)]\npub(crate) struct CoinShare([u8; COIN_LEN]);\n\n/// Result of the coin tossing protocol.\npub(crate) type CoinResult = [u8; COIN_LEN];\n\n/// Creates a new coinshare and a message to be shared with another party.\npub(crate) fn init(coin: [u8; COIN_LEN]) -\u003e Result\u003c(CoinShare, Vec\u003cu8\u003e), Error\u003e {\n    let hash = hash_coinshare(\u0026coin);\n    let msg = bincode::serialize(\u0026hash)?;\n    let coin_share = CoinShare(coin);\n    Ok((coin_share, msg))\n}\n\n/// Serializes a CoinShare to be disclosed to another party at the 2nd protocol step.\npub(crate) fn serialize(cs: \u0026CoinShare) -\u003e Result\u003cVec\u003cu8\u003e, Error\u003e {\n    let msg = bincode::serialize(\u0026cs.0)?;\n    Ok(msg)\n}\n\n/// Verifies the upstream coinshare and returns the resulting coin.\npub(crate) fn finish(\n    coin_share: CoinShare,\n    upstream_hash_msg: Vec\u003cu8\u003e,\n    upstream_coin: Vec\u003cu8\u003e,\n) -\u003e Result\u003cCoinResult, Error\u003e {\n    let upstream_hash: [u8; HASH_LEN] = bincode::deserialize(\u0026upstream_hash_msg)?;\n    let upstream_coin: [u8; COIN_LEN] = bincode::deserialize(\u0026upstream_coin)?;\n\n    if upstream_hash != hash_coinshare(\u0026upstream_coin) {\n        return Err(Error::MacError);\n    }\n\n    Ok(xor(coin_share.0, upstream_coin))\n}\n\nfn hash_coinshare(s: \u0026[u8; COIN_LEN]) -\u003e [u8; HASH_LEN] {\n    let mut hasher = blake3::Hasher::new();\n    hasher.update(s);\n    let mut output_reader = hasher.finalize_xof();\n    let mut result = [0u8; HASH_LEN];\n    output_reader.fill(\u0026mut result);\n\n    result\n}\n\nfn xor(lhs: [u8; COIN_LEN], rhs: [u8; COIN_LEN]) -\u003e CoinResult {\n    let mut result = [0u8; COIN_LEN];\n    for i in 0..COIN_LEN {\n        result[i] = lhs[i] ^ rhs[i];\n    }\n\n    result\n}\n\n#[test]\nfn test_coinshare() {\n    use rand_core::RngCore;\n    use rand_chacha::ChaCha20Rng;\n    use rand_core::SeedableRng;\n\n    let test_val = (ChaCha20Rng::from_entropy().next_u32() % 255) as u8;\n    let coin1 = [test_val; COIN_LEN];\n    let coin2 = [!test_val; COIN_LEN];\n    let expected = [255u8; COIN_LEN];\n\n    let (coin_share1, commitment_msg1) = init(coin1).unwrap();\n    let coin_msg1 = serialize(\u0026coin_share1).unwrap();\n\n    let (coin_share2, commitment_msg2) = init(coin2).unwrap();\n    let coin_msg2 = serialize(\u0026coin_share2).unwrap();\n\n    assert_eq!(\n        expected,\n        finish(coin_share1, commitment_msg2, coin_msg2).unwrap()\n    );\n    assert_eq!(\n        expected,\n        finish(coin_share2, commitment_msg1, coin_msg1).unwrap()\n    );\n}\n\n#[test]\nfn test_coinshare_fail() {\n    use rand_core::RngCore;\n    use rand_chacha::ChaCha20Rng;\n    use rand_core::SeedableRng;\n    let mut rng = ChaCha20Rng::from_entropy();\n    let mut coin1: [u8; COIN_LEN] = Default::default();\n    let mut coin2: [u8; COIN_LEN] = Default::default();\n    rng.fill_bytes(\u0026mut coin1[0..]);\n    rng.fill_bytes(\u0026mut coin2[0..]);\n    let coin1 = coin1;\n    let coin2 = coin2;\n\n    let corruption_index = (rng.next_u32() as usize) % (COIN_LEN * 8);\n\n    let (coin_share1, _) = init(coin1).unwrap();\n    let (coin_share2_ok, commitment_msg2_ok) = init(coin2.clone()).unwrap();\n    let coin_msg2_ok = serialize(\u0026coin_share2_ok).unwrap();\n\n    let mut coin2 = coin2.clone();\n    coin2[corruption_index / 8] ^= 1 \u003c\u003c (corruption_index % 8);\n\n    let (coin_share2_nok, commitment_msg2_nok) = init(coin2).unwrap();\n    let coin_msg2_nok = serialize(\u0026coin_share2_nok).unwrap();\n\n    assert_eq!(\n        Err(Error::MacError),\n        finish(\n            coin_share1.clone(),\n            commitment_msg2_nok,\n            coin_msg2_ok.clone()\n        )\n    );\n\n    assert_eq!(\n        Err(Error::MacError),\n        finish(\n            coin_share1.clone(),\n            commitment_msg2_ok,\n            coin_msg2_nok.clone()\n        )\n    );\n}\n","traces":[{"line":26,"address":[1214272],"length":1,"stats":{"Line":5}},{"line":27,"address":[1136038],"length":1,"stats":{"Line":5}},{"line":28,"address":[1136048],"length":1,"stats":{"Line":6}},{"line":29,"address":[1136193],"length":1,"stats":{"Line":4}},{"line":30,"address":[1136240],"length":1,"stats":{"Line":6}},{"line":34,"address":[1136384],"length":1,"stats":{"Line":7}},{"line":35,"address":[1214658],"length":1,"stats":{"Line":4}},{"line":36,"address":[1136526],"length":1,"stats":{"Line":5}},{"line":40,"address":[425520,426321],"length":1,"stats":{"Line":6}},{"line":45,"address":[1136688,1137390,1136616],"length":1,"stats":{"Line":7}},{"line":46,"address":[1215644,1215103],"length":1,"stats":{"Line":4}},{"line":48,"address":[1137066],"length":1,"stats":{"Line":5}},{"line":49,"address":[1137239],"length":1,"stats":{"Line":1}},{"line":52,"address":[1215528,1215372],"length":1,"stats":{"Line":8}},{"line":55,"address":[1137424,1137689,1137695],"length":1,"stats":{"Line":5}},{"line":56,"address":[1215709],"length":1,"stats":{"Line":6}},{"line":57,"address":[1137482],"length":1,"stats":{"Line":4}},{"line":58,"address":[426467],"length":1,"stats":{"Line":5}},{"line":59,"address":[1215819],"length":1,"stats":{"Line":5}},{"line":60,"address":[1137582],"length":1,"stats":{"Line":6}},{"line":62,"address":[1137618],"length":1,"stats":{"Line":3}},{"line":65,"address":[1215968],"length":1,"stats":{"Line":4}},{"line":66,"address":[1137736],"length":1,"stats":{"Line":6}},{"line":67,"address":[1137998,1137753],"length":1,"stats":{"Line":8}},{"line":68,"address":[1138008,1137825,1137893],"length":1,"stats":{"Line":10}},{"line":71,"address":[1137843],"length":1,"stats":{"Line":5}}],"covered":26,"coverable":26},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","src","protocol","mod.rs"],"content":"pub(crate) mod cointossing;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","src","simulator.rs"],"content":"//! Simulation environment for secure computation under ideal functionality\n\nuse crate::{\n    states::{Contributor, Evaluator},\n    Circuit, Error,\n};\nuse rand_core::SeedableRng;\nuse rand_chacha::ChaCha20Rng;\n\n/// Simulates the local execution of the circuit using a 2-party secure computation protocol.\n///\n/// The computation is performed using the cryptographic protocol exposed by the\n/// [`Contributor`] and [`Evaluator`]. Messages are exchanged using local message queues,\n/// simulating execution under ideal network conditions.\npub fn simulate(\n    circuit: \u0026Circuit,\n    input_contributor: \u0026[bool],\n    input_evaluator: \u0026[bool],\n) -\u003e Result\u003cVec\u003cbool\u003e, Error\u003e {\n    let mut eval = Evaluator::new(\n        circuit.clone(),\n        input_evaluator,\n        ChaCha20Rng::from_entropy(),\n    )?;\n    let (mut contrib, mut msg_for_eval) =\n        Contributor::new(circuit, input_contributor, ChaCha20Rng::from_entropy())?;\n\n    assert_eq!(contrib.steps(), eval.steps());\n\n    for _ in 0..eval.steps() {\n        let (next_state, msg_for_contrib) = eval.run(\u0026msg_for_eval)?;\n        eval = next_state;\n\n        let (next_state, reply) = contrib.run(\u0026msg_for_contrib)?;\n        contrib = next_state;\n\n        msg_for_eval = reply;\n    }\n    eval.output(\u0026msg_for_eval)\n}\n","traces":[{"line":15,"address":[721168,722957,724720],"length":1,"stats":{"Line":2}},{"line":21,"address":[666074],"length":1,"stats":{"Line":2}},{"line":23,"address":[666095],"length":1,"stats":{"Line":3}},{"line":25,"address":[666590,669441,666515],"length":1,"stats":{"Line":15}},{"line":28,"address":[722179,722108],"length":1,"stats":{"Line":6}},{"line":30,"address":[667090,669193],"length":1,"stats":{"Line":7}},{"line":31,"address":[669397,667715,667203,669344],"length":1,"stats":{"Line":4}},{"line":32,"address":[723428],"length":1,"stats":{"Line":6}},{"line":34,"address":[668388,668625,669300,668464],"length":1,"stats":{"Line":12}},{"line":35,"address":[668849],"length":1,"stats":{"Line":2}},{"line":37,"address":[668929,668988,669077],"length":1,"stats":{"Line":10}},{"line":39,"address":[667687,667347,667488],"length":1,"stats":{"Line":3}}],"covered":12,"coverable":12},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","src","states.rs"],"content":"//! The different states in the secure computation protocol.\n//!\n//! At each step in the protocol, each party ([`Contributor`] and [`Evaluator`]) always expects a\n//! single message from the other party. Based on the message each party either computes the final\n//! output or transitions into a new state, returning a message for the other party.\n//!\n//! The parties are deliberately communication-agnostic and expect the sending and receiving of\n//! messages to be handled by the user of this crate.\n\nuse std::borrow::Borrow;\n\nuse crate::{\n    hash::{garbling_hash, hash, hash_key, hash_keys},\n    leakyand::{compute_leaky_and_hashes, derive_and_shares},\n    leakydelta_ot::{\n        message::{OtInitReply, SerializedOtInit},\n        LeakyOtReceiver, LeakyOtSender, ReceiverInitializer, SenderInitializer, BLOCK_SIZE,\n    },\n    protocol::{\n        self,\n        cointossing::{CoinResult, CoinShare},\n    },\n    types::{\n        AndTableShare, BitShare, Delta, InputMaskShare, KeyType, MacType, PartialBitShare,\n        TableShare, WireLabel, WireMask, WireState, K,\n    },\n    Circuit,\n    Error::{self, *},\n    Gate, GateIndex,\n};\nuse bincode::{deserialize, serialize};\nuse rand_core::{RngCore, SeedableRng};\nuse rand_chacha::ChaCha20Rng;\n\n/// The type of messages exchanged between [`Contributor`] and [`Evaluator`].\npub type Msg = Vec\u003cu8\u003e;\n\nconst TRIPLES: usize = BLOCK_SIZE * 3;\n\n/// The party that contributes its input to the secure computation protocol.\npub struct Contributor\u003cC: Borrow\u003cCircuit\u003e, I: Borrow\u003c[bool]\u003e\u003e {\n    state: Box\u003cContribState\u003e,\n    circuit: C,\n    input: I,\n}\n\n/// The party that evaluates the circuit and the output.\npub struct Evaluator\u003cC: Borrow\u003cCircuit\u003e, I: Borrow\u003c[bool]\u003e\u003e {\n    state: Box\u003cEvalState\u003e,\n    circuit: C,\n    input: I,\n}\n\nimpl\u003cC: Borrow\u003cCircuit\u003e, I: Borrow\u003c[bool]\u003e\u003e Contributor\u003cC, I\u003e {\n    /// Initializes the contributor, returning a state and an initial message for the [`Evaluator`].\n    pub fn new(circuit: C, input: I, rng: ChaCha20Rng) -\u003e Result\u003c(Self, Msg), Error\u003e {\n        let (state, msg) = ContribStep1::init(circuit.borrow(), input.borrow(), rng)?;\n        let contrib = Self {\n            state: Box::new(ContribState::Step1(state)),\n            circuit,\n            input,\n        };\n        Ok((contrib, msg))\n    }\n\n    /// Returns the number of messages that need to be exchanged before the protocol is completed.\n    ///\n    /// When the end state is reached, the contributor's last message will enable the [`Evaluator`]\n    /// to compute the final output.\n    pub fn steps(\u0026self) -\u003e u32 {\n        7\n    }\n\n    /// Executes a single step in the protocol, based on the message received from the [`Evaluator`].\n    pub fn run(self, msg: \u0026[u8]) -\u003e Result\u003c(Contributor\u003cC, I\u003e, Msg), Error\u003e {\n        use ContribState::*;\n\n        let (state, msg) = match *self.state {\n            Step1(s) =\u003e {\n                let (state, msg) = s.run(msg)?;\n                (Box::new(Step1a(state)), msg)\n            }\n            Step1a(s) =\u003e {\n                let (state, msg) = s.run(msg, self.circuit.borrow())?;\n                (Box::new(Step2(state)), msg)\n            }\n            Step2(s) =\u003e {\n                let (state, msg) = s.run(msg)?;\n                (Box::new(Step3(state)), msg)\n            }\n            Step3(s) =\u003e {\n                let (state, msg) = s.run(msg)?;\n                (Box::new(Step4(state)), msg)\n            }\n            Step4(s) =\u003e {\n                let (state, msg) = s.run(msg, self.circuit.borrow())?;\n                (Box::new(Step5(ContribBucketingStep(state))), msg)\n            }\n            Step5(s) =\u003e {\n                let (state, msg) = s.run(msg, self.circuit.borrow(), self.input.borrow())?;\n                (Box::new(Step6(state)), msg)\n            }\n            Step6(s) =\u003e {\n                let ((), msg) = s.run(msg, self.circuit.borrow(), self.input.borrow())?;\n                (Box::new(Done), msg)\n            }\n            Done =\u003e return Err(Error::ProtocolEnded),\n        };\n        let next_state = Contributor {\n            state,\n            circuit: self.circuit,\n            input: self.input,\n        };\n        Ok((next_state, msg))\n    }\n}\n\nimpl\u003cC: Borrow\u003cCircuit\u003e, I: Borrow\u003c[bool]\u003e\u003e Evaluator\u003cC, I\u003e {\n    /// Initializes the evaluator, returning its initial state.\n    pub fn new(circuit: C, input: I, rng: ChaCha20Rng) -\u003e Result\u003cSelf, Error\u003e {\n        let state = EvalStep1::init(circuit.borrow(), input.borrow(), rng)?;\n        Ok(Self {\n            state: Box::new(EvalState::Step1(state)),\n            circuit,\n            input,\n        })\n    }\n\n    /// Returns the number of messages that need to be exchanged before reaching the end state.\n    ///\n    /// After the end state is reached, the evaluator expects one last message from the\n    /// [`Contributor`] to compute the final output.\n    pub fn steps(\u0026self) -\u003e u32 {\n        7\n    }\n\n    /// Executes a single step in the protocol, based on the message received from the [`Contributor`].\n    pub fn run(self, msg: \u0026[u8]) -\u003e Result\u003c(Evaluator\u003cC, I\u003e, Msg), Error\u003e {\n        use EvalState::*;\n\n        let (state, msg) = match *self.state {\n            Step1(s) =\u003e {\n                let (state, msg) = s.run(msg, self.circuit.borrow())?;\n                (Box::new(Step2(state)), msg)\n            }\n            Step2(s) =\u003e {\n                let (state, msg) = s.run(msg)?;\n                (Box::new(Step2a(state)), msg)\n            }\n            Step2a(s) =\u003e {\n                let (state, msg) = s.run(msg, self.circuit.borrow())?;\n                (Box::new(Step3(state)), msg)\n            }\n            Step3(s) =\u003e {\n                let (state, msg) = s.run(msg)?;\n                (Box::new(Step4(state)), msg)\n            }\n            Step4(s) =\u003e {\n                let (state, msg) = s.run(msg)?;\n                (Box::new(Step5(state)), msg)\n            }\n            Step5(s) =\u003e {\n                let (state, msg) = s.run(msg, self.circuit.borrow())?;\n                (Box::new(Step6(state)), msg)\n            }\n            Step6(s) =\u003e {\n                let (state, msg) = s.run(msg, self.circuit.borrow(), self.input.borrow())?;\n                (Box::new(Step8(state)), msg)\n            }\n            Step8(s) =\u003e {\n                let (_, _) = s.run(msg, self.circuit.borrow())?;\n                (Box::new(Done()), vec![])\n            }\n            Done() =\u003e return Err(Error::ProtocolEnded),\n        };\n        let next_state = Evaluator {\n            state,\n            circuit: self.circuit,\n            input: self.input,\n        };\n        Ok((next_state, msg))\n    }\n\n    /// Returns the output of the computation or `None` if the protocol has not ended.\n    pub fn output(self, msg: \u0026[u8]) -\u003e Result\u003cVec\u003cbool\u003e, Error\u003e {\n        match *self.state {\n            EvalState::Step8(s) =\u003e {\n                let (output, _) = s.run(msg, self.circuit.borrow())?;\n                Ok(output)\n            }\n            _ =\u003e Err(Error::ProtocolStillInProgress),\n        }\n    }\n}\n\ntype MpcResult\u003cS\u003e = Result\u003c(S, Msg), Error\u003e;\n\nenum ContribState {\n    Step1(ContribStep1),\n    Step1a(ContribStep1a),\n    Step2(ContribStep2),\n    Step3(ContribStep3),\n    Step4(ContribStep4),\n    Step5(ContribBucketingStep),\n    Step6(InputProcContrib),\n    Done,\n}\n\nenum EvalState {\n    Step1(EvalStep1),\n    Step2(EvalStep2),\n    Step2a(EvalStep2a),\n    Step3(EvalStep3),\n    Step4(EvalStep4),\n    Step5(EvalStep5),\n    Step6(EvalStep6),\n    Step8(InputProcEval),\n    Done(),\n}\n\n#[derive(Clone)]\nstruct EvalStep1(OtPreInitState);\n\n#[derive(Clone)]\nstruct ContribStep1(OtInitState1);\n\n#[derive(Clone)]\nstruct ContribStep1a(OtInitState3);\n\n#[derive(Clone)]\nstruct EvalStep2(OtInitState2);\n\nstruct EvalStep2a(OtInitState4);\n\n#[derive(Clone)]\nstruct ContribStep2(OtAndsState1);\n\n#[derive(Clone)]\nstruct EvalStep3(OtAndsState2);\n\n#[derive(Clone)]\nstruct ContribStep3(OtAndsState2);\n\n#[derive(Clone)]\nstruct EvalStep4(OtAndsState3);\n\n#[derive(Clone)]\nstruct ContribStep4(OtAndsState4);\n\n#[derive(Clone)]\nstruct ContribBucketingStep(AndsBucketingState);\n\n#[derive(Clone)]\nstruct EvalStep5(OtAndsState5);\n\n#[derive(Clone)]\nstruct EvalStep6(OtAndsState6);\n\n#[derive(Clone)]\nstruct OtPreInitState {\n    rng: ChaCha20Rng,\n}\n\n#[derive(Clone)]\nstruct OtInitState1 {\n    rng: ChaCha20Rng,\n    delta: Delta,\n    r_init: ReceiverInitializer,\n    coin_share: CoinShare,\n    blocks: usize,\n}\n\n#[derive(Clone)]\nstruct OtInitState2 {\n    rng: ChaCha20Rng,\n    delta: Delta,\n    r_init: ReceiverInitializer,\n    s: SenderInitializer,\n    coin_share: CoinShare,\n    coin_commitment: Vec\u003cu8\u003e, //\u003c upstream coin commitment message\n    blocks: usize,\n}\n\n#[derive(Clone)]\nstruct OtInitState3 {\n    rng: ChaCha20Rng,\n    delta: Delta,\n    s: SenderInitializer,\n    r: LeakyOtReceiver,\n    coin: CoinResult,\n    blocks: usize,\n}\n\n#[derive(Clone)]\nstruct OtInitState4 {\n    rng: ChaCha20Rng,\n    delta: Delta,\n    s: LeakyOtSender,\n    coin: CoinResult,\n    blocks: usize,\n    abits: Vec\u003cBitShare\u003e,\n}\n\n#[derive(Clone)]\nstruct OtAndsState1 {\n    rng: ChaCha20Rng,\n    delta: Delta,\n    coin: CoinResult,\n    random_bits: Vec\u003cMacType\u003e,\n    and_triples: Vec\u003cBitShare\u003e,\n    wire_abits: Vec\u003cBitShare\u003e,\n    and_shares: Vec\u003cMacType\u003e,\n    r_and_rand_key: Vec\u003c(MacType, KeyType)\u003e,\n    r_and_rand_hash: Vec\u003cMacType\u003e,\n    r_prime: Vec\u003cMacType\u003e,\n}\n\n#[derive(Clone)]\nstruct OtAndsState2 {\n    rng: ChaCha20Rng,\n    delta: Delta,\n    coin: CoinResult,\n    and_triples: Vec\u003cBitShare\u003e,\n    wire_abits: Vec\u003cBitShare\u003e,\n    and_shares: Vec\u003cMacType\u003e,\n    r_and_rand_key: Vec\u003c(MacType, KeyType)\u003e,\n    r_and_rand_hash: Vec\u003cMacType\u003e,\n    r_prime: Vec\u003cMacType\u003e,\n}\n\n#[derive(Clone)]\nstruct OtAndsState3 {\n    rng: ChaCha20Rng,\n    delta: Delta,\n    coin: CoinResult,\n    and_triples: Vec\u003cBitShare\u003e,\n    wire_abits: Vec\u003cBitShare\u003e,\n    r_and_rand_key: Vec\u003c(MacType, KeyType)\u003e,\n    r_and_rand_hash: Vec\u003cMacType\u003e,\n    r_prime: Vec\u003cMacType\u003e,\n}\n\n#[derive(Clone)]\nstruct OtAndsState4 {\n    rng: ChaCha20Rng,\n    delta: Delta,\n    coin: CoinResult,\n    and_triples: Vec\u003cBitShare\u003e,\n    wire_abits: Vec\u003cBitShare\u003e,\n    r_and_rand_key: Vec\u003c(MacType, KeyType)\u003e,\n    r_and_rand_hash: Vec\u003cMacType\u003e,\n    r_prime: Vec\u003cMacType\u003e,\n}\n\n#[derive(Clone)]\nstruct OtAndsState5 {\n    rng: ChaCha20Rng,\n    delta: Delta,\n    coin: CoinResult,\n    and_triples: Vec\u003cBitShare\u003e,\n    wire_abits: Vec\u003cBitShare\u003e,\n    r_and_rand_key: Vec\u003c(MacType, KeyType)\u003e,\n    r_and_rand_hash: Vec\u003cMacType\u003e,\n    r_prime: Vec\u003cMacType\u003e,\n}\n\n#[derive(Clone)]\nstruct AndsBucketingState {\n    rng: ChaCha20Rng,\n    delta: Delta,\n    bucketing_bits: Vec\u003cbool\u003e,\n    wire_abits: Vec\u003cBitShare\u003e,\n    and_triples: Vec\u003cBitShare\u003e,\n    permutation: Vec\u003cu32\u003e,\n    length: usize, // number of resulting and triples\n    bucket_size: usize,\n}\n\n#[derive(Clone)]\nstruct OtAndsState6 {\n    delta: Delta,\n    and_triples: Vec\u003cBitShare\u003e,\n    masks: Vec\u003cWireMask\u003e,\n    lhs_and_bits: Vec\u003cbool\u003e,\n    rhs_and_bits: Vec\u003cbool\u003e,\n}\n\n/// WRK17 \"input processing phase\".\n#[derive(Clone)]\nstruct InputProcContrib {\n    delta: Delta,\n    pending_from_b: usize,\n    mac_checks_success: bool,\n    masks: Vec\u003cWireMask\u003e,\n}\n\n/// WRK17 \"input processing phase\" / \"circuit evaluation phase\".\nstruct InputProcEval {\n    delta: Delta,\n    pending_input: usize,\n    masks: Vec\u003cWireMask\u003e,\n    wires: Vec\u003cWireState\u003e,\n}\n\nimpl EvalStep1 {\n    pub(crate) fn init(circuit: \u0026Circuit, input: \u0026[bool], rng: ChaCha20Rng) -\u003e Result\u003cSelf, Error\u003e {\n        circuit.validate_evaluator_input(input)?;\n        let state = OtPreInitState { rng };\n        Ok(Self(state))\n    }\n}\n\nimpl ContribStep1 {\n    pub(crate) fn init(\n        circuit: \u0026Circuit,\n        input: \u0026[bool],\n        mut rng: ChaCha20Rng,\n    ) -\u003e Result\u003c(Self, Msg), Error\u003e {\n        circuit.validate_contributor_input(input)?;\n        let (state, msg) = init_ot1(Delta::gen_random(\u0026mut rng), rng, circuit)?;\n        Ok((Self(state), msg))\n    }\n}\n\nimpl EvalStep1 {\n    fn run(mut self, msg: \u0026[u8], circuit: \u0026Circuit) -\u003e MpcResult\u003cEvalStep2\u003e {\n        let (state, reply1) = init_ot1(Delta::gen_random(\u0026mut self.0.rng), self.0.rng, circuit)?;\n        let (state, reply2) = init_ot2(state, msg)?;\n        let reply = serialize(\u0026(reply1, reply2))?;\n        Ok((EvalStep2(state), reply))\n    }\n}\n\nimpl ContribStep1 {\n    fn run(self, msg: \u0026[u8]) -\u003e MpcResult\u003cContribStep1a\u003e {\n        let (msg1, msg2): (Msg, Msg) = deserialize(msg)?;\n        let (state, reply1) = init_ot2(self.0, \u0026msg1)?;\n        let (state, reply2) = init_ot3(state, \u0026msg2)?;\n        let reply = serialize(\u0026(reply1, reply2))?;\n        Ok((ContribStep1a(state), reply))\n    }\n}\n\nimpl EvalStep2 {\n    fn run(self, msg: \u0026[u8]) -\u003e MpcResult\u003cEvalStep2a\u003e {\n        let (msg1, msg2): (Msg, Msg) = deserialize(msg)?;\n        let (state, reply1) = init_ot3(self.0, \u0026msg1)?;\n        let (state, reply2) = init_ot4(state, msg2)?;\n        let reply = serialize(\u0026(reply1, reply2))?;\n        Ok((EvalStep2a(state), reply))\n    }\n}\n\nimpl ContribStep1a {\n    fn run(self, msg: \u0026[u8], circuit: \u0026Circuit) -\u003e MpcResult\u003cContribStep2\u003e {\n        let (msg1, msg2): (Msg, Msg) = deserialize(msg)?;\n        let (state, reply1) = init_ot4(self.0, msg1)?;\n        let (state, reply2) = ot_ands1(state, \u0026msg2, circuit)?;\n        let reply = serialize(\u0026(reply1, reply2))?;\n        Ok((ContribStep2(state), reply))\n    }\n}\n\nimpl EvalStep2a {\n    fn run(self, msg: \u0026[u8], circuit: \u0026Circuit) -\u003e MpcResult\u003cEvalStep3\u003e {\n        let (msg1, msg2): (Msg, Msg) = deserialize(msg)?;\n        let (state, reply) = ot_ands1(self.0, \u0026msg1, circuit)?;\n\n        // Step 2 of `_{LaAND}`\n        let and_hashes: Vec\u003c[MacType; 2]\u003e = deserialize(\u0026msg2)?;\n        let and_shares = state.compute_and_shares(\u0026and_hashes, Role::Evaluator)?;\n        let state = OtAndsState2 {\n            rng: state.rng,\n            delta: state.delta,\n            coin: state.coin,\n            and_triples: state.and_triples,\n            wire_abits: state.wire_abits,\n            r_and_rand_key: state.r_and_rand_key,\n            r_and_rand_hash: state.r_and_rand_hash,\n            r_prime: state.r_prime,\n            and_shares,\n        };\n        Ok((EvalStep3(state), reply))\n    }\n}\n\nimpl ContribStep2 {\n    // Implements Step 2 of `_{LaAND}` of WRK17a\n    fn run(self, msg: \u0026[u8]) -\u003e MpcResult\u003cContribStep3\u003e {\n        let and_hashes: Vec\u003c[MacType; 2]\u003e = deserialize(msg)?;\n        let state = self.0;\n        let and_shares = state.compute_and_shares(\u0026and_hashes, Role::Contributor)?;\n        let reply = serialize(\u0026and_shares)?;\n        let state = OtAndsState2 {\n            rng: state.rng,\n            delta: state.delta,\n            coin: state.coin,\n            and_triples: state.and_triples,\n            wire_abits: state.wire_abits,\n            r_and_rand_key: state.r_and_rand_key,\n            r_and_rand_hash: state.r_and_rand_hash,\n            r_prime: state.r_prime,\n            and_shares: state.and_shares,\n        };\n        Ok((ContribStep3(state), reply))\n    }\n}\n\n/// Receives its message from [`ContribStep2`] which is a (large) vector of `AND` shares.\nimpl EvalStep3 {\n    fn run(self, msg: \u0026[u8]) -\u003e MpcResult\u003cEvalStep4\u003e {\n        let (state, replies) = ot_ands3_update_z2_eval(self.0, msg)?;\n        let reply = serialize(\u0026replies)?;\n        Ok((EvalStep4(state), reply))\n    }\n}\n\nimpl ContribStep3 {\n    fn run(self, msg: \u0026[u8]) -\u003e MpcResult\u003cContribStep4\u003e {\n        let (msg1, msg2): (Msg, Msg) = deserialize(msg)?;\n        let (state, reply1) = ot_ands3_update_z2_contrib(self.0, \u0026msg1)?;\n        let (state, reply2) = ot_ands4(state, \u0026msg2)?;\n        let reply = serialize(\u0026(reply1, reply2))?;\n        Ok((ContribStep4(state), reply))\n    }\n}\n\nimpl EvalStep4 {\n    fn run(self, msg: \u0026[u8]) -\u003e MpcResult\u003cEvalStep5\u003e {\n        let (msg1, msg2): (Msg, Msg) = deserialize(msg)?;\n        let (state, reply1) = ot_ands4(self.0, \u0026msg1)?;\n        let (state, reply2) = ot_ands5(state, \u0026msg2)?;\n        let reply = serialize(\u0026(reply1, reply2))?;\n        Ok((EvalStep5(state), reply))\n    }\n}\n\nimpl ContribStep4 {\n    fn run(self, msg: \u0026[u8], circuit: \u0026Circuit) -\u003e MpcResult\u003cAndsBucketingState\u003e {\n        let (msg1, msg2): (Msg, Msg) = deserialize(msg)?;\n        let (state, reply1) = ot_ands5(self.0, \u0026msg1)?;\n        let (state, reply2) = ot_ands6(state, \u0026msg2, circuit)?;\n        let reply = serialize(\u0026(reply1, reply2))?;\n        Ok((state, reply))\n    }\n}\n\nimpl EvalStep5 {\n    fn run(self, msg: \u0026[u8], circuit: \u0026Circuit) -\u003e MpcResult\u003cEvalStep6\u003e {\n        let (msg1, msg2): (Msg, Msg) = deserialize(msg)?;\n        let (state, reply1) = ot_ands6(self.0, \u0026msg1, circuit)?;\n        let (state, reply2) = state.finish(\u0026msg2, circuit)?;\n\n        let msg = serialize(\u0026(reply1, reply2))?;\n        Ok((EvalStep6(state), msg))\n    }\n}\n\nimpl ContribBucketingStep {\n    fn run(self, msg: \u0026[u8], circuit: \u0026Circuit, input: \u0026[bool]) -\u003e MpcResult\u003cInputProcContrib\u003e {\n        let (msg1, msg2): (Msg, Msg) = deserialize(msg)?;\n        let (state, reply1) = self.0.finish(\u0026msg1, circuit)?;\n        let (state, reply2) = ot_ands8_contrib(state, \u0026msg2, circuit, input)?;\n\n        let msg = serialize(\u0026(reply1, reply2))?;\n        Ok((state, msg))\n    }\n}\n\nimpl EvalStep6 {\n    fn run(self, msg: \u0026[u8], circuit: \u0026Circuit, input: \u0026[bool]) -\u003e MpcResult\u003cInputProcEval\u003e {\n        let (msg1, msg2): (Msg, Msg) = deserialize(msg)?;\n        let (state, reply) = ot_ands8_eval(self.0, \u0026msg1, \u0026msg2, circuit, input)?;\n        Ok((state, reply))\n    }\n}\n\ntype StateResult\u003cS\u003e = Result\u003c(S, Msg), Error\u003e;\n\n/// Calculates the bucket size for statistical security.\nfn bucket_size(circuit: \u0026Circuit) -\u003e usize {\n    match circuit.and_gates() {\n        n if n \u003e= 280_000 =\u003e 3,\n        n if n \u003e= 3_100 =\u003e 4,\n        _ =\u003e 5,\n    }\n}\n\nenum Role {\n    Contributor,\n    Evaluator,\n}\n\nfn init_ot1(delta: Delta, mut rng: ChaCha20Rng, p: \u0026Circuit) -\u003e StateResult\u003cOtInitState1\u003e {\n    p.validate()?;\n\n    // the number of authenticated bits we need for wires\n    let wire_abits = p.and_gates() + p.eval_inputs() + p.contrib_inputs();\n\n    // the number of authenticated bits need for AND triples\n    let triples_bits = p.and_gates() * 3 * bucket_size(p);\n    let triples_bits_aligned = (triples_bits + TRIPLES - 1) / TRIPLES * TRIPLES;\n    let total_abits = wire_abits + triples_bits_aligned;\n    let num_abits_aligned = (total_abits + BLOCK_SIZE - 1) / BLOCK_SIZE * BLOCK_SIZE;\n    let (r_init, ot_msg) = ReceiverInitializer::init(\u0026mut rng);\n    let (coin_share, coin_msg) = {\n        let mut coin = [0u8; protocol::cointossing::COIN_LEN];\n        rng.fill_bytes(\u0026mut coin);\n        protocol::cointossing::init(coin)?\n    };\n\n    let msg = serialize(\u0026(\u0026ot_msg.serialize(), \u0026coin_msg))?;\n    let state = OtInitState1 {\n        rng,\n        delta,\n        r_init,\n        coin_share,\n        blocks: num_abits_aligned / BLOCK_SIZE,\n    };\n    Ok((state, msg))\n}\n\nfn init_ot2(mut state: OtInitState1, msg: \u0026[u8]) -\u003e StateResult\u003cOtInitState2\u003e {\n    let (serialized_ot_init, coin_commitment): (SerializedOtInit, Vec\u003cu8\u003e) = deserialize(msg)?;\n    let ot_init = serialized_ot_init.deserialize()?;\n    let sender = SenderInitializer::init(\u0026mut state.rng, state.delta.clone(), \u0026ot_init);\n    let coin_msg = protocol::cointossing::serialize(\u0026state.coin_share)?;\n    let msg = serialize(\u0026(sender.1.serialize(), coin_msg))?;\n    let state = OtInitState2 {\n        rng: state.rng,\n        delta: state.delta,\n        r_init: state.r_init,\n        s: sender.0,\n        coin_share: state.coin_share,\n        coin_commitment,\n        blocks: state.blocks,\n    };\n    Ok((state, msg))\n}\n\nfn init_ot3(state: OtInitState2, msg: \u0026[u8]) -\u003e StateResult\u003cOtInitState3\u003e {\n    let (serialized_ot_init, upstream_coin): (SerializedOtInit, Vec\u003cu8\u003e) = deserialize(msg)?;\n    let coin =\n        protocol::cointossing::finish(state.coin_share, state.coin_commitment, upstream_coin)?;\n    let ot_init = serialized_ot_init.deserialize()?;\n    let (r, reply) = state.r_init.recv(\u0026ot_init);\n    let reply = reply.serialize();\n    let state = OtInitState3 {\n        rng: state.rng,\n        delta: state.delta,\n        s: state.s,\n        r,\n        coin,\n        blocks: state.blocks,\n    };\n    Ok((state, reply))\n}\n\nfn init_ot4(mut state: OtInitState3, msg: Vec\u003cu8\u003e) -\u003e StateResult\u003cOtInitState4\u003e {\n    let init_msg = OtInitReply::deserialize(msg)?;\n    let s = state.s.recv(\u0026init_msg);\n\n    let mut r = state.r;\n    let mut blocks = Vec::new();\n    let mut abits = vec![BitShare::default(); state.blocks * BLOCK_SIZE];\n    for block_id in 0..state.blocks {\n        let mut macs_out = [MacType(0); BLOCK_SIZE];\n        let mut ot_out = Box::new([MacType(0); BLOCK_SIZE]);\n        let bits: u128 = state.rng.next_u64() as u128 | ((state.rng.next_u64() as u128) \u003c\u003c 64);\n        r.new_batch(bits, \u0026mut macs_out, \u0026mut ot_out[0..]);\n\n        let abits = \u0026mut abits[block_id * BLOCK_SIZE..];\n        for i in 0..BLOCK_SIZE {\n            abits[i].mac = MacType(macs_out[i].0);\n            abits[i].bit = bits \u0026 (1 \u003c\u003c i) != 0;\n        }\n        blocks.push(ot_out.to_vec());\n    }\n    let reply = serialize(\u0026blocks)?;\n\n    let state = OtInitState4 {\n        rng: state.rng,\n        delta: state.delta,\n        blocks: state.blocks,\n        coin: state.coin,\n        abits,\n        s,\n    };\n    Ok((state, reply))\n}\n\nfn ot_ands1(mut state: OtInitState4, msg: \u0026[u8], circuit: \u0026Circuit) -\u003e StateResult\u003cOtAndsState1\u003e {\n    let blocks: Vec\u003cVec\u003cMacType\u003e\u003e = deserialize(msg)?;\n    for (block_id, block) in blocks.into_iter().enumerate() {\n        let ot_rx: [MacType; BLOCK_SIZE] = block\n            .try_into()\n            .map_err(|_| Error::OtBlockDeserializationError)?;\n        let ot_rx = Box::new(ot_rx);\n        let mut keys_out = [MacType(0); BLOCK_SIZE];\n        state.s.send(ot_rx.as_ref(), \u0026mut keys_out);\n\n        let abits = \u0026mut state.abits[block_id * BLOCK_SIZE..];\n        for i in 0..BLOCK_SIZE {\n            abits[i].key = KeyType(keys_out[i].0);\n        }\n    }\n\n    // the number of authenticated bits we need for wires\n    let n_and_gates = circuit.and_gates();\n    let n_wire_abits = circuit.and_gates() + circuit.eval_inputs() + circuit.contrib_inputs();\n    let abits_blocks = (n_wire_abits + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    assert_eq!(0, (state.blocks - abits_blocks) % 3);\n\n    // split state.abits into 2 parts:\n    // 1. the first part is used for the wires which equals the number of input and AND gates\n    //    aligned by BLOCK_SIZE\n    // 2. the latter part is used for AND triples\n\n    let wire_abits_start = (state.blocks - abits_blocks) * BLOCK_SIZE;\n    let wire_abits = \u0026state.abits[wire_abits_start..wire_abits_start + n_wire_abits];\n\n    let num_blocks = (n_and_gates + BLOCK_SIZE - 1) / BLOCK_SIZE * BLOCK_SIZE;\n    let random_bits = Vec::\u003cMacType\u003e::with_capacity(num_blocks / BLOCK_SIZE);\n    let wire_abits = wire_abits.to_vec();\n\n    let mut triples = state.abits;\n    triples.truncate((state.blocks - abits_blocks) * BLOCK_SIZE);\n\n    let mut state = OtAndsState1 {\n        rng: state.rng,\n        delta: state.delta,\n        coin: state.coin,\n        and_triples: triples,\n        wire_abits: wire_abits.to_vec(),\n        and_shares: Default::default(),\n        random_bits,\n        r_and_rand_key: vec![],\n        r_and_rand_hash: vec![],\n        r_prime: vec![],\n    };\n\n    // Step 1 of `_{LaAND}`\n    let and_hashes = state.compute_and_ot_data();\n    let msg = serialize(\u0026and_hashes)?;\n\n    Ok((state, msg))\n}\n\nimpl OtAndsState1 {\n    fn compute_and_ot_data(\u0026mut self) -\u003e Vec\u003c[MacType; 2]\u003e {\n        let and_bits = \u0026self.and_triples[0..];\n        let num_blocks = and_bits.len() / BLOCK_SIZE / 3;\n\n        self.random_bits.clear();\n\n        let mut result: Vec\u003c[MacType; 2]\u003e = Vec::with_capacity(num_blocks * BLOCK_SIZE);\n        result.resize(num_blocks * BLOCK_SIZE, [MacType(0), MacType(0)]);\n\n        for i in 0..num_blocks {\n            let r: u128 = self.rng.next_u64() as u128 | ((self.rng.next_u64() as u128) \u003c\u003c 64);\n            self.random_bits.push(MacType(r));\n\n            let bits = \u0026and_bits[(i * BLOCK_SIZE * 3)..];\n            let y = collect_y_bits(bits);\n            compute_leaky_and_hashes(\n                \u0026mut result[(i * BLOCK_SIZE)..],\n                \u0026self.delta,\n                r,\n                y.0,\n                \u0026keys(bits),\n            );\n        }\n\n        result\n    }\n\n    fn compute_and_shares(\n        \u0026self,\n        and_hashes: \u0026[[MacType; 2]],\n        role: Role,\n    ) -\u003e Result\u003cVec\u003cMacType\u003e, Error\u003e {\n        let and_bits = \u0026self.and_triples[0..];\n        let num_blocks = and_bits.len() / BLOCK_SIZE / 3;\n\n        if and_hashes.len() != num_blocks * BLOCK_SIZE {\n            return Err(InsufficientAndShares);\n        }\n\n        let mut result: Vec\u003cMacType\u003e = Vec::with_capacity(num_blocks);\n        for i in 0..num_blocks {\n            let bits = \u0026and_bits[(i * BLOCK_SIZE * 3)..];\n            let (x, y, z) = collect_authenticated_bits(bits);\n            let and_bits = derive_and_shares(\n                self.random_bits[i].0,\n                x.0,\n                \u0026macs(bits),\n                \u0026and_hashes[(i * BLOCK_SIZE)..],\n            );\n\n            let and_share = if let Role::Contributor = role {\n                MacType(and_bits.0 ^ (x.0 \u0026 y.0) ^ z.0)\n            } else {\n                and_bits\n            };\n            result.push(and_share);\n        }\n\n        Ok(result)\n    }\n}\n\n/// Implements sub-protoocol _{LaAND} steps 4a+4b (resp. 5a+5b) of WRK17a.\nfn compute_u(delta: \u0026Delta, and_bits: \u0026[BitShare]) -\u003e Vec\u003cMacType\u003e {\n    let mut msgs = Vec::with_capacity(and_bits.len() / 3);\n    for i in (0..and_bits.len()).step_by(3) {\n        let BitShare {\n            key: k_x1,\n            bit: b_x2,\n            ..\n        } = and_bits[i];\n        let BitShare {\n            key: k_y1,\n            bit: b_y2,\n            ..\n        } = and_bits[i + 1];\n        let BitShare {\n            key: k_z1,\n            bit: b_z2,\n            ..\n        } = and_bits[i + 2];\n        let t0 = hash_keys(k_x1, k_z1 ^ (if b_z2 { delta.0 } else { 0 }));\n        let u0 = t0\n            ^ hash_keys(\n                k_x1 ^ delta.0,\n                k_y1 ^ k_z1 ^ (if b_y2 ^ b_z2 { delta.0 } else { 0 }),\n            );\n        let t1 = hash_keys(k_x1, k_y1 ^ k_z1 ^ (if b_y2 ^ b_z2 { delta.0 } else { 0 }));\n        let u1 = t1 ^ hash_keys(k_x1 ^ delta.0, k_z1 ^ (if b_z2 { delta.0 } else { 0 }));\n        let u_for_other_party = if b_x2 { u1 } else { u0 };\n        msgs.push(u_for_other_party);\n    }\n    msgs\n}\n\nfn ot_ands3_update_z2_contrib(mut state: OtAndsState2, msg: \u0026[u8]) -\u003e StateResult\u003cOtAndsState3\u003e {\n    let and_shares: Vec\u003cMacType\u003e = deserialize(msg)?;\n    // Step 3 of `_{LaAND}`\n    let and_bits = \u0026mut state.and_triples[0..];\n    let num_blocks = and_bits.len() / BLOCK_SIZE / 3;\n\n    if and_shares.len() != num_blocks {\n        return Err(InsufficientAndShares);\n    }\n\n    for block in 0..num_blocks {\n        let bits = \u0026mut and_bits[(block * BLOCK_SIZE * 3)..];\n        let z_r_bits = and_shares[block];\n\n        for i in 0..K {\n            if (z_r_bits.0 \u0026 (1 \u003c\u003c i)) != 0 {\n                bits[i * 3 + 2].key.0 ^= state.delta.0;\n            }\n        }\n    }\n\n    // Step 4/5 (a + b) of `_{LaAND}`\n    let u = compute_u(\u0026state.delta, \u0026state.and_triples);\n    let msg = serialize(\u0026u)?;\n    let state = OtAndsState3 {\n        rng: state.rng,\n        delta: state.delta,\n        coin: state.coin,\n        and_triples: state.and_triples,\n        wire_abits: state.wire_abits,\n        r_and_rand_key: state.r_and_rand_key,\n        r_and_rand_hash: state.r_and_rand_hash,\n        r_prime: state.r_prime,\n    };\n    Ok((state, msg))\n}\n\nfn ot_ands3_update_z2_eval(\n    mut state: OtAndsState2,\n    msg: \u0026[u8],\n) -\u003e Result\u003c(OtAndsState3, (Msg, Msg)), Error\u003e {\n    let upstream_ands: Vec\u003cMacType\u003e = deserialize(msg)?;\n    // Step 3 of `_{LaAND}`\n    let and_bits = \u0026mut state.and_triples[0..];\n    let num_blocks = and_bits.len() / BLOCK_SIZE / 3;\n\n    if and_bits.len() != num_blocks * BLOCK_SIZE * 3 {\n        return Err(InsufficientAndShares);\n    }\n\n    let mut result: Vec\u003cMacType\u003e = Vec::with_capacity(num_blocks);\n    for block in 0..num_blocks {\n        let bits = \u0026mut and_bits[(block * BLOCK_SIZE * 3)..];\n        let (x, y, r) = collect_authenticated_bits(bits);\n        let z_2 = state.and_shares[block].0 ^ (x.0 \u0026 y.0) ^ upstream_ands[block].0;\n        let d = MacType(r.0 ^ z_2);\n\n        result.push(d);\n\n        // update z_2 according to new values\n        for bit_idx in 0..BLOCK_SIZE {\n            bits[bit_idx * 3 + 2].bit ^= (d.0 \u0026 (1 \u003c\u003c bit_idx)) != 0\n        }\n    }\n    let msg1 = serialize(\u0026result)?;\n\n    // Step 4/5 (a + b) of `_{LaAND}`\n    let u = compute_u(\u0026state.delta, \u0026state.and_triples);\n    let msg2 = serialize(\u0026u)?;\n\n    let state = OtAndsState3 {\n        rng: state.rng,\n        delta: state.delta,\n        coin: state.coin,\n        and_triples: state.and_triples,\n        wire_abits: state.wire_abits,\n        r_and_rand_key: state.r_and_rand_key,\n        r_and_rand_hash: state.r_and_rand_hash,\n        r_prime: state.r_prime,\n    };\n    Ok((state, (msg1, msg2)))\n}\n\nfn ot_ands4(mut state: OtAndsState3, msg: \u0026[u8]) -\u003e StateResult\u003cOtAndsState4\u003e {\n    let u_from_other_party: Vec\u003cMacType\u003e = deserialize(msg)?;\n    // Step 4/5 (c + d) of `_{LaAND}`\n    // implementation of Protoocol _{LaAND} steps 4c+4d (resp. 5c+5d) of WRK17a\n    let and_bits = \u0026state.and_triples[0..];\n    let mut r_and_rand = Vec::with_capacity(and_bits.len() / 3);\n    let mut r_and_rand_hashed = Vec::with_capacity(and_bits.len() / 3);\n    let mut w = Vec::with_capacity(and_bits.len() / 3);\n    for i in (0..and_bits.len()).step_by(3) {\n        let BitShare {\n            key: k_x1,\n            mac: m_x2,\n            bit: b_x2,\n        } = and_bits[i];\n        let BitShare { mac: m_y2, .. } = and_bits[i + 1];\n        let BitShare { mac: m_z2, .. } = and_bits[i + 2];\n\n        let r: u128 = state.rng.next_u64() as u128 | ((state.rng.next_u64() as u128) \u003c\u003c 64);\n        let u = u_from_other_party[i / 3];\n        let v0 = hash_keys(m_x2.into(), m_z2.into());\n        let v1 = hash_keys(m_x2.into(), KeyType(m_z2.0) ^ m_y2.0);\n        let (w_x2_0, w_x2_1) = if b_x2 {\n            let w_1_0 = hash_key(k_x1) ^ v1 ^ u.0 ^ r;\n            let w_1_1 = hash_key(k_x1 ^ state.delta.0) ^ v0 ^ u.0 ^ r;\n            (w_1_0, w_1_1)\n        } else {\n            let w_0_0 = hash_key(k_x1) ^ v0 ^ r;\n            let w_0_1 = hash_key(k_x1 ^ state.delta.0) ^ v1 ^ r;\n            (w_0_0, w_0_1)\n        };\n        // hash r + random key for 'commit \u0026 open' eq check\n        let rand_for_eq_box_hash = KeyType(state.rng.next_u64() as u128 | ((state.rng.next_u64() as u128) \u003c\u003c 64));\n        let hash_for_commit = hash_keys(KeyType(r), rand_for_eq_box_hash);\n        r_and_rand.push((MacType(r), rand_for_eq_box_hash));\n        r_and_rand_hashed.push(hash_for_commit);\n        w.push((w_x2_0, w_x2_1));\n    }\n    let msg = serialize(\u0026(r_and_rand_hashed, w))?;\n\n    state.r_and_rand_key = r_and_rand;\n\n    let state = OtAndsState4 {\n        rng: state.rng,\n        delta: state.delta,\n        coin: state.coin,\n        and_triples: state.and_triples,\n        wire_abits: state.wire_abits,\n        r_and_rand_key: state.r_and_rand_key,\n        r_and_rand_hash: state.r_and_rand_hash,\n        r_prime: state.r_prime,\n    };\n    Ok((state, msg))\n}\n\nfn ot_ands5(mut state: OtAndsState4, msg: \u0026[u8]) -\u003e StateResult\u003cOtAndsState5\u003e {\n    let (r_and_rand_hashed, w_from_other_party): (Vec\u003cMacType\u003e, Vec\u003c(MacType, MacType)\u003e) =\n        deserialize(msg)?;\n\n    // Step 4/5 (e) of `_{LaAND}`\n    let and_bits = \u0026state.and_triples[0..];\n    let mut r_prime = Vec::with_capacity(and_bits.len() / 3);\n    for i in (0..and_bits.len()).step_by(3) {\n        let BitShare {\n            key: k_x1,\n            mac: m_x2,\n            bit: b_x2,\n        } = and_bits[i];\n        let BitShare {\n            key: k_y1,\n            bit: b_y2,\n            ..\n        } = and_bits[i + 1];\n        let BitShare {\n            key: k_z1,\n            bit: b_z2,\n            ..\n        } = and_bits[i + 2];\n\n        let t0 = hash_keys(k_x1, k_z1 ^ (if b_z2 { state.delta.0 } else { 0 }));\n        let t1 = hash_keys(\n            k_x1,\n            k_y1 ^ k_z1 ^ (if b_y2 ^ b_z2 { state.delta.0 } else { 0 }),\n        );\n        let t_x2 = if b_x2 { t1 } else { t0 };\n        let (w_x1_0, w_x1_1) = w_from_other_party[i / 3];\n        let w_x1_x2 = if b_x2 { w_x1_1 } else { w_x1_0 };\n        r_prime.push(hash(m_x2) ^ w_x1_x2 ^ t_x2);\n    }\n\n    // 'commit' step of F_EQ check\n    state.r_and_rand_hash = r_and_rand_hashed;\n    state.r_prime = r_prime.clone();\n\n    let msg = serialize(\u0026(r_prime, state.r_and_rand_key.clone()))?;\n\n    let state = OtAndsState5 {\n        rng: state.rng,\n        delta: state.delta,\n        coin: state.coin,\n        and_triples: state.and_triples,\n        wire_abits: state.wire_abits,\n        r_and_rand_key: state.r_and_rand_key,\n        r_and_rand_hash: state.r_and_rand_hash,\n        r_prime: state.r_prime,\n    };\n    Ok((state, msg))\n}\n\nfn check_hash(\n    state: \u0026OtAndsState5,\n    r_prime: \u0026[MacType],\n    r_and_rand: \u0026[(MacType, KeyType)],\n) -\u003e Result\u003c(), Error\u003e {\n    if r_prime.len() != r_and_rand.len() || r_prime.len() != state.r_and_rand_key.len() {\n        return Err(UnexpectedMessageType);\n    }\n\n    let mut success = true;\n\n    // 'open' step of F_EQ check\n    for (i, (r, rand_key)) in r_and_rand.iter().enumerate() {\n        let hashed = hash_keys(KeyType(r.0), KeyType(rand_key.0));\n        // check that the hash received previously matches the r + rand received now:\n        let hash_ok = state.r_and_rand_hash[i] == hashed;\n        // check that the r received now matches own r':\n        let r_equal = *r == state.r_prime[i];\n        success \u0026= hash_ok \u0026 r_equal;\n    }\n    for (i, r_prime) in r_prime.iter().enumerate() {\n        // check that the r' received now from the other party matches own r:\n        let r_prime_check = state.r_and_rand_key[i].0 == *r_prime;\n\n        success \u0026= r_prime_check;\n    }\n\n    if !success {\n        Err(LeakyAndNotEqual)\n    } else {\n        Ok(())\n    }\n}\n\nfn compute_hashes_contrib(\n    state: \u0026OtAndsState6,\n    gate_index: usize,\n    output_mask: \u0026WireMask,\n    lhs: \u0026WireMask,\n    rhs: \u0026WireMask,\n    input_mask: \u0026BitShare,\n) -\u003e AndTableShare {\n    let mut h0 = output_mask.bit.xor(input_mask);\n    let mut h1 = h0.xor(\u0026lhs.bit);\n    let mut h2 = h0.xor(\u0026rhs.bit);\n    let mut h3 = h1.xor(\u0026rhs.bit);\n    h3.key.0 ^= state.delta.0;\n\n    let output_label = output_mask.label_0.0;\n    h0.key = KeyType(mac(\u0026state.delta, h0.key.0 ^ output_label, h0.bit));\n    h1.key = KeyType(mac(\u0026state.delta, h1.key.0 ^ output_label, h1.bit));\n    h2.key = KeyType(mac(\u0026state.delta, h2.key.0 ^ output_label, h2.bit));\n    h3.key = KeyType(mac(\u0026state.delta, h3.key.0 ^ output_label, h3.bit));\n\n    let l0 = \u0026lhs.label_0;\n    let l1 = WireLabel(l0.0 ^ state.delta.0);\n    let r0 = \u0026rhs.label_0;\n    let r1 = WireLabel(r0.0 ^ state.delta.0);\n\n    let gi_u32 = gate_index as u32;\n    [\n        h0.xor(\u0026garbling_hash::new(l0, r0, gi_u32, 0)),\n        h1.xor(\u0026garbling_hash::new(l0, \u0026r1, gi_u32, 1)),\n        h2.xor(\u0026garbling_hash::new(\u0026l1, r0, gi_u32, 2)),\n        h3.xor(\u0026garbling_hash::new(\u0026l1, \u0026r1, gi_u32, 3)),\n    ]\n}\n\nfn mac(delta: \u0026Delta, value: u128, bit: bool) -\u003e u128 {\n    value ^ (if bit { delta.0 } else { 0 })\n}\n\n/// Implements Step 2 + 3 + 4a of the preprocessing phase.\nfn preprocessing_assign_masks(\n    abits: Vec\u003cBitShare\u003e,\n    rng: \u0026mut ChaCha20Rng,\n    delta: \u0026Delta,\n    circuit: \u0026Circuit,\n) -\u003e Vec\u003cWireMask\u003e {\n    let mut masks = vec![WireMask::default(); circuit.gates().len()];\n\n    // assign output masks to each wire\n    let mut abit_offset = 0;\n    for (idx, gate) in circuit.gates().iter().enumerate() {\n        match gate {\n            Gate::InContrib | Gate::InEval | Gate::And { .. } =\u003e {\n                // Step 2 `_{2pc}`\n                masks[idx].bit = abits[abit_offset];\n                abit_offset += 1;\n                let label_val = rng.next_u64() as u128 | ((rng.next_u64() as u128) \u003c\u003c 64);\n                masks[idx].label_0 = label_val.into();\n            }\n            _ =\u003e {}\n        }\n    }\n\n    for (idx, gate) in circuit.gates().iter().enumerate() {\n        match gate {\n            Gate::Xor(input_lhs, input_rhs) =\u003e {\n                // Step 3 `_{2pc}`\n                let lhs = \u0026masks[*input_lhs as usize];\n                let rhs = \u0026masks[*input_rhs as usize];\n                masks[idx] = lhs.xor(rhs);\n            }\n            Gate::Not(input) =\u003e {\n                let lhs = \u0026masks[*input as usize];\n                masks[idx] = lhs.not(delta);\n            }\n            _ =\u003e {}\n        }\n    }\n\n    masks\n}\n\n/// Collects XOR of authenticated bits relating to input wires to AND gates.\n///\n/// Returns:\n///   - Tuple #1: XOR of authenticated bits of left-hand side input\n///   - Tuple #2: like #1 but for right-hand side\nfn preprocessing_and_gate_bits(\n    circuit: \u0026Circuit,\n    masks: \u0026[WireMask],\n    and_triples: \u0026[BitShare],\n) -\u003e (Vec\u003cbool\u003e, Vec\u003cbool\u003e) {\n    let mut lhs_bits = Vec::new();\n    let mut rhs_bits = Vec::new();\n\n    let mut ands = 0;\n    for gate in circuit.gates() {\n        if let Gate::And(input_lhs, input_rhs) = gate {\n            lhs_bits.push(masks[*input_lhs as usize].bit.bit ^ and_triples[3 * ands].bit);\n            rhs_bits.push(masks[*input_rhs as usize].bit.bit ^ and_triples[3 * ands + 1].bit);\n            ands += 1;\n        }\n    }\n\n    (lhs_bits, rhs_bits)\n}\n\n/// Implements the preprocessing phase for AND gates.\n///\n/// The protocol processes authenticated AND triples from previous steps and returns a new vector\n/// with AND triples for further processing.\n///\n///   - Function `init`: Starts the process yielding bits and their respective macs.\n///   - Function `finish`: Upon receiving upstream bits, computes the final authenticated AND\n///     triples.\nimpl AndsBucketingState {\n    fn init(state: OtAndsState5, circuit: \u0026Circuit) -\u003e StateResult\u003cAndsBucketingState\u003e {\n        fn new_permutation(mut rng: ChaCha20Rng, total_abits: usize) -\u003e Vec\u003cu32\u003e {\n            let mut permutation = vec![0; total_abits];\n            for (i, item) in permutation.iter_mut().enumerate().take(total_abits) {\n                *item = i as u32;\n            }\n\n            let mut idx: Vec\u003ci32\u003e = vec![0; total_abits];\n            for i in 0..total_abits {\n                idx[i] = rng.next_u32() as i32;\n            }\n            let idx = idx;\n\n            for i in (0..total_abits as i32).rev() {\n                let idx = idx[i as usize] % (i + 1);\n                let idx = if idx \u003c 0 { -idx } else { idx };\n\n                permutation.swap(i as usize, idx as usize);\n            }\n\n            permutation\n        }\n\n        let bucket_size = bucket_size(circuit);\n        let length = circuit.and_gates();\n\n        assert!(state.and_triples.len() \u003e= length * bucket_size);\n\n        let mut bits = vec![false; length * bucket_size];\n        let mut macs = vec![MacType::default(); length * bucket_size];\n\n        let permutation = {\n            let rng = ChaCha20Rng::from_seed(state.coin);\n            new_permutation(rng, length * bucket_size)\n        };\n\n        for i in 0..length {\n            let lhs = permutation[i * bucket_size] as usize;\n\n            for j in 1..bucket_size {\n                let rhs = permutation[i * bucket_size + j] as usize;\n\n                let d = state.and_triples[lhs * 3 + 1].xor(\u0026state.and_triples[rhs * 3 + 1]);\n                bits[i * bucket_size + j] = d.bit;\n                macs[i * bucket_size + j] = d.mac;\n            }\n        }\n\n        let msg = serialize(\u0026(\u0026bits, macs))?;\n\n        let state = AndsBucketingState {\n            rng: state.rng,\n            delta: state.delta,\n            bucketing_bits: bits,\n            wire_abits: state.wire_abits,\n            permutation,\n            and_triples: state.and_triples,\n            length,\n            bucket_size,\n        };\n\n        Ok((state, msg))\n    }\n\n    fn finish(self, msg: \u0026[u8], circuit: \u0026Circuit) -\u003e StateResult\u003cOtAndsState6\u003e {\n        let mut state = self.update_triples(msg)?;\n\n        let wire_abits = state.wire_abits;\n        let masks = preprocessing_assign_masks(wire_abits, \u0026mut state.rng, \u0026state.delta, circuit);\n        let (lhs_and_bits, rhs_and_bits) =\n            preprocessing_and_gate_bits(circuit, \u0026masks, \u0026state.and_triples);\n        let msg = serialize(\u0026(\u0026lhs_and_bits, \u0026rhs_and_bits))?;\n\n        let state = OtAndsState6 {\n            delta: state.delta,\n            and_triples: state.and_triples,\n            masks,\n            lhs_and_bits,\n            rhs_and_bits,\n        };\n\n        Ok((state, msg))\n    }\n\n    /// Updates the triples and performs verification checks.\n    fn update_triples(self, msg: \u0026[u8]) -\u003e Result\u003cAndsBucketingState, Error\u003e {\n        assert!(self.bucketing_bits.len() == self.length * self.bucket_size);\n\n        let (upstream_bits, upstream_macs): (Vec\u003cbool\u003e, Vec\u003cMacType\u003e) = deserialize(msg)?;\n        if upstream_bits.len() != self.bucketing_bits.len()\n            || upstream_macs.len() != self.bucketing_bits.len()\n        {\n            return Err(Error::InsufficientInput);\n        }\n\n        let perm = \u0026self.permutation;\n\n        // Verify the authenticated bits\n        {\n            let mut checks_succeeded = 0;\n            for i in 0..self.length {\n                let lhs = perm[i * self.bucket_size] as usize;\n\n                for j in 1..self.bucket_size {\n                    let rhs = perm[i * self.bucket_size + j] as usize;\n                    let d = self.and_triples[lhs * 3 + 1].xor(\u0026self.and_triples[rhs * 3 + 1]);\n                    let upstream_bs = PartialBitShare {\n                        bit: upstream_bits[i * self.bucket_size + j],\n                        mac: upstream_macs[i * self.bucket_size + j],\n                    };\n\n                    checks_succeeded += upstream_bs.verify(\u0026d.key, \u0026self.delta) as usize;\n                }\n            }\n            if checks_succeeded != self.length * (self.bucket_size - 1) {\n                return Err(Error::MacError);\n            }\n        }\n\n        // Update the authenticated bits\n        let mut bucketing_bits = self.bucketing_bits;\n        for i in 0..bucketing_bits.len() {\n            bucketing_bits[i] ^= upstream_bits[i];\n        }\n\n        Ok(AndsBucketingState {\n            rng: self.rng,\n            delta: self.delta,\n            bucketing_bits,\n            wire_abits: self.wire_abits,\n            permutation: self.permutation,\n            and_triples: self.and_triples,\n            length: self.length,\n            bucket_size: self.bucket_size,\n        })\n    }\n}\n\nfn ot_ands6(state: OtAndsState5, msg: \u0026[u8], circuit: \u0026Circuit) -\u003e StateResult\u003cAndsBucketingState\u003e {\n    // 2nd part of Step 4e/5e of `_{LaAND}`\n    let (r_prime, r_and_rand): (Vec\u003cMacType\u003e, Vec\u003c(MacType, KeyType)\u003e) = deserialize(msg)?;\n    check_hash(\u0026state, \u0026r_prime, \u0026r_and_rand)?;\n\n    AndsBucketingState::init(state, circuit)\n}\n\nfn ot_ands8_contrib(\n    mut state: OtAndsState6,\n    msg1: \u0026[u8],\n    circuit: \u0026Circuit,\n    input: \u0026[bool],\n) -\u003e StateResult\u003cInputProcContrib\u003e {\n    let (x2, y2): (Vec\u003cbool\u003e, Vec\u003cbool\u003e) = deserialize(msg1)?;\n    if state.lhs_and_bits.len() != x2.len()\n        || state.rhs_and_bits.len() != y2.len()\n        || state.lhs_and_bits.len() != state.rhs_and_bits.len()\n    {\n        return Err(Error::InsufficientAndShares);\n    }\n\n    for i in 0..state.lhs_and_bits.len() {\n        state.lhs_and_bits[i] ^= x2[i];\n        state.rhs_and_bits[i] ^= y2[i];\n    }\n\n    let masks = \u0026state.masks;\n    let mut ands = 0_usize;\n    let mut garbled_table_shares = Vec::new();\n\n    for (index, gate) in circuit.gates().iter().enumerate() {\n        if let Gate::And(input_lhs, input_rhs) = gate {\n            let input_mask = \u0026state.sigma_mac(ands, Role::Contributor);\n            ands += 1;\n\n            let values = compute_hashes_contrib(\n                \u0026state,\n                index,\n                \u0026masks[index],\n                \u0026masks[*input_lhs as usize],\n                \u0026masks[*input_rhs as usize],\n                input_mask,\n            );\n            garbled_table_shares.push((index as u32, values));\n        }\n    }\n\n    let pending_from_a = circuit.contrib_inputs();\n    let pending_from_b = circuit.eval_inputs();\n\n    if pending_from_a \u003e input.len() {\n        return Err(InsufficientInput);\n    }\n    if pending_from_a + pending_from_b == 0 {\n        return Err(InvalidCircuit);\n    }\n\n    // generate message for each input bit and continue\n    let mut input_mask_shares = Vec::with_capacity(pending_from_b);\n    for (index, gate) in circuit.gates().iter().enumerate() {\n        if gate == \u0026Gate::InEval {\n            input_mask_shares.push((\n                index as GateIndex,\n                PartialBitShare {\n                    bit: masks[index].bit.bit,\n                    mac: masks[index].bit.mac,\n                },\n            ))\n        }\n    }\n    let msg = serialize(\u0026(garbled_table_shares, input_mask_shares))?;\n\n    let state = InputProcContrib {\n        delta: state.delta,\n        pending_from_b,\n        mac_checks_success: true,\n        masks: state.masks,\n    };\n    Ok((state, msg))\n}\n\nimpl OtAndsState6 {\n    fn sigma_mac(\u0026self, ands: usize, role: Role) -\u003e BitShare {\n        let mut res = self.and_triples[3 * ands + 2];\n        if self.lhs_and_bits[ands] {\n            res = res.xor(\u0026self.and_triples[3 * ands + 1]);\n        }\n        if self.rhs_and_bits[ands] {\n            res = res.xor(\u0026self.and_triples[3 * ands]);\n        }\n\n        if self.lhs_and_bits[ands] \u0026\u0026 self.rhs_and_bits[ands] {\n            if let Role::Contributor = role {\n                res.key.0 ^= self.delta.0; // TODO: is this correct?\n            } else {\n                res.bit = !res.bit;\n            }\n        }\n\n        res\n    }\n}\n\nfn ot_ands8_eval(\n    mut state: OtAndsState6,\n    msg1: \u0026[u8],\n    msg2: \u0026[u8],\n    circuit: \u0026Circuit,\n    input: \u0026[bool],\n) -\u003e StateResult\u003cInputProcEval\u003e {\n    let (upstream_lhs_bits, upstream_rhs_bits): (Vec\u003cbool\u003e, Vec\u003cbool\u003e) = deserialize(msg1)?;\n\n    for i in 0..state.lhs_and_bits.len() {\n        state.lhs_and_bits[i] ^= upstream_lhs_bits[i];\n        state.rhs_and_bits[i] ^= upstream_rhs_bits[i];\n    }\n\n    let mut ands = 0_usize;\n    let mut wires = vec![WireState::default(); circuit.gates().len()];\n    for (index, gate) in circuit.gates().iter().enumerate() {\n        if let Gate::And(input_lhs, input_rhs) = gate {\n            let input_mask = \u0026state.sigma_mac(ands, Role::Evaluator);\n            ands += 1;\n\n            wires[index].my_and_table = compute_hashes(\n                \u0026state.masks[index],\n                \u0026state.masks[*input_lhs as usize],\n                \u0026state.masks[*input_rhs as usize],\n                input_mask,\n            );\n        }\n    }\n\n    // input processing:\n    let (garbled_table_shares, input_mask_shares): (Vec\u003cTableShare\u003e, Vec\u003cInputMaskShare\u003e) =\n        deserialize(msg2)?;\n    if ands != garbled_table_shares.len() {\n        return Err(UnexpectedGarbledTableShare);\n    }\n    for (gate, and_share) in garbled_table_shares {\n        if !circuit.gates()[gate as usize].is_and() {\n            return Err(UnexpectedGarbledTableShare);\n        }\n        wires[gate as usize].other_and_table = and_share;\n    }\n\n    if circuit.eval_inputs() \u003e input.len() {\n        return Err(InsufficientInput);\n    }\n\n    // generate message for each input bit and continue\n    let mut mask_shares = Vec::new();\n    for (index, gate) in circuit.gates().iter().enumerate() {\n        if gate == \u0026Gate::InContrib {\n            mask_shares.push((\n                index as GateIndex,\n                PartialBitShare {\n                    mac: state.masks[index].bit.mac,\n                    bit: state.masks[index].bit.bit,\n                },\n            ))\n        }\n    }\n\n    let mut masked_inputs = Vec::with_capacity(input_mask_shares.len());\n    for ((index, bit_share), input) in input_mask_shares.iter().zip(input.iter()) {\n        if circuit.gates()[*index as usize] != Gate::InEval {\n            return Err(UnexpectedMessageType);\n        }\n\n        let mask = \u0026state.masks[*index as usize];\n        assert!(bit_share.verify(\u0026mask.bit.key, \u0026state.delta));\n\n        let masked_input = mask.bit.bit ^ bit_share.bit ^ input;\n        masked_inputs.push((*index, masked_input));\n    }\n\n    let (garbled_table_shares, input_mask_shares): (Vec\u003cTableShare\u003e, Vec\u003cInputMaskShare\u003e) =\n        deserialize(msg2)?;\n    if ands != garbled_table_shares.len() {\n        return Err(UnexpectedGarbledTableShare);\n    }\n    for (gate, and_share) in garbled_table_shares {\n        if !circuit.gates()[gate as usize].is_and() {\n            return Err(UnexpectedGarbledTableShare);\n        }\n        wires[gate as usize].other_and_table = and_share;\n    }\n\n    let input_gates = circuit\n        .gates()\n        .iter()\n        .filter(|g| *g == \u0026Gate::InEval)\n        .count();\n    if input_gates \u003e input.len() {\n        return Err(InsufficientInput);\n    }\n\n    // generate message for each input bit and continue\n    let mut mask_shares = Vec::new();\n    for (index, gate) in circuit.gates().iter().enumerate() {\n        if gate == \u0026Gate::InContrib {\n            mask_shares.push((\n                index as GateIndex,\n                PartialBitShare {\n                    mac: state.masks[index].bit.mac,\n                    bit: state.masks[index].bit.bit,\n                },\n            ))\n        }\n    }\n\n    let mut masked_inputs = Vec::with_capacity(input_mask_shares.len());\n    for ((index, bit_share), input) in input_mask_shares.iter().zip(input.iter()) {\n        if circuit.gates()[*index as usize] != Gate::InEval {\n            return Err(UnexpectedMessageType);\n        }\n\n        let mask = \u0026state.masks[*index as usize];\n        assert!(bit_share.verify(\u0026mask.bit.key, \u0026state.delta));\n\n        let masked_input = mask.bit.bit ^ bit_share.bit ^ input;\n        masked_inputs.push((*index, masked_input));\n    }\n    let reply = serialize(\u0026(mask_shares, masked_inputs))?;\n    let state = InputProcEval {\n        delta: state.delta,\n        pending_input: circuit.eval_inputs() + circuit.contrib_inputs(),\n        masks: state.masks,\n        wires,\n    };\n\n    Ok((state, reply))\n}\n\n#[allow(clippy::identity_op)]\nfn collect_authenticated_bits(bits: \u0026[BitShare]) -\u003e (MacType, MacType, MacType) {\n    use crate::types::SecurityBits;\n\n    assert!(!bits.len() \u003e= BLOCK_SIZE * 3);\n\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\n    for i in 0..BLOCK_SIZE {\n        x |= SecurityBits::from(bits[i * 3 + 0].bit) \u003c\u003c i;\n        y |= SecurityBits::from(bits[i * 3 + 1].bit) \u003c\u003c i;\n        z |= SecurityBits::from(bits[i * 3 + 2].bit) \u003c\u003c i;\n    }\n\n    (MacType(x), MacType(y), MacType(z))\n}\n\nfn collect_y_bits(bits: \u0026[BitShare]) -\u003e MacType {\n    use crate::types::SecurityBits;\n\n    assert!(!bits.len() \u003e= BLOCK_SIZE * 3);\n\n    let mut result = 0;\n\n    for i in 0..BLOCK_SIZE {\n        result |= SecurityBits::from(bits[i * 3 + 1].bit) \u003c\u003c i;\n    }\n\n    MacType(result)\n}\n\n#[inline]\nfn keys(bits: \u0026[BitShare]) -\u003e [KeyType; BLOCK_SIZE] {\n    assert!(bits.len() \u003e= BLOCK_SIZE * 3);\n\n    let mut r = [KeyType(0); BLOCK_SIZE];\n    for i in 0..BLOCK_SIZE {\n        r[i] = bits[3 * i].key;\n    }\n\n    r\n}\n\n#[inline]\nfn macs(bits: \u0026[BitShare]) -\u003e [MacType; BLOCK_SIZE] {\n    assert!(bits.len() \u003e= BLOCK_SIZE * 3);\n\n    let mut r = [MacType(0); BLOCK_SIZE];\n    for i in 0..BLOCK_SIZE {\n        r[i] = bits[3 * i].mac;\n    }\n\n    r\n}\n\nfn compute_hashes(\n    output_mask: \u0026WireMask,\n    lhs: \u0026WireMask,\n    rhs: \u0026WireMask,\n    input_mask: \u0026BitShare,\n) -\u003e [BitShare; 4] {\n    let h0 = output_mask.bit.xor(input_mask);\n    let h1 = h0.xor(\u0026lhs.bit);\n    let h2 = h0.xor(\u0026rhs.bit);\n    let mut h3 = h1.xor(\u0026rhs.bit);\n    h3.bit ^= true;\n    [h0, h1, h2, h3]\n}\n\nimpl InputProcContrib {\n    fn run(mut self, msg: \u0026[u8], circuit: \u0026Circuit, input: \u0026[bool]) -\u003e MpcResult\u003c()\u003e {\n        // P_B sends its mask to P_A which then returns masked input plus label to P_B for final\n        // circuit evaluation\n        let (shares, inputs): (Vec\u003cInputMaskShare\u003e, Vec\u003c(u32, bool)\u003e) = deserialize(msg)?;\n        let mut evaluation_inputs = Vec::with_capacity(shares.len());\n        for ((index, bit_share), input) in shares.iter().zip(input.iter()) {\n            if circuit.gates()[*index as usize] != Gate::InContrib {\n                return Err(UnexpectedMessageType);\n            }\n            let mask = \u0026self.masks[*index as usize];\n\n            self.mac_checks_success \u0026= bit_share.verify(\u0026mask.bit.key, \u0026self.delta);\n            let my_input_masked = input ^ bit_share.bit ^ mask.bit.bit;\n            let label = mask.label(my_input_masked, \u0026self.delta);\n            evaluation_inputs.push((*index, label, my_input_masked));\n        }\n\n        // P_B sends masked bit to P_A so P_A can return its label\n        for (index, bit) in inputs {\n            if circuit.gates()[index as usize] != Gate::InEval {\n                return Err(UnexpectedMessageType);\n            }\n            if self.pending_from_b == 0 {\n                return Err(UnexpectedMessageType);\n            }\n\n            let mask = \u0026self.masks[index as usize];\n            let label = mask.label(bit, \u0026self.delta);\n            evaluation_inputs.push((index, label, bit));\n        }\n\n        if self.mac_checks_success {\n            // disclose masks of output gates to other party\n            let mut mask_shares = Vec::new();\n            for index in circuit.output_gates() {\n                mask_shares.push((\n                    *index,\n                    PartialBitShare {\n                        mac: self.masks[*index as usize].bit.mac,\n                        bit: self.masks[*index as usize].bit.bit,\n                    },\n                ));\n            }\n            let reply = serialize(\u0026(evaluation_inputs, mask_shares))?;\n            Ok(((), reply))\n        } else {\n            Err(MacError)\n        }\n    }\n}\n\nimpl InputProcEval {\n    fn run(mut self, msg: \u0026[u8], circuit: \u0026Circuit) -\u003e MpcResult\u003cVec\u003cbool\u003e\u003e {\n        let (inputs, shares): (Vec\u003c(u32, WireLabel, bool)\u003e, Vec\u003cInputMaskShare\u003e) =\n            deserialize(msg)?;\n        for (index, label, masked_value) in inputs {\n            if circuit.gates()[index as usize] != Gate::InEval\n                \u0026\u0026 circuit.gates()[index as usize] != Gate::InContrib\n            {\n                return Err(UnexpectedMessageType);\n            }\n            if self.pending_input == 0 {\n                return Err(UnexpectedMessageType);\n            }\n\n            self.wires[index as usize].label = label.clone();\n            self.wires[index as usize].masked_value = masked_value;\n\n            self.pending_input -= 1;\n        }\n\n        assert_eq!(self.pending_input, 0);\n        let mut wires = self.wires;\n        let mut mac_checks_success = true;\n        for (index, gate) in circuit.gates().iter().enumerate() {\n            if let Gate::Xor(input_lhs, input_rhs) = gate {\n                wires[index].masked_value = wires[*input_lhs as usize].masked_value\n                    ^ wires[*input_rhs as usize].masked_value;\n                wires[index].label = wires[*input_lhs as usize]\n                    .label\n                    .xor(\u0026wires[*input_rhs as usize].label);\n            } else if let Gate::Not(input) = gate {\n                wires[index].masked_value = !wires[*input as usize].masked_value;\n                wires[index].label = wires[*input as usize].label.clone();\n            } else if let Gate::And(input_lhs, input_rhs) = gate {\n                let lhs = \u0026wires[*input_lhs as usize];\n                let rhs = \u0026wires[*input_rhs as usize];\n\n                let row: u8 = 2 * u8::from(lhs.masked_value) + u8::from(rhs.masked_value);\n                let result = wires[index].other_and_table[row as usize].xor(\u0026garbling_hash::new(\n                    \u0026lhs.label,\n                    \u0026rhs.label,\n                    index as u32,\n                    row,\n                ));\n\n                mac_checks_success \u0026= PartialBitShare::from(\u0026result)\n                    .verify(\u0026wires[index].my_and_table[row as usize].key, \u0026self.delta);\n\n                wires[index].masked_value =\n                    wires[index].my_and_table[row as usize].bit ^ result.bit;\n                wires[index].label =\n                    WireLabel(result.key.0 ^ wires[index].my_and_table[row as usize].mac.0);\n            }\n        }\n        if !mac_checks_success {\n            return Err(MacError);\n        }\n\n        let mut output = Vec::with_capacity(circuit.output_gates().len());\n        if circuit.output_gates().len() != shares.len() {\n            return Err(UnexpectedMessageType);\n        }\n        for (index, bit_share) in shares {\n            mac_checks_success \u0026=\n                bit_share.verify(\u0026self.masks[index as usize].bit.key, \u0026self.delta);\n\n            let result = wires[index as usize].masked_value\n                ^ bit_share.bit\n                ^ self.masks[index as usize].bit.bit;\n\n            output.push(result);\n        }\n        if mac_checks_success {\n            let empty_reply = vec![];\n            Ok((output, empty_reply))\n        } else {\n            Err(MacError)\n        }\n    }\n}\n","traces":[{"line":56,"address":[512531,511728,512489],"length":1,"stats":{"Line":4}},{"line":57,"address":[511822,511765],"length":1,"stats":{"Line":13}},{"line":59,"address":[803673],"length":1,"stats":{"Line":5}},{"line":63,"address":[871002],"length":1,"stats":{"Line":3}},{"line":70,"address":[804128],"length":1,"stats":{"Line":5}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[871280,878096,872887],"length":1,"stats":{"Line":7}},{"line":78,"address":[804282,805494],"length":1,"stats":{"Line":5}},{"line":79,"address":[513289,512859,513169],"length":1,"stats":{"Line":6}},{"line":80,"address":[872929,871994,872070],"length":1,"stats":{"Line":6}},{"line":81,"address":[872337,872502],"length":1,"stats":{"Line":7}},{"line":83,"address":[804481,805998,805825],"length":1,"stats":{"Line":5}},{"line":84,"address":[873147,873085,873822],"length":1,"stats":{"Line":2}},{"line":85,"address":[806386,806533],"length":1,"stats":{"Line":4}},{"line":87,"address":[806721,804519,806845],"length":1,"stats":{"Line":4}},{"line":88,"address":[806858,806826,807443],"length":1,"stats":{"Line":7}},{"line":89,"address":[874261,874426],"length":1,"stats":{"Line":8}},{"line":91,"address":[807456,804557,807580],"length":1,"stats":{"Line":4}},{"line":92,"address":[515908,515944,516497],"length":1,"stats":{"Line":6}},{"line":93,"address":[808025,807860],"length":1,"stats":{"Line":6}},{"line":95,"address":[875327,871731,875500],"length":1,"stats":{"Line":7}},{"line":96,"address":[517389,516634,516692],"length":1,"stats":{"Line":5}},{"line":97,"address":[517240,517043],"length":1,"stats":{"Line":4}},{"line":99,"address":[809129,809281,804633],"length":1,"stats":{"Line":9}},{"line":100,"address":[517581,517526,518401],"length":1,"stats":{"Line":4}},{"line":101,"address":[876894,877121],"length":1,"stats":{"Line":5}},{"line":103,"address":[804671,810374,810173],"length":1,"stats":{"Line":9}},{"line":104,"address":[810282,810387,810931],"length":1,"stats":{"Line":7}},{"line":105,"address":[518964,519041],"length":1,"stats":{"Line":9}},{"line":107,"address":[871845],"length":1,"stats":{"Line":0}},{"line":111,"address":[872694],"length":1,"stats":{"Line":5}},{"line":112,"address":[805562],"length":1,"stats":{"Line":6}},{"line":114,"address":[513998],"length":1,"stats":{"Line":2}},{"line":120,"address":[878681,878144],"length":1,"stats":{"Line":6}},{"line":121,"address":[811096,811053],"length":1,"stats":{"Line":12}},{"line":122,"address":[811418],"length":1,"stats":{"Line":2}},{"line":123,"address":[519532],"length":1,"stats":{"Line":7}},{"line":124,"address":[878511],"length":1,"stats":{"Line":3}},{"line":125,"address":[519614],"length":1,"stats":{"Line":9}},{"line":133,"address":[519776],"length":1,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[521483,527610,519792],"length":1,"stats":{"Line":3}},{"line":141,"address":[880117,878858],"length":1,"stats":{"Line":6}},{"line":142,"address":[879351,879455,878995],"length":1,"stats":{"Line":6}},{"line":143,"address":[520620,521521,520508],"length":1,"stats":{"Line":9}},{"line":144,"address":[812861,812698],"length":1,"stats":{"Line":7}},{"line":146,"address":[813378,813506,811898],"length":1,"stats":{"Line":9}},{"line":147,"address":[814102,813487,813519],"length":1,"stats":{"Line":5}},{"line":148,"address":[880922,881085],"length":1,"stats":{"Line":4}},{"line":150,"address":[814288,811937,814115],"length":1,"stats":{"Line":4}},{"line":151,"address":[523123,522452,522398],"length":1,"stats":{"Line":2}},{"line":152,"address":[522974,522815],"length":1,"stats":{"Line":4}},{"line":154,"address":[879112,882163,882291],"length":1,"stats":{"Line":8}},{"line":155,"address":[815136,815168,815751],"length":1,"stats":{"Line":6}},{"line":156,"address":[882734,882571],"length":1,"stats":{"Line":5}},{"line":158,"address":[523871,523995,520223],"length":1,"stats":{"Line":8}},{"line":159,"address":[523988,524024,524548],"length":1,"stats":{"Line":9}},{"line":160,"address":[524249,524399],"length":1,"stats":{"Line":5}},{"line":162,"address":[883610,883762,879190],"length":1,"stats":{"Line":7}},{"line":163,"address":[524722,524671,525581],"length":1,"stats":{"Line":4}},{"line":164,"address":[884501,884172],"length":1,"stats":{"Line":7}},{"line":166,"address":[520301,525612,525890],"length":1,"stats":{"Line":5}},{"line":167,"address":[817699,817848,818762],"length":1,"stats":{"Line":2}},{"line":168,"address":[818609,818344],"length":1,"stats":{"Line":9}},{"line":170,"address":[812132,819023,818797],"length":1,"stats":{"Line":0}},{"line":171,"address":[886711,886172,886055],"length":1,"stats":{"Line":0}},{"line":172,"address":[886502],"length":1,"stats":{"Line":0}},{"line":174,"address":[879307],"length":1,"stats":{"Line":0}},{"line":178,"address":[813053],"length":1,"stats":{"Line":5}},{"line":179,"address":[813087],"length":1,"stats":{"Line":6}},{"line":181,"address":[880313],"length":1,"stats":{"Line":6}},{"line":185,"address":[820673,820873,819728],"length":1,"stats":{"Line":6}},{"line":186,"address":[886912],"length":1,"stats":{"Line":3}},{"line":187,"address":[887029,887228,886954],"length":1,"stats":{"Line":9}},{"line":188,"address":[888022,887418,887241,887133],"length":1,"stats":{"Line":8}},{"line":189,"address":[820558],"length":1,"stats":{"Line":3}},{"line":191,"address":[819852],"length":1,"stats":{"Line":0}},{"line":406,"address":[1059104],"length":1,"stats":{"Line":2}},{"line":407,"address":[630149],"length":1,"stats":{"Line":10}},{"line":408,"address":[1059270],"length":1,"stats":{"Line":7}},{"line":409,"address":[630243],"length":1,"stats":{"Line":3}},{"line":414,"address":[1059360],"length":1,"stats":{"Line":7}},{"line":419,"address":[1059445],"length":1,"stats":{"Line":4}},{"line":420,"address":[1059529],"length":1,"stats":{"Line":4}},{"line":421,"address":[630755],"length":1,"stats":{"Line":3}},{"line":426,"address":[630896,632273,632495],"length":1,"stats":{"Line":4}},{"line":427,"address":[630980],"length":1,"stats":{"Line":4}},{"line":428,"address":[632400,631423,631313],"length":1,"stats":{"Line":5}},{"line":429,"address":[632299,631611],"length":1,"stats":{"Line":3}},{"line":430,"address":[632039],"length":1,"stats":{"Line":3}},{"line":435,"address":[634879,632528,634528],"length":1,"stats":{"Line":2}},{"line":436,"address":[1061826,1064019,1061710],"length":1,"stats":{"Line":6}},{"line":437,"address":[1062280,1063961,1062055,1063997],"length":1,"stats":{"Line":7}},{"line":438,"address":[633393,634758,633599,634655],"length":1,"stats":{"Line":6}},{"line":439,"address":[633783,634554],"length":1,"stats":{"Line":4}},{"line":440,"address":[1063392],"length":1,"stats":{"Line":3}},{"line":445,"address":[995778,993392,995341],"length":1,"stats":{"Line":8}},{"line":446,"address":[993602,995757,993486],"length":1,"stats":{"Line":13}},{"line":447,"address":[1066297,1064527,1066404,1064749],"length":1,"stats":{"Line":4}},{"line":448,"address":[994414,995480,994282],"length":1,"stats":{"Line":8}},{"line":449,"address":[995359,994629],"length":1,"stats":{"Line":2}},{"line":450,"address":[995123],"length":1,"stats":{"Line":2}},{"line":455,"address":[1068521,1068886,1066512],"length":1,"stats":{"Line":2}},{"line":456,"address":[1066735,1066619,1068865],"length":1,"stats":{"Line":5}},{"line":457,"address":[637875,639502,637712],"length":1,"stats":{"Line":4}},{"line":458,"address":[639455,638099,638310,639352],"length":1,"stats":{"Line":7}},{"line":459,"address":[997082,997851],"length":1,"stats":{"Line":2}},{"line":460,"address":[997575],"length":1,"stats":{"Line":2}},{"line":465,"address":[1001178,1000719,998240],"length":1,"stats":{"Line":2}},{"line":466,"address":[639716,639860,642413],"length":1,"stats":{"Line":7}},{"line":467,"address":[1069405,1071823,1069650,1071784],"length":1,"stats":{"Line":4}},{"line":470,"address":[640530,640618,642055],"length":1,"stats":{"Line":5}},{"line":471,"address":[1070150,1070233],"length":1,"stats":{"Line":4}},{"line":473,"address":[641082],"length":1,"stats":{"Line":3}},{"line":474,"address":[641099],"length":1,"stats":{"Line":3}},{"line":475,"address":[641125],"length":1,"stats":{"Line":3}},{"line":476,"address":[1070533],"length":1,"stats":{"Line":3}},{"line":477,"address":[999885],"length":1,"stats":{"Line":3}},{"line":478,"address":[641237],"length":1,"stats":{"Line":3}},{"line":479,"address":[641277],"length":1,"stats":{"Line":3}},{"line":480,"address":[1000005],"length":1,"stats":{"Line":3}},{"line":483,"address":[1071031],"length":1,"stats":{"Line":3}},{"line":489,"address":[1071904,1073788,1074093],"length":1,"stats":{"Line":2}},{"line":490,"address":[1072092,1071968,1074072],"length":1,"stats":{"Line":7}},{"line":491,"address":[642815],"length":1,"stats":{"Line":4}},{"line":492,"address":[1072345,1073794,1072428],"length":1,"stats":{"Line":8}},{"line":493,"address":[1001951,1002022],"length":1,"stats":{"Line":8}},{"line":495,"address":[1002202],"length":1,"stats":{"Line":4}},{"line":496,"address":[643422],"length":1,"stats":{"Line":4}},{"line":497,"address":[643448],"length":1,"stats":{"Line":4}},{"line":498,"address":[1072964],"length":1,"stats":{"Line":4}},{"line":499,"address":[1073004],"length":1,"stats":{"Line":4}},{"line":500,"address":[643560],"length":1,"stats":{"Line":4}},{"line":501,"address":[643600],"length":1,"stats":{"Line":4}},{"line":502,"address":[643640],"length":1,"stats":{"Line":4}},{"line":503,"address":[643680],"length":1,"stats":{"Line":4}},{"line":505,"address":[1002814],"length":1,"stats":{"Line":4}},{"line":511,"address":[1074947,1074128],"length":1,"stats":{"Line":4}},{"line":512,"address":[1003498],"length":1,"stats":{"Line":3}},{"line":513,"address":[1003843,1003772],"length":1,"stats":{"Line":4}},{"line":514,"address":[1003981],"length":1,"stats":{"Line":2}},{"line":519,"address":[1077416,1074992,1077040],"length":1,"stats":{"Line":2}},{"line":520,"address":[1006707,1004398,1004514],"length":1,"stats":{"Line":5}},{"line":521,"address":[1077373,1075431,1075656,1077337],"length":1,"stats":{"Line":6}},{"line":522,"address":[1077274,1077179,1076087,1075877],"length":1,"stats":{"Line":6}},{"line":523,"address":[646679,647450],"length":1,"stats":{"Line":4}},{"line":524,"address":[647152],"length":1,"stats":{"Line":4}},{"line":529,"address":[649808,647808,650159],"length":1,"stats":{"Line":7}},{"line":530,"address":[1077666,1077550,1079859],"length":1,"stats":{"Line":13}},{"line":531,"address":[1079801,1079837,1078120,1077895],"length":1,"stats":{"Line":8}},{"line":532,"address":[1008955,1007653,1007863,1009050],"length":1,"stats":{"Line":6}},{"line":533,"address":[649834,649063],"length":1,"stats":{"Line":2}},{"line":534,"address":[649536],"length":1,"stats":{"Line":2}},{"line":539,"address":[1081956,1082332,1079920],"length":1,"stats":{"Line":2}},{"line":540,"address":[650427,650299,652511],"length":1,"stats":{"Line":7}},{"line":541,"address":[652457,650632,652501,650853],"length":1,"stats":{"Line":7}},{"line":542,"address":[1010345,1011502,1010130,1011407],"length":1,"stats":{"Line":7}},{"line":543,"address":[1010533,1011286],"length":1,"stats":{"Line":2}},{"line":544,"address":[651938],"length":1,"stats":{"Line":2}},{"line":549,"address":[655193,652560,654848],"length":1,"stats":{"Line":6}},{"line":550,"address":[652780,652652,655176],"length":1,"stats":{"Line":9}},{"line":551,"address":[1083023,1085034,1085001,1082796],"length":1,"stats":{"Line":9}},{"line":552,"address":[1014250,1012551,1012766,1014155],"length":1,"stats":{"Line":9}},{"line":554,"address":[653880,654874],"length":1,"stats":{"Line":4}},{"line":555,"address":[654313],"length":1,"stats":{"Line":3}},{"line":560,"address":[655232,657915,657570],"length":1,"stats":{"Line":4}},{"line":561,"address":[1085215,1085331,1087842],"length":1,"stats":{"Line":8}},{"line":562,"address":[655890,655667,657847,657888],"length":1,"stats":{"Line":8}},{"line":563,"address":[1017036,1015693,1015360,1016941],"length":1,"stats":{"Line":6}},{"line":565,"address":[656761,657596],"length":1,"stats":{"Line":3}},{"line":566,"address":[657194],"length":1,"stats":{"Line":2}},{"line":571,"address":[1089403,1087904,1089382],"length":1,"stats":{"Line":3}},{"line":572,"address":[1017417,1017333,1018700],"length":1,"stats":{"Line":5}},{"line":573,"address":[658740,659396,658364],"length":1,"stats":{"Line":9}},{"line":574,"address":[1018329],"length":1,"stats":{"Line":2}},{"line":581,"address":[659456],"length":1,"stats":{"Line":3}},{"line":582,"address":[1018761],"length":1,"stats":{"Line":4}},{"line":583,"address":[659475,659519],"length":1,"stats":{"Line":4}},{"line":584,"address":[1018793,1018836],"length":1,"stats":{"Line":6}},{"line":585,"address":[659529],"length":1,"stats":{"Line":3}},{"line":594,"address":[661554,659568,661634],"length":1,"stats":{"Line":7}},{"line":595,"address":[1018951],"length":1,"stats":{"Line":5}},{"line":598,"address":[659899,659760],"length":1,"stats":{"Line":4}},{"line":601,"address":[659874,659920,659992],"length":1,"stats":{"Line":9}},{"line":602,"address":[1090115,1089965,1090001],"length":1,"stats":{"Line":6}},{"line":603,"address":[1090100,1090159,1090133],"length":1,"stats":{"Line":8}},{"line":604,"address":[1090177,1090387,1090141],"length":1,"stats":{"Line":9}},{"line":605,"address":[1019594],"length":1,"stats":{"Line":3}},{"line":606,"address":[660670],"length":1,"stats":{"Line":4}},{"line":607,"address":[1019660],"length":1,"stats":{"Line":8}},{"line":608,"address":[1019692],"length":1,"stats":{"Line":5}},{"line":609,"address":[660449,661609],"length":1,"stats":{"Line":3}},{"line":612,"address":[1020065,1020902,1020124],"length":1,"stats":{"Line":8}},{"line":618,"address":[1091208],"length":1,"stats":{"Line":3}},{"line":620,"address":[1091364],"length":1,"stats":{"Line":4}},{"line":623,"address":[1021024,1023090,1023317],"length":1,"stats":{"Line":6}},{"line":624,"address":[1091886,1091794,1094003],"length":1,"stats":{"Line":9}},{"line":625,"address":[1023204,1021491,1021443],"length":1,"stats":{"Line":8}},{"line":626,"address":[1021617,1021728],"length":1,"stats":{"Line":6}},{"line":627,"address":[1023164,1021743,1021809],"length":1,"stats":{"Line":7}},{"line":628,"address":[1093784,1092679,1092743],"length":1,"stats":{"Line":7}},{"line":630,"address":[1022474],"length":1,"stats":{"Line":4}},{"line":631,"address":[663117],"length":1,"stats":{"Line":3}},{"line":632,"address":[1093243],"length":1,"stats":{"Line":5}},{"line":633,"address":[663161],"length":1,"stats":{"Line":2}},{"line":634,"address":[1022619],"length":1,"stats":{"Line":4}},{"line":636,"address":[663270],"length":1,"stats":{"Line":2}},{"line":638,"address":[1022889],"length":1,"stats":{"Line":4}},{"line":641,"address":[1025258,1023360,1024994],"length":1,"stats":{"Line":5}},{"line":642,"address":[1025117,1023431,1023546],"length":1,"stats":{"Line":7}},{"line":643,"address":[1023780,1023968,1025051],"length":1,"stats":{"Line":7}},{"line":645,"address":[1025022,1024110],"length":1,"stats":{"Line":3}},{"line":646,"address":[1094928,1095002],"length":1,"stats":{"Line":7}},{"line":647,"address":[664894],"length":1,"stats":{"Line":6}},{"line":649,"address":[1095165],"length":1,"stats":{"Line":7}},{"line":650,"address":[1095187],"length":1,"stats":{"Line":2}},{"line":651,"address":[1024523],"length":1,"stats":{"Line":7}},{"line":654,"address":[1095289],"length":1,"stats":{"Line":2}},{"line":656,"address":[1024790],"length":1,"stats":{"Line":4}},{"line":659,"address":[665840,668820,668935],"length":1,"stats":{"Line":4}},{"line":660,"address":[665905,666017,668844],"length":1,"stats":{"Line":9}},{"line":661,"address":[666119,666210],"length":1,"stats":{"Line":4}},{"line":663,"address":[1096454],"length":1,"stats":{"Line":6}},{"line":664,"address":[1025797],"length":1,"stats":{"Line":3}},{"line":665,"address":[1096612,1096556],"length":1,"stats":{"Line":5}},{"line":666,"address":[1026022,1026120],"length":1,"stats":{"Line":7}},{"line":667,"address":[1026290],"length":1,"stats":{"Line":3}},{"line":668,"address":[1027324,1026331],"length":1,"stats":{"Line":8}},{"line":669,"address":[1098020,1098117],"length":1,"stats":{"Line":8}},{"line":670,"address":[667908],"length":1,"stats":{"Line":4}},{"line":672,"address":[1098383],"length":1,"stats":{"Line":5}},{"line":673,"address":[668195,668784],"length":1,"stats":{"Line":5}},{"line":674,"address":[1028253,1027969,1028124],"length":1,"stats":{"Line":11}},{"line":675,"address":[1098921,1099131,1098983],"length":1,"stats":{"Line":8}},{"line":677,"address":[1098674],"length":1,"stats":{"Line":5}},{"line":679,"address":[1097051],"length":1,"stats":{"Line":2}},{"line":682,"address":[666955],"length":1,"stats":{"Line":6}},{"line":683,"address":[1026621],"length":1,"stats":{"Line":2}},{"line":684,"address":[667067],"length":1,"stats":{"Line":2}},{"line":685,"address":[667082],"length":1,"stats":{"Line":2}},{"line":689,"address":[667415],"length":1,"stats":{"Line":3}},{"line":692,"address":[1028688,1032468,1033588],"length":1,"stats":{"Line":3}},{"line":693,"address":[1028834,1028952,1033509],"length":1,"stats":{"Line":8}},{"line":694,"address":[1099821,1099929,1100080],"length":1,"stats":{"Line":12}},{"line":695,"address":[672752,672828,669801],"length":1,"stats":{"Line":8}},{"line":697,"address":[821168,821169],"length":1,"stats":{"Line":0}},{"line":698,"address":[1032796],"length":1,"stats":{"Line":3}},{"line":699,"address":[1103551],"length":1,"stats":{"Line":4}},{"line":700,"address":[1032873,1032976],"length":1,"stats":{"Line":8}},{"line":702,"address":[673133],"length":1,"stats":{"Line":4}},{"line":703,"address":[1104117,1103821],"length":1,"stats":{"Line":6}},{"line":704,"address":[1033279,1033321,1033444],"length":1,"stats":{"Line":7}},{"line":709,"address":[669834],"length":1,"stats":{"Line":4}},{"line":710,"address":[1029585,1029779],"length":1,"stats":{"Line":2}},{"line":711,"address":[670034,670081],"length":1,"stats":{"Line":7}},{"line":712,"address":[1100596],"length":1,"stats":{"Line":3}},{"line":719,"address":[1100807,1100950],"length":1,"stats":{"Line":2}},{"line":720,"address":[670505,670583],"length":1,"stats":{"Line":5}},{"line":722,"address":[1030402,1030547],"length":1,"stats":{"Line":3}},{"line":723,"address":[1030545,1030576],"length":1,"stats":{"Line":7}},{"line":724,"address":[1030630],"length":1,"stats":{"Line":5}},{"line":726,"address":[1101394],"length":1,"stats":{"Line":5}},{"line":727,"address":[1101582,1101455],"length":1,"stats":{"Line":10}},{"line":730,"address":[1030962],"length":1,"stats":{"Line":3}},{"line":731,"address":[1101660],"length":1,"stats":{"Line":3}},{"line":732,"address":[671262],"length":1,"stats":{"Line":3}},{"line":734,"address":[671340,671427],"length":1,"stats":{"Line":7}},{"line":735,"address":[1031186],"length":1,"stats":{"Line":4}},{"line":737,"address":[671534],"length":1,"stats":{"Line":4}},{"line":738,"address":[671589],"length":1,"stats":{"Line":5}},{"line":739,"address":[1031409],"length":1,"stats":{"Line":5}},{"line":743,"address":[1031819],"length":1,"stats":{"Line":4}},{"line":744,"address":[672099,672159],"length":1,"stats":{"Line":5}},{"line":746,"address":[672276],"length":1,"stats":{"Line":2}},{"line":750,"address":[673776,675068,675074],"length":1,"stats":{"Line":3}},{"line":751,"address":[673826],"length":1,"stats":{"Line":3}},{"line":752,"address":[1033784],"length":1,"stats":{"Line":4}},{"line":754,"address":[1104502],"length":1,"stats":{"Line":3}},{"line":756,"address":[1104604,1104523],"length":1,"stats":{"Line":4}},{"line":757,"address":[1033893,1033937],"length":1,"stats":{"Line":7}},{"line":759,"address":[674192],"length":1,"stats":{"Line":3}},{"line":760,"address":[1034267,1034440,1034375],"length":1,"stats":{"Line":8}},{"line":761,"address":[1105166],"length":1,"stats":{"Line":2}},{"line":763,"address":[1034511],"length":1,"stats":{"Line":2}},{"line":764,"address":[674798],"length":1,"stats":{"Line":2}},{"line":766,"address":[1034756],"length":1,"stats":{"Line":2}},{"line":767,"address":[1105562],"length":1,"stats":{"Line":2}},{"line":770,"address":[674982],"length":1,"stats":{"Line":2}},{"line":774,"address":[674399],"length":1,"stats":{"Line":3}},{"line":777,"address":[676532,676538,675088],"length":1,"stats":{"Line":2}},{"line":782,"address":[1105797],"length":1,"stats":{"Line":2}},{"line":783,"address":[675250],"length":1,"stats":{"Line":2}},{"line":785,"address":[1035201],"length":1,"stats":{"Line":2}},{"line":786,"address":[675412],"length":1,"stats":{"Line":0}},{"line":789,"address":[1035266],"length":1,"stats":{"Line":2}},{"line":790,"address":[675373,675504],"length":1,"stats":{"Line":4}},{"line":791,"address":[675625,675767],"length":1,"stats":{"Line":8}},{"line":792,"address":[1106565],"length":1,"stats":{"Line":2}},{"line":794,"address":[676093],"length":1,"stats":{"Line":4}},{"line":796,"address":[1036108],"length":1,"stats":{"Line":2}},{"line":797,"address":[1106811],"length":1,"stats":{"Line":3}},{"line":800,"address":[1107003,1107042],"length":1,"stats":{"Line":5}},{"line":801,"address":[1107084],"length":1,"stats":{"Line":3}},{"line":803,"address":[1107026],"length":1,"stats":{"Line":3}},{"line":805,"address":[1107118],"length":1,"stats":{"Line":3}},{"line":808,"address":[1106277],"length":1,"stats":{"Line":3}},{"line":813,"address":[678724,678718,676560],"length":1,"stats":{"Line":3}},{"line":814,"address":[1107268],"length":1,"stats":{"Line":2}},{"line":815,"address":[1036621,1036693],"length":1,"stats":{"Line":5}},{"line":816,"address":[1107585,1107781],"length":1,"stats":{"Line":3}},{"line":817,"address":[677026],"length":1,"stats":{"Line":3}},{"line":818,"address":[677075],"length":1,"stats":{"Line":3}},{"line":821,"address":[1037292,1037129,1037058],"length":1,"stats":{"Line":6}},{"line":822,"address":[677225],"length":1,"stats":{"Line":3}},{"line":823,"address":[1107918],"length":1,"stats":{"Line":3}},{"line":826,"address":[1037257,1037329,1037473],"length":1,"stats":{"Line":6}},{"line":827,"address":[1037373],"length":1,"stats":{"Line":3}},{"line":828,"address":[1037422],"length":1,"stats":{"Line":3}},{"line":831,"address":[677538,677495],"length":1,"stats":{"Line":5}},{"line":832,"address":[1108725],"length":1,"stats":{"Line":2}},{"line":833,"address":[1037982],"length":1,"stats":{"Line":4}},{"line":834,"address":[677761],"length":1,"stats":{"Line":4}},{"line":835,"address":[1108475],"length":1,"stats":{"Line":2}},{"line":837,"address":[1038116],"length":1,"stats":{"Line":3}},{"line":838,"address":[678370],"length":1,"stats":{"Line":2}},{"line":839,"address":[1038614],"length":1,"stats":{"Line":4}},{"line":840,"address":[678675],"length":1,"stats":{"Line":3}},{"line":842,"address":[1107611],"length":1,"stats":{"Line":3}},{"line":845,"address":[1040746,1038752,1041669],"length":1,"stats":{"Line":2}},{"line":846,"address":[1109525,1112179,1109665],"length":1,"stats":{"Line":5}},{"line":848,"address":[1039158,1039263],"length":1,"stats":{"Line":5}},{"line":849,"address":[679267],"length":1,"stats":{"Line":3}},{"line":851,"address":[679327],"length":1,"stats":{"Line":2}},{"line":852,"address":[1039434],"length":1,"stats":{"Line":0}},{"line":855,"address":[1039395,1039489],"length":1,"stats":{"Line":5}},{"line":856,"address":[1110298,1111448],"length":1,"stats":{"Line":8}},{"line":857,"address":[1111617],"length":1,"stats":{"Line":4}},{"line":859,"address":[1111686],"length":1,"stats":{"Line":4}},{"line":860,"address":[681367,681079],"length":1,"stats":{"Line":4}},{"line":861,"address":[681382,681193],"length":1,"stats":{"Line":4}},{"line":867,"address":[1039648],"length":1,"stats":{"Line":3}},{"line":868,"address":[679789,679726],"length":1,"stats":{"Line":5}},{"line":870,"address":[1040002],"length":1,"stats":{"Line":2}},{"line":871,"address":[1040036],"length":1,"stats":{"Line":3}},{"line":872,"address":[680022],"length":1,"stats":{"Line":2}},{"line":873,"address":[1110784],"length":1,"stats":{"Line":3}},{"line":874,"address":[680090],"length":1,"stats":{"Line":2}},{"line":875,"address":[1040172],"length":1,"stats":{"Line":3}},{"line":876,"address":[680166],"length":1,"stats":{"Line":2}},{"line":877,"address":[1110936],"length":1,"stats":{"Line":3}},{"line":879,"address":[680521],"length":1,"stats":{"Line":2}},{"line":882,"address":[684091,685334,681616],"length":1,"stats":{"Line":2}},{"line":886,"address":[1112485,1116062,1112633],"length":1,"stats":{"Line":5}},{"line":888,"address":[1112814,1112919],"length":1,"stats":{"Line":5}},{"line":889,"address":[682139],"length":1,"stats":{"Line":3}},{"line":891,"address":[682185],"length":1,"stats":{"Line":2}},{"line":892,"address":[1042456],"length":1,"stats":{"Line":0}},{"line":895,"address":[1042422],"length":1,"stats":{"Line":4}},{"line":896,"address":[1042594,1042503],"length":1,"stats":{"Line":8}},{"line":897,"address":[1113403,1115016],"length":1,"stats":{"Line":5}},{"line":898,"address":[1044513],"length":1,"stats":{"Line":2}},{"line":899,"address":[684486],"length":1,"stats":{"Line":3}},{"line":900,"address":[684670],"length":1,"stats":{"Line":3}},{"line":902,"address":[1044895],"length":1,"stats":{"Line":3}},{"line":905,"address":[1044921,1045317],"length":1,"stats":{"Line":6}},{"line":906,"address":[684874,685137],"length":1,"stats":{"Line":3}},{"line":909,"address":[682637,684119],"length":1,"stats":{"Line":2}},{"line":912,"address":[1113649,1113773],"length":1,"stats":{"Line":5}},{"line":913,"address":[1043092,1043160],"length":1,"stats":{"Line":5}},{"line":916,"address":[1043353],"length":1,"stats":{"Line":2}},{"line":917,"address":[1114075],"length":1,"stats":{"Line":3}},{"line":918,"address":[1043417],"length":1,"stats":{"Line":2}},{"line":919,"address":[1114135],"length":1,"stats":{"Line":3}},{"line":920,"address":[1114173],"length":1,"stats":{"Line":2}},{"line":921,"address":[1114211],"length":1,"stats":{"Line":3}},{"line":922,"address":[1114249],"length":1,"stats":{"Line":2}},{"line":923,"address":[683443],"length":1,"stats":{"Line":3}},{"line":925,"address":[1114583],"length":1,"stats":{"Line":2}},{"line":928,"address":[1051103,1045600,1048119],"length":1,"stats":{"Line":3}},{"line":929,"address":[1121634,1116373,1116537],"length":1,"stats":{"Line":5}},{"line":932,"address":[685794,685891],"length":1,"stats":{"Line":5}},{"line":933,"address":[1116857],"length":1,"stats":{"Line":5}},{"line":934,"address":[1046230,1046306],"length":1,"stats":{"Line":9}},{"line":935,"address":[686157,686080],"length":1,"stats":{"Line":9}},{"line":936,"address":[1117109,1117175],"length":1,"stats":{"Line":9}},{"line":937,"address":[1119079,1117379],"length":1,"stats":{"Line":2}},{"line":938,"address":[687929],"length":1,"stats":{"Line":2}},{"line":939,"address":[1048287],"length":1,"stats":{"Line":2}},{"line":940,"address":[688020],"length":1,"stats":{"Line":4}},{"line":942,"address":[1119249,1119115,1119044],"length":1,"stats":{"Line":5}},{"line":943,"address":[1048598,1048731,1048526],"length":1,"stats":{"Line":5}},{"line":945,"address":[1048700,1048786],"length":1,"stats":{"Line":5}},{"line":946,"address":[1119587],"length":1,"stats":{"Line":3}},{"line":947,"address":[688692],"length":1,"stats":{"Line":2}},{"line":948,"address":[1119880],"length":1,"stats":{"Line":3}},{"line":949,"address":[1120067,1120612,1121254],"length":1,"stats":{"Line":8}},{"line":950,"address":[689109,689721],"length":1,"stats":{"Line":5}},{"line":951,"address":[1120959],"length":1,"stats":{"Line":2}},{"line":952,"address":[690157],"length":1,"stats":{"Line":3}},{"line":954,"address":[1049496,1049399],"length":1,"stats":{"Line":4}},{"line":955,"address":[1120326],"length":1,"stats":{"Line":2}},{"line":956,"address":[1120572],"length":1,"stats":{"Line":2}},{"line":959,"address":[689671,690222],"length":1,"stats":{"Line":5}},{"line":960,"address":[1050686],"length":1,"stats":{"Line":2}},{"line":961,"address":[690378],"length":1,"stats":{"Line":3}},{"line":962,"address":[690410],"length":1,"stats":{"Line":3}},{"line":963,"address":[690464],"length":1,"stats":{"Line":3}},{"line":965,"address":[1046705,1048125],"length":1,"stats":{"Line":3}},{"line":967,"address":[1047164],"length":1,"stats":{"Line":2}},{"line":970,"address":[1047400],"length":1,"stats":{"Line":3}},{"line":971,"address":[1118122],"length":1,"stats":{"Line":4}},{"line":972,"address":[687172],"length":1,"stats":{"Line":4}},{"line":973,"address":[1047494],"length":1,"stats":{"Line":4}},{"line":974,"address":[1047532],"length":1,"stats":{"Line":4}},{"line":975,"address":[1118258],"length":1,"stats":{"Line":4}},{"line":976,"address":[1047608],"length":1,"stats":{"Line":4}},{"line":977,"address":[687354],"length":1,"stats":{"Line":4}},{"line":979,"address":[1047942],"length":1,"stats":{"Line":4}},{"line":982,"address":[690736,693297,694994],"length":1,"stats":{"Line":3}},{"line":983,"address":[690821,694853,690989],"length":1,"stats":{"Line":8}},{"line":987,"address":[1051630,1051735],"length":1,"stats":{"Line":6}},{"line":988,"address":[1122457],"length":1,"stats":{"Line":6}},{"line":989,"address":[691397,691461],"length":1,"stats":{"Line":7}},{"line":990,"address":[691641,693533],"length":1,"stats":{"Line":4}},{"line":991,"address":[693380],"length":1,"stats":{"Line":2}},{"line":992,"address":[1053934],"length":1,"stats":{"Line":3}},{"line":993,"address":[1124664],"length":1,"stats":{"Line":3}},{"line":995,"address":[1054003,1054074,1054237],"length":1,"stats":{"Line":6}},{"line":996,"address":[1124814],"length":1,"stats":{"Line":3}},{"line":997,"address":[1124863],"length":1,"stats":{"Line":3}},{"line":1000,"address":[1054274,1054418,1054202],"length":1,"stats":{"Line":6}},{"line":1001,"address":[1054318],"length":1,"stats":{"Line":3}},{"line":1002,"address":[1125055],"length":1,"stats":{"Line":3}},{"line":1006,"address":[693891,693934],"length":1,"stats":{"Line":5}},{"line":1009,"address":[694172],"length":1,"stats":{"Line":3}},{"line":1011,"address":[1054921],"length":1,"stats":{"Line":2}},{"line":1012,"address":[1125673],"length":1,"stats":{"Line":4}},{"line":1013,"address":[1055124],"length":1,"stats":{"Line":2}},{"line":1014,"address":[1125886],"length":1,"stats":{"Line":3}},{"line":1018,"address":[1122803],"length":1,"stats":{"Line":2}},{"line":1019,"address":[691851],"length":1,"stats":{"Line":3}},{"line":1021,"address":[692037,693311],"length":1,"stats":{"Line":2}},{"line":1024,"address":[692549],"length":1,"stats":{"Line":3}},{"line":1025,"address":[1053075],"length":1,"stats":{"Line":2}},{"line":1026,"address":[1053105],"length":1,"stats":{"Line":3}},{"line":1027,"address":[1053135],"length":1,"stats":{"Line":2}},{"line":1028,"address":[1053173],"length":1,"stats":{"Line":3}},{"line":1029,"address":[1053211],"length":1,"stats":{"Line":2}},{"line":1030,"address":[1123937],"length":1,"stats":{"Line":3}},{"line":1031,"address":[1053287],"length":1,"stats":{"Line":2}},{"line":1033,"address":[693091],"length":1,"stats":{"Line":3}},{"line":1036,"address":[1126288],"length":1,"stats":{"Line":3}},{"line":1041,"address":[695112],"length":1,"stats":{"Line":3}},{"line":1042,"address":[695147],"length":1,"stats":{"Line":0}},{"line":1045,"address":[1126424],"length":1,"stats":{"Line":4}},{"line":1048,"address":[1126802,1126429],"length":1,"stats":{"Line":5}},{"line":1049,"address":[695381],"length":1,"stats":{"Line":4}},{"line":1051,"address":[695427],"length":1,"stats":{"Line":2}},{"line":1053,"address":[1126739],"length":1,"stats":{"Line":3}},{"line":1054,"address":[1126788],"length":1,"stats":{"Line":2}},{"line":1056,"address":[1127071,1126817],"length":1,"stats":{"Line":6}},{"line":1058,"address":[1056325],"length":1,"stats":{"Line":2}},{"line":1060,"address":[1127059],"length":1,"stats":{"Line":4}},{"line":1063,"address":[1056414,1056388],"length":1,"stats":{"Line":2}},{"line":1064,"address":[695823],"length":1,"stats":{"Line":0}},{"line":1066,"address":[695844],"length":1,"stats":{"Line":3}},{"line":1070,"address":[1056448],"length":1,"stats":{"Line":3}},{"line":1078,"address":[1127237],"length":1,"stats":{"Line":2}},{"line":1079,"address":[1056579],"length":1,"stats":{"Line":3}},{"line":1080,"address":[696034],"length":1,"stats":{"Line":2}},{"line":1081,"address":[696074],"length":1,"stats":{"Line":3}},{"line":1082,"address":[696089],"length":1,"stats":{"Line":2}},{"line":1084,"address":[696134],"length":1,"stats":{"Line":4}},{"line":1085,"address":[696167],"length":1,"stats":{"Line":3}},{"line":1086,"address":[1127513],"length":1,"stats":{"Line":2}},{"line":1087,"address":[1056907],"length":1,"stats":{"Line":4}},{"line":1088,"address":[696413],"length":1,"stats":{"Line":4}},{"line":1090,"address":[1127754],"length":1,"stats":{"Line":2}},{"line":1091,"address":[1127762],"length":1,"stats":{"Line":3}},{"line":1092,"address":[696534],"length":1,"stats":{"Line":5}},{"line":1093,"address":[1127806],"length":1,"stats":{"Line":4}},{"line":1095,"address":[1057154],"length":1,"stats":{"Line":2}},{"line":1097,"address":[1127855],"length":1,"stats":{"Line":4}},{"line":1098,"address":[696645],"length":1,"stats":{"Line":3}},{"line":1099,"address":[1127974],"length":1,"stats":{"Line":2}},{"line":1100,"address":[696770],"length":1,"stats":{"Line":3}},{"line":1104,"address":[1128224],"length":1,"stats":{"Line":2}},{"line":1105,"address":[1128265],"length":1,"stats":{"Line":4}},{"line":1109,"address":[1128352,1130324],"length":1,"stats":{"Line":3}},{"line":1115,"address":[1057751,1057810],"length":1,"stats":{"Line":7}},{"line":1118,"address":[1128594],"length":1,"stats":{"Line":2}},{"line":1119,"address":[1057989,1057918],"length":1,"stats":{"Line":6}},{"line":1120,"address":[1058307],"length":1,"stats":{"Line":4}},{"line":1123,"address":[1059247],"length":1,"stats":{"Line":2}},{"line":1124,"address":[698766,698711],"length":1,"stats":{"Line":5}},{"line":1125,"address":[1059427,1059484],"length":1,"stats":{"Line":8}},{"line":1126,"address":[1059542],"length":1,"stats":{"Line":4}},{"line":1132,"address":[1129048],"length":1,"stats":{"Line":3}},{"line":1133,"address":[1129401],"length":1,"stats":{"Line":4}},{"line":1134,"address":[1058835],"length":1,"stats":{"Line":4}},{"line":1136,"address":[698228,698337],"length":1,"stats":{"Line":5}},{"line":1137,"address":[1129686],"length":1,"stats":{"Line":4}},{"line":1138,"address":[1129750],"length":1,"stats":{"Line":2}},{"line":1140,"address":[698271],"length":1,"stats":{"Line":2}},{"line":1141,"address":[1059149,1058935],"length":1,"stats":{"Line":4}},{"line":1142,"address":[1129853],"length":1,"stats":{"Line":2}},{"line":1148,"address":[1129458],"length":1,"stats":{"Line":2}},{"line":1156,"address":[700156,700162,698976],"length":1,"stats":{"Line":2}},{"line":1161,"address":[699081],"length":1,"stats":{"Line":2}},{"line":1162,"address":[1059805],"length":1,"stats":{"Line":2}},{"line":1164,"address":[699149],"length":1,"stats":{"Line":2}},{"line":1165,"address":[1059935,1059873],"length":1,"stats":{"Line":7}},{"line":1166,"address":[1131562,1130759,1130977],"length":1,"stats":{"Line":7}},{"line":1167,"address":[1060324],"length":1,"stats":{"Line":4}},{"line":1168,"address":[699829],"length":1,"stats":{"Line":2}},{"line":1169,"address":[700135,700097],"length":1,"stats":{"Line":4}},{"line":1173,"address":[699373],"length":1,"stats":{"Line":3}},{"line":1185,"address":[1060928,1063126],"length":1,"stats":{"Line":2}},{"line":1186,"address":[1135056,1136498,1136578],"length":1,"stats":{"Line":3}},{"line":1187,"address":[1135103],"length":1,"stats":{"Line":5}},{"line":1188,"address":[1064481,1064885,1064565],"length":1,"stats":{"Line":12}},{"line":1189,"address":[704027],"length":1,"stats":{"Line":4}},{"line":1192,"address":[704042],"length":1,"stats":{"Line":3}},{"line":1193,"address":[1065018,1064942,1065863],"length":1,"stats":{"Line":7}},{"line":1194,"address":[1135820,1136509],"length":1,"stats":{"Line":6}},{"line":1196,"address":[1135842],"length":1,"stats":{"Line":2}},{"line":1198,"address":[704334,704401],"length":1,"stats":{"Line":5}},{"line":1199,"address":[1065525,1065651,1065392],"length":1,"stats":{"Line":6}},{"line":1200,"address":[1136332,1136361,1136416],"length":1,"stats":{"Line":8}},{"line":1202,"address":[1065695,1065776],"length":1,"stats":{"Line":5}},{"line":1205,"address":[1065434],"length":1,"stats":{"Line":3}},{"line":1208,"address":[1131674,1131757],"length":1,"stats":{"Line":5}},{"line":1209,"address":[700321],"length":1,"stats":{"Line":3}},{"line":1211,"address":[1061120],"length":1,"stats":{"Line":2}},{"line":1213,"address":[1131955],"length":1,"stats":{"Line":2}},{"line":1214,"address":[1061337,1061420],"length":1,"stats":{"Line":5}},{"line":1217,"address":[1061523],"length":1,"stats":{"Line":3}},{"line":1218,"address":[700857],"length":1,"stats":{"Line":5}},{"line":1221,"address":[1132397,1132488],"length":1,"stats":{"Line":5}},{"line":1222,"address":[702412,701153],"length":1,"stats":{"Line":5}},{"line":1224,"address":[1134011,1135027],"length":1,"stats":{"Line":4}},{"line":1225,"address":[702690],"length":1,"stats":{"Line":3}},{"line":1227,"address":[1063688],"length":1,"stats":{"Line":3}},{"line":1228,"address":[1064009],"length":1,"stats":{"Line":2}},{"line":1229,"address":[1064172],"length":1,"stats":{"Line":4}},{"line":1233,"address":[1061954,1063145],"length":1,"stats":{"Line":2}},{"line":1236,"address":[701605],"length":1,"stats":{"Line":2}},{"line":1237,"address":[1133123],"length":1,"stats":{"Line":2}},{"line":1239,"address":[1062497],"length":1,"stats":{"Line":2}},{"line":1241,"address":[1133247],"length":1,"stats":{"Line":3}},{"line":1246,"address":[1062815],"length":1,"stats":{"Line":2}},{"line":1249,"address":[705024,706379],"length":1,"stats":{"Line":2}},{"line":1250,"address":[1065982],"length":1,"stats":{"Line":7}},{"line":1252,"address":[1066192],"length":1,"stats":{"Line":3}},{"line":1253,"address":[1136920],"length":1,"stats":{"Line":6}},{"line":1254,"address":[705397,705471],"length":1,"stats":{"Line":5}},{"line":1256,"address":[1066538,1066633],"length":1,"stats":{"Line":8}},{"line":1259,"address":[705830],"length":1,"stats":{"Line":5}},{"line":1260,"address":[705846],"length":1,"stats":{"Line":4}},{"line":1266,"address":[1137752],"length":1,"stats":{"Line":5}},{"line":1270,"address":[1140712,1138368,1142110],"length":1,"stats":{"Line":6}},{"line":1271,"address":[1138581,1138442],"length":1,"stats":{"Line":8}},{"line":1273,"address":[707021,710225],"length":1,"stats":{"Line":3}},{"line":1274,"address":[1138937,1139016],"length":1,"stats":{"Line":7}},{"line":1275,"address":[707433,707363],"length":1,"stats":{"Line":9}},{"line":1277,"address":[1068410],"length":1,"stats":{"Line":0}},{"line":1280,"address":[707484],"length":1,"stats":{"Line":6}},{"line":1284,"address":[1068538],"length":1,"stats":{"Line":3}},{"line":1285,"address":[1139238],"length":1,"stats":{"Line":6}},{"line":1286,"address":[1140756,1139421],"length":1,"stats":{"Line":6}},{"line":1288,"address":[1070149,1071242],"length":1,"stats":{"Line":4}},{"line":1289,"address":[709285],"length":1,"stats":{"Line":4}},{"line":1290,"address":[709465],"length":1,"stats":{"Line":2}},{"line":1292,"address":[1141534],"length":1,"stats":{"Line":4}},{"line":1293,"address":[1070996],"length":1,"stats":{"Line":2}},{"line":1296,"address":[1071168,1071247],"length":1,"stats":{"Line":3}},{"line":1299,"address":[1139458],"length":1,"stats":{"Line":2}},{"line":1300,"address":[707977],"length":1,"stats":{"Line":0}},{"line":1305,"address":[1139624],"length":1,"stats":{"Line":3}},{"line":1306,"address":[708963,707954,708064],"length":1,"stats":{"Line":8}},{"line":1307,"address":[708232,708900],"length":1,"stats":{"Line":5}},{"line":1310,"address":[1069613],"length":1,"stats":{"Line":5}},{"line":1311,"address":[708317],"length":1,"stats":{"Line":2}},{"line":1312,"address":[1069391],"length":1,"stats":{"Line":3}},{"line":1313,"address":[708381],"length":1,"stats":{"Line":2}},{"line":1314,"address":[1140141],"length":1,"stats":{"Line":3}},{"line":1315,"address":[1140179],"length":1,"stats":{"Line":4}},{"line":1316,"address":[708489],"length":1,"stats":{"Line":4}},{"line":1317,"address":[1069567],"length":1,"stats":{"Line":4}},{"line":1318,"address":[1069582],"length":1,"stats":{"Line":3}},{"line":1323,"address":[1142984,1142992,1142160],"length":1,"stats":{"Line":3}},{"line":1325,"address":[1072302,1071625,1071549],"length":1,"stats":{"Line":6}},{"line":1326,"address":[710814,710729],"length":1,"stats":{"Line":7}},{"line":1328,"address":[1072104],"length":1,"stats":{"Line":2}},{"line":1331,"address":[1146335,1143024],"length":1,"stats":{"Line":5}},{"line":1337,"address":[1072469,1072568,1076653],"length":1,"stats":{"Line":9}},{"line":1338,"address":[1143552,1143485],"length":1,"stats":{"Line":9}},{"line":1339,"address":[1072920,1072987],"length":1,"stats":{"Line":9}},{"line":1340,"address":[711855],"length":1,"stats":{"Line":4}},{"line":1342,"address":[1143639],"length":1,"stats":{"Line":0}},{"line":1345,"address":[1143818,1147298],"length":1,"stats":{"Line":9}},{"line":1346,"address":[715079,712129],"length":1,"stats":{"Line":6}},{"line":1347,"address":[1147195],"length":1,"stats":{"Line":2}},{"line":1350,"address":[1144062],"length":1,"stats":{"Line":3}},{"line":1351,"address":[1144082],"length":1,"stats":{"Line":2}},{"line":1352,"address":[1073406],"length":1,"stats":{"Line":2}},{"line":1354,"address":[1144121,1144197],"length":1,"stats":{"Line":7}},{"line":1355,"address":[1073835,1075991],"length":1,"stats":{"Line":6}},{"line":1356,"address":[1146716],"length":1,"stats":{"Line":2}},{"line":1357,"address":[1076157,1076083],"length":1,"stats":{"Line":3}},{"line":1362,"address":[1146822],"length":1,"stats":{"Line":2}},{"line":1363,"address":[1146879],"length":1,"stats":{"Line":3}},{"line":1364,"address":[714874],"length":1,"stats":{"Line":2}},{"line":1367,"address":[714965],"length":1,"stats":{"Line":2}},{"line":1371,"address":[1144548],"length":1,"stats":{"Line":2}},{"line":1372,"address":[712667],"length":1,"stats":{"Line":2}},{"line":1374,"address":[1144642],"length":1,"stats":{"Line":2}},{"line":1375,"address":[1074001],"length":1,"stats":{"Line":0}},{"line":1377,"address":[1074042,1073975],"length":1,"stats":{"Line":4}},{"line":1378,"address":[1144766],"length":1,"stats":{"Line":0}},{"line":1382,"address":[712879,712928],"length":1,"stats":{"Line":4}},{"line":1383,"address":[1074248,1074180],"length":1,"stats":{"Line":4}},{"line":1384,"address":[714380,713298],"length":1,"stats":{"Line":5}},{"line":1385,"address":[714498],"length":1,"stats":{"Line":3}},{"line":1386,"address":[1146418],"length":1,"stats":{"Line":2}},{"line":1388,"address":[1075736],"length":1,"stats":{"Line":3}},{"line":1389,"address":[1146475],"length":1,"stats":{"Line":2}},{"line":1394,"address":[713330,714353],"length":1,"stats":{"Line":2}},{"line":1397,"address":[1075077],"length":1,"stats":{"Line":3}},{"line":1400,"address":[1075084],"length":1,"stats":{"Line":2}},{"line":1402,"address":[1145868],"length":1,"stats":{"Line":3}},{"line":1406,"address":[1147440],"length":1,"stats":{"Line":4}},{"line":1407,"address":[1076812,1076948],"length":1,"stats":{"Line":2}},{"line":1408,"address":[715515,715728],"length":1,"stats":{"Line":6}},{"line":1409,"address":[1147833,1147700],"length":1,"stats":{"Line":2}},{"line":1411,"address":[1147988,1147659],"length":1,"stats":{"Line":7}},{"line":1412,"address":[715793,715891],"length":1,"stats":{"Line":4}},{"line":1415,"address":[1147856,1148049],"length":1,"stats":{"Line":4}},{"line":1416,"address":[716043,716003,715972],"length":1,"stats":{"Line":6}},{"line":1417,"address":[1077425],"length":1,"stats":{"Line":2}},{"line":1419,"address":[1077400],"length":1,"stats":{"Line":2}},{"line":1423,"address":[715909],"length":1,"stats":{"Line":2}},{"line":1427,"address":[1148160,1154891],"length":1,"stats":{"Line":3}},{"line":1434,"address":[1077668,1077791,1087026],"length":1,"stats":{"Line":5}},{"line":1436,"address":[1148783,1148708,1157709],"length":1,"stats":{"Line":7}},{"line":1437,"address":[716815,724885],"length":1,"stats":{"Line":5}},{"line":1438,"address":[1157606],"length":1,"stats":{"Line":3}},{"line":1441,"address":[716848],"length":1,"stats":{"Line":2}},{"line":1442,"address":[1078320],"length":1,"stats":{"Line":3}},{"line":1443,"address":[1149127,1149195],"length":1,"stats":{"Line":5}},{"line":1444,"address":[717345,724471,724838],"length":1,"stats":{"Line":8}},{"line":1445,"address":[1086462],"length":1,"stats":{"Line":2}},{"line":1446,"address":[1086517,1086595],"length":1,"stats":{"Line":2}},{"line":1448,"address":[1086735],"length":1,"stats":{"Line":3}},{"line":1449,"address":[1157256],"length":1,"stats":{"Line":3}},{"line":1450,"address":[1086629],"length":1,"stats":{"Line":2}},{"line":1451,"address":[1157361],"length":1,"stats":{"Line":3}},{"line":1458,"address":[1079042],"length":1,"stats":{"Line":3}},{"line":1460,"address":[1149905,1149802],"length":1,"stats":{"Line":5}},{"line":1461,"address":[1079297],"length":1,"stats":{"Line":0}},{"line":1463,"address":[1079468,1079333,1079222,1086257],"length":1,"stats":{"Line":11}},{"line":1464,"address":[1086071,1079554],"length":1,"stats":{"Line":5}},{"line":1465,"address":[1086132],"length":1,"stats":{"Line":0}},{"line":1467,"address":[1086192],"length":1,"stats":{"Line":2}},{"line":1470,"address":[1079603],"length":1,"stats":{"Line":3}},{"line":1471,"address":[1079670],"length":1,"stats":{"Line":0}},{"line":1475,"address":[1079643],"length":1,"stats":{"Line":2}},{"line":1476,"address":[1150402,1150473],"length":1,"stats":{"Line":5}},{"line":1477,"address":[1150791,1156505],"length":1,"stats":{"Line":5}},{"line":1478,"address":[1085987],"length":1,"stats":{"Line":2}},{"line":1479,"address":[723933],"length":1,"stats":{"Line":3}},{"line":1481,"address":[723942],"length":1,"stats":{"Line":2}},{"line":1482,"address":[1156614],"length":1,"stats":{"Line":3}},{"line":1488,"address":[1150827],"length":1,"stats":{"Line":3}},{"line":1489,"address":[1080200,1080295],"length":1,"stats":{"Line":4}},{"line":1490,"address":[1080683,1085378],"length":1,"stats":{"Line":5}},{"line":1491,"address":[723615],"length":1,"stats":{"Line":0}},{"line":1494,"address":[1085470,1085572],"length":1,"stats":{"Line":5}},{"line":1495,"address":[723683],"length":1,"stats":{"Line":3}},{"line":1497,"address":[1156356],"length":1,"stats":{"Line":2}},{"line":1498,"address":[1156418],"length":1,"stats":{"Line":3}},{"line":1501,"address":[1156048,1151409],"length":1,"stats":{"Line":2}},{"line":1503,"address":[1080969,1081072],"length":1,"stats":{"Line":7}},{"line":1504,"address":[1081152],"length":1,"stats":{"Line":0}},{"line":1506,"address":[723399,719683,719449,719556],"length":1,"stats":{"Line":17}},{"line":1507,"address":[1155756,1152097],"length":1,"stats":{"Line":6}},{"line":1508,"address":[723276],"length":1,"stats":{"Line":0}},{"line":1510,"address":[1155889],"length":1,"stats":{"Line":3}},{"line":1513,"address":[719810],"length":1,"stats":{"Line":4}},{"line":1516,"address":[821225,821200],"length":1,"stats":{"Line":8}},{"line":1518,"address":[1152345],"length":1,"stats":{"Line":4}},{"line":1519,"address":[1152377],"length":1,"stats":{"Line":0}},{"line":1523,"address":[1081662],"length":1,"stats":{"Line":4}},{"line":1524,"address":[1081809,1081733],"length":1,"stats":{"Line":8}},{"line":1525,"address":[722941,720431],"length":1,"stats":{"Line":7}},{"line":1526,"address":[1084962],"length":1,"stats":{"Line":3}},{"line":1527,"address":[1084811],"length":1,"stats":{"Line":3}},{"line":1529,"address":[1155508],"length":1,"stats":{"Line":3}},{"line":1530,"address":[723049],"length":1,"stats":{"Line":2}},{"line":1536,"address":[1152851],"length":1,"stats":{"Line":2}},{"line":1537,"address":[1152920,1153012],"length":1,"stats":{"Line":5}},{"line":1538,"address":[720980,722463],"length":1,"stats":{"Line":5}},{"line":1539,"address":[1084410],"length":1,"stats":{"Line":0}},{"line":1542,"address":[722645,722547],"length":1,"stats":{"Line":5}},{"line":1543,"address":[722653],"length":1,"stats":{"Line":7}},{"line":1545,"address":[1084566],"length":1,"stats":{"Line":2}},{"line":1546,"address":[1155316],"length":1,"stats":{"Line":7}},{"line":1548,"address":[1082734,1084222],"length":1,"stats":{"Line":2}},{"line":1550,"address":[1153889],"length":1,"stats":{"Line":7}},{"line":1551,"address":[722000,721468],"length":1,"stats":{"Line":2}},{"line":1552,"address":[1154034],"length":1,"stats":{"Line":7}},{"line":1556,"address":[1154194],"length":1,"stats":{"Line":2}},{"line":1560,"address":[1087120],"length":1,"stats":{"Line":3}},{"line":1563,"address":[1087169],"length":1,"stats":{"Line":3}},{"line":1565,"address":[1157956],"length":1,"stats":{"Line":2}},{"line":1566,"address":[1157980],"length":1,"stats":{"Line":3}},{"line":1567,"address":[1158004],"length":1,"stats":{"Line":3}},{"line":1569,"address":[726297,725340],"length":1,"stats":{"Line":6}},{"line":1570,"address":[1158483,1158244,1158124],"length":1,"stats":{"Line":7}},{"line":1571,"address":[725813,725775,726052],"length":1,"stats":{"Line":8}},{"line":1572,"address":[1088032,1088070,1088302],"length":1,"stats":{"Line":6}},{"line":1575,"address":[1158160],"length":1,"stats":{"Line":2}},{"line":1578,"address":[726320],"length":1,"stats":{"Line":2}},{"line":1581,"address":[1159041],"length":1,"stats":{"Line":2}},{"line":1583,"address":[1159128],"length":1,"stats":{"Line":2}},{"line":1585,"address":[1159479,1159146],"length":1,"stats":{"Line":4}},{"line":1586,"address":[726576,726533,726796],"length":1,"stats":{"Line":4}},{"line":1589,"address":[1088553],"length":1,"stats":{"Line":2}},{"line":1593,"address":[726816],"length":1,"stats":{"Line":3}},{"line":1594,"address":[1159547],"length":1,"stats":{"Line":2}},{"line":1596,"address":[726937],"length":1,"stats":{"Line":3}},{"line":1597,"address":[1089237,1088954],"length":1,"stats":{"Line":6}},{"line":1598,"address":[1159738,1159935,1159801],"length":1,"stats":{"Line":6}},{"line":1601,"address":[727075],"length":1,"stats":{"Line":2}},{"line":1605,"address":[1089280],"length":1,"stats":{"Line":4}},{"line":1606,"address":[727323],"length":1,"stats":{"Line":2}},{"line":1608,"address":[1160089],"length":1,"stats":{"Line":4}},{"line":1609,"address":[1089418,1089702],"length":1,"stats":{"Line":5}},{"line":1610,"address":[1089577,1089712,1089514],"length":1,"stats":{"Line":5}},{"line":1613,"address":[727539],"length":1,"stats":{"Line":2}},{"line":1616,"address":[1089744],"length":1,"stats":{"Line":3}},{"line":1622,"address":[1089816],"length":1,"stats":{"Line":3}},{"line":1623,"address":[727835],"length":1,"stats":{"Line":3}},{"line":1624,"address":[1160547],"length":1,"stats":{"Line":3}},{"line":1625,"address":[727886],"length":1,"stats":{"Line":3}},{"line":1626,"address":[1160596],"length":1,"stats":{"Line":3}},{"line":1627,"address":[1089926],"length":1,"stats":{"Line":2}},{"line":1631,"address":[730453,728080,731663],"length":1,"stats":{"Line":2}},{"line":1634,"address":[731661,728221,728316],"length":1,"stats":{"Line":9}},{"line":1635,"address":[1161301,1161225],"length":1,"stats":{"Line":10}},{"line":1636,"address":[728631,728708],"length":1,"stats":{"Line":5}},{"line":1637,"address":[1161815,1163923],"length":1,"stats":{"Line":7}},{"line":1638,"address":[1164042],"length":1,"stats":{"Line":0}},{"line":1640,"address":[1164003,1164099],"length":1,"stats":{"Line":7}},{"line":1642,"address":[1164107],"length":1,"stats":{"Line":5}},{"line":1643,"address":[731307],"length":1,"stats":{"Line":3}},{"line":1644,"address":[1164223],"length":1,"stats":{"Line":4}},{"line":1645,"address":[731428],"length":1,"stats":{"Line":4}},{"line":1649,"address":[1091149,1091371],"length":1,"stats":{"Line":7}},{"line":1650,"address":[729395,730690],"length":1,"stats":{"Line":7}},{"line":1651,"address":[1163603],"length":1,"stats":{"Line":0}},{"line":1653,"address":[1163586],"length":1,"stats":{"Line":6}},{"line":1654,"address":[1092956],"length":1,"stats":{"Line":0}},{"line":1657,"address":[730860,730925],"length":1,"stats":{"Line":7}},{"line":1658,"address":[1163773],"length":1,"stats":{"Line":3}},{"line":1659,"address":[730996],"length":1,"stats":{"Line":6}},{"line":1662,"address":[729481,729436,730373],"length":1,"stats":{"Line":8}},{"line":1664,"address":[1162246],"length":1,"stats":{"Line":6}},{"line":1665,"address":[1091604,1091680],"length":1,"stats":{"Line":9}},{"line":1666,"address":[1092720],"length":1,"stats":{"Line":3}},{"line":1667,"address":[1162530],"length":1,"stats":{"Line":3}},{"line":1669,"address":[730522,729764],"length":1,"stats":{"Line":9}},{"line":1670,"address":[730540],"length":1,"stats":{"Line":6}},{"line":1674,"address":[1091886,1092579],"length":1,"stats":{"Line":6}},{"line":1675,"address":[730234],"length":1,"stats":{"Line":3}},{"line":1677,"address":[1162213],"length":1,"stats":{"Line":0}},{"line":1683,"address":[1093888,1099528,1096689],"length":1,"stats":{"Line":3}},{"line":1684,"address":[732029],"length":1,"stats":{"Line":3}},{"line":1686,"address":[1094576,1094441,1099312,1094333],"length":1,"stats":{"Line":11}},{"line":1687,"address":[1165373,1169501],"length":1,"stats":{"Line":7}},{"line":1688,"address":[1098909],"length":1,"stats":{"Line":3}},{"line":1690,"address":[736564],"length":1,"stats":{"Line":0}},{"line":1692,"address":[1169573],"length":1,"stats":{"Line":3}},{"line":1693,"address":[1169738],"length":1,"stats":{"Line":0}},{"line":1696,"address":[1169833,1169779],"length":1,"stats":{"Line":7}},{"line":1697,"address":[1169901],"length":1,"stats":{"Line":4}},{"line":1699,"address":[1099317,1099273],"length":1,"stats":{"Line":3}},{"line":1702,"address":[1165422],"length":1,"stats":{"Line":5}},{"line":1703,"address":[1094870],"length":1,"stats":{"Line":4}},{"line":1704,"address":[1094902],"length":1,"stats":{"Line":3}},{"line":1705,"address":[732731,732666],"length":1,"stats":{"Line":9}},{"line":1706,"address":[1167426,1165997,1167905],"length":1,"stats":{"Line":9}},{"line":1707,"address":[1167552,1167472,1167632],"length":1,"stats":{"Line":9}},{"line":1708,"address":[734524],"length":1,"stats":{"Line":3}},{"line":1709,"address":[1167709,1167809],"length":1,"stats":{"Line":6}},{"line":1711,"address":[734702],"length":1,"stats":{"Line":2}},{"line":1712,"address":[1097230,1097556,1096831],"length":1,"stats":{"Line":8}},{"line":1713,"address":[1167941,1168021],"length":1,"stats":{"Line":4}},{"line":1714,"address":[1097414],"length":1,"stats":{"Line":2}},{"line":1715,"address":[1169481,1168257,1167988],"length":1,"stats":{"Line":9}},{"line":1716,"address":[1168295],"length":1,"stats":{"Line":3}},{"line":1717,"address":[1168358],"length":1,"stats":{"Line":2}},{"line":1719,"address":[735335,735513],"length":1,"stats":{"Line":3}},{"line":1720,"address":[735541,735483],"length":1,"stats":{"Line":5}},{"line":1727,"address":[1168802,1168940,1169003],"length":1,"stats":{"Line":15}},{"line":1728,"address":[735865,735744],"length":1,"stats":{"Line":5}},{"line":1730,"address":[1098546,1098448],"length":1,"stats":{"Line":6}},{"line":1731,"address":[1169178,1169021],"length":1,"stats":{"Line":5}},{"line":1732,"address":[736288,736361],"length":1,"stats":{"Line":5}},{"line":1733,"address":[1169433,1169245],"length":1,"stats":{"Line":3}},{"line":1736,"address":[1095326],"length":1,"stats":{"Line":3}},{"line":1737,"address":[1095344],"length":1,"stats":{"Line":0}},{"line":1740,"address":[1095385,1095434],"length":1,"stats":{"Line":5}},{"line":1741,"address":[1095574,1095503],"length":1,"stats":{"Line":5}},{"line":1742,"address":[1095716],"length":1,"stats":{"Line":0}},{"line":1744,"address":[1095904,1095769,1095641],"length":1,"stats":{"Line":7}},{"line":1745,"address":[1096484],"length":1,"stats":{"Line":3}},{"line":1746,"address":[1166694,1167132],"length":1,"stats":{"Line":5}},{"line":1748,"address":[1096503,1096577,1096638],"length":1,"stats":{"Line":6}},{"line":1749,"address":[1167258],"length":1,"stats":{"Line":3}},{"line":1750,"address":[1167274],"length":1,"stats":{"Line":3}},{"line":1752,"address":[1167340],"length":1,"stats":{"Line":3}},{"line":1754,"address":[1096109,1096060,1096327],"length":1,"stats":{"Line":5}},{"line":1755,"address":[1096111],"length":1,"stats":{"Line":3}},{"line":1756,"address":[1096157],"length":1,"stats":{"Line":2}},{"line":1758,"address":[1096078],"length":1,"stats":{"Line":0}}],"covered":790,"coverable":826},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","src","types.rs"],"content":"//! Common type definitions.\n\nuse std::ops::BitXor;\n\nuse rand_core::RngCore;\nuse serde::{Deserialize, Serialize};\n\n/// The number bits of computational security.\npub const K: usize = SecurityBits::BITS as usize;\n\npub type SecurityBits = u128;\n\n/// MAC data type underlying authenticated bits etc.\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Serialize, Deserialize)]\npub struct MacType(pub SecurityBits);\n\nimpl BitXor\u003cu128\u003e for MacType {\n    type Output = MacType;\n\n    fn bitxor(self, rhs: u128) -\u003e Self::Output {\n        MacType(self.0 ^ rhs)\n    }\n}\n\nimpl BitXor\u003cMacType\u003e for MacType {\n    type Output = MacType;\n\n    fn bitxor(self, rhs: MacType) -\u003e Self::Output {\n        MacType(self.0 ^ rhs.0)\n    }\n}\n\n/// Data type of Keys underlying authenticated bits etc.\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Serialize, Deserialize)]\npub struct KeyType(pub SecurityBits);\n\nimpl BitXor\u003cu128\u003e for KeyType {\n    type Output = Self;\n\n    fn bitxor(self, rhs: u128) -\u003e Self::Output {\n        Self(self.0 ^ rhs)\n    }\n}\n\nimpl BitXor\u003cKeyType\u003e for KeyType {\n    type Output = Self;\n\n    fn bitxor(self, rhs: KeyType) -\u003e Self::Output {\n        Self(self.0 ^ rhs.0)\n    }\n}\n\nimpl From\u003cMacType\u003e for KeyType {\n    fn from(m: MacType) -\u003e Self {\n        Self(m.0)\n    }\n}\n\n/// A wire mask generated during preprocessing. Foundation for garbled circuit computation.\n#[derive(Default, Debug, Clone, Serialize, Deserialize)]\npub(crate) struct WireMask {\n    /// The wire label if {bit.bit} is `false`.\n    pub(crate) label_0: WireLabel,\n    /// The current mask which is used to hide the wire's actual value.\n    pub(crate) bit: BitShare,\n}\n\n/// Evaluation state derived at function-dependant preprocessing stage.\n#[derive(Default, Debug, Clone, Serialize, Deserialize)]\npub(crate) struct WireState {\n    /// The label for this wire, computed during preprocessing.\n    pub(crate) label: WireLabel,\n    /// The value of the wire after masking it with {bit.bit}.\n    pub(crate) masked_value: bool,\n    /// The AND table derived at preprocessing time, representing the local share.\n    pub(crate) my_and_table: AndTableShare,\n    /// The AND table from a contributing party, representing their share.\n    pub(crate) other_and_table: AndTableShare,\n}\n\npub(crate) type TableShare = (u32, [BitShare; 4]);\npub(crate) type InputMaskShare = (u32, PartialBitShare);\n\n/// The share of a bit coming from preprocessing.\n///\n/// The mac relates to the bit {bit} while the {key} relates to the bit given to the other party.\n#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub struct BitShare {\n    /// MAC key used for other party's bit.\n    pub key: KeyType,\n    /// MAC for this bit.\n    pub mac: MacType,\n    /// The actual bit i.e. value of this authenticated bit.\n    pub bit: bool,\n}\n\n/// Random bitmask used to construct AND gate table shares.\n#[derive(Debug, Clone, PartialEq, Eq, Default, Serialize, Deserialize)]\npub struct WireLabel(pub SecurityBits);\n\n/// A partial bit share; used for disclosing one's authenticated bit.\n#[derive(Default, Debug, Copy, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct PartialBitShare {\n    /// The authenticated bit's MAC.\n    pub mac: MacType,\n    /// The authenticated bit's value.\n    pub bit: bool,\n}\n\n/// The processing node-global hiding key.\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub(crate) struct Delta(pub(crate) SecurityBits);\n\n/// Share of an AND table.\npub(crate) type AndTableShare = [BitShare; 4];\n\nimpl Delta {\n    pub(crate) fn gen_random(rng: \u0026mut impl RngCore) -\u003e Self {\n        let val = rng.next_u64() as u128 | ((rng.next_u64() as u128) \u003c\u003c 64);\n        Self(val)\n    }\n\n    #[inline]\n    pub(crate) fn xor(\u0026self, rhs: MacType) -\u003e MacType {\n        MacType(self.0 ^ rhs.0)\n    }\n}\n\nimpl From\u003cSecurityBits\u003e for WireLabel {\n    fn from(label: SecurityBits) -\u003e WireLabel {\n        WireLabel(label)\n    }\n}\n\nimpl From\u003cSecurityBits\u003e for Delta {\n    fn from(delta: SecurityBits) -\u003e Delta {\n        Delta(delta)\n    }\n}\n\nimpl From\u003cBitShare\u003e for PartialBitShare {\n    fn from(b: BitShare) -\u003e PartialBitShare {\n        PartialBitShare::from(\u0026b)\n    }\n}\n\nimpl From\u003c\u0026BitShare\u003e for PartialBitShare {\n    fn from(b: \u0026BitShare) -\u003e PartialBitShare {\n        PartialBitShare {\n            mac: b.mac,\n            bit: b.bit,\n        }\n    }\n}\n\nimpl WireLabel {\n    fn delta_xor(\u0026self, delta: \u0026Delta) -\u003e WireLabel {\n        WireLabel(self.0 ^ delta.0)\n    }\n\n    pub(crate) fn xor(\u0026self, rhs: \u0026WireLabel) -\u003e WireLabel {\n        WireLabel(self.0 ^ rhs.0)\n    }\n}\n\nimpl WireMask {\n    /// Returns a label matching the given {bit}.\n    #[inline]\n    pub(crate) fn label(\u0026self, bit: bool, delta: \u0026Delta) -\u003e WireLabel {\n        if bit {\n            self.label_0.delta_xor(delta)\n        } else {\n            self.label_0.clone()\n        }\n    }\n\n    /// Computes a new wire mask under XOR-homomorphism.\n    #[inline]\n    pub(crate) fn xor(\u0026self, rhs: \u0026WireMask) -\u003e WireMask {\n        let label_0 = self.label_0.xor(\u0026rhs.label_0);\n        WireMask {\n            label_0,\n            bit: self.bit.xor(\u0026rhs.bit),\n        }\n    }\n\n    /// Negates the current WireMask.\n    ///\n    /// (This is used to enable `NOT` gate support at the engine-level.)\n    #[inline]\n    pub(crate) fn not(\u0026self, delta: \u0026Delta) -\u003e WireMask {\n        WireMask {\n            label_0: self.label_0.delta_xor(delta),\n            bit: self.bit,\n        }\n    }\n}\n\nimpl BitShare {\n    /// XOR homomorphism.\n    pub(crate) fn xor(\u0026self, rhs: \u0026BitShare) -\u003e BitShare {\n        BitShare {\n            key: KeyType(self.key.0 ^ rhs.key.0),\n            mac: MacType(self.mac.0 ^ rhs.mac.0),\n            bit: self.bit ^ rhs.bit,\n        }\n    }\n}\n\nimpl PartialBitShare {\n    /// MAC verification of an authenticated bit.\n    pub(crate) fn verify(\u0026self, key: \u0026KeyType, delta: \u0026Delta) -\u003e bool {\n        (if self.bit { delta.0 } else { 0 }) ^ key.0 == self.mac.0\n    }\n}\n\n#[test]\nfn test_xor_impl() {\n    use rand_chacha::ChaCha20Rng;\n    use rand_core::SeedableRng;\n    \n    let mut rng = ChaCha20Rng::from_entropy();\n    for _ in 0..20 {\n        let x = rng.next_u64() as u128 | ((rng.next_u64() as u128) \u003c\u003c 64);\n        let y = rng.next_u64() as u128 | ((rng.next_u64() as u128) \u003c\u003c 64);\n\n        assert_eq!(KeyType(x ^ y), KeyType(x) ^ KeyType(y));\n        assert_eq!(MacType(x ^ y), MacType(x) ^ MacType(y));\n        assert_eq!(KeyType(x ^ y), KeyType(x) ^ y);\n        assert_eq!(MacType(x ^ y), MacType(x) ^ y);\n    }\n}\n","traces":[{"line":20,"address":[837232],"length":1,"stats":{"Line":3}},{"line":21,"address":[837268],"length":1,"stats":{"Line":4}},{"line":28,"address":[764400],"length":1,"stats":{"Line":5}},{"line":29,"address":[764436],"length":1,"stats":{"Line":6}},{"line":40,"address":[764448],"length":1,"stats":{"Line":4}},{"line":41,"address":[764484],"length":1,"stats":{"Line":4}},{"line":48,"address":[764496],"length":1,"stats":{"Line":5}},{"line":49,"address":[837412],"length":1,"stats":{"Line":3}},{"line":54,"address":[764544],"length":1,"stats":{"Line":2}},{"line":118,"address":[933216],"length":1,"stats":{"Line":7}},{"line":119,"address":[566542],"length":1,"stats":{"Line":5}},{"line":124,"address":[764576],"length":1,"stats":{"Line":2}},{"line":125,"address":[837474],"length":1,"stats":{"Line":3}},{"line":130,"address":[764608],"length":1,"stats":{"Line":4}},{"line":136,"address":[764640],"length":1,"stats":{"Line":0}},{"line":142,"address":[622032],"length":1,"stats":{"Line":0}},{"line":143,"address":[837560],"length":1,"stats":{"Line":0}},{"line":148,"address":[622064],"length":1,"stats":{"Line":5}},{"line":150,"address":[764715],"length":1,"stats":{"Line":5}},{"line":151,"address":[764723],"length":1,"stats":{"Line":5}},{"line":157,"address":[764752],"length":1,"stats":{"Line":2}},{"line":158,"address":[764765],"length":1,"stats":{"Line":2}},{"line":161,"address":[622160],"length":1,"stats":{"Line":3}},{"line":162,"address":[622173],"length":1,"stats":{"Line":3}},{"line":169,"address":[764848],"length":1,"stats":{"Line":4}},{"line":170,"address":[764883],"length":1,"stats":{"Line":3}},{"line":171,"address":[837798],"length":1,"stats":{"Line":2}},{"line":173,"address":[622252],"length":1,"stats":{"Line":3}},{"line":179,"address":[622320],"length":1,"stats":{"Line":3}},{"line":180,"address":[837891],"length":1,"stats":{"Line":3}},{"line":183,"address":[837928],"length":1,"stats":{"Line":3}},{"line":191,"address":[838000],"length":1,"stats":{"Line":2}},{"line":193,"address":[838048],"length":1,"stats":{"Line":2}},{"line":194,"address":[765183],"length":1,"stats":{"Line":2}},{"line":201,"address":[765248],"length":1,"stats":{"Line":3}},{"line":203,"address":[838148],"length":1,"stats":{"Line":2}},{"line":204,"address":[765288],"length":1,"stats":{"Line":2}},{"line":205,"address":[765310],"length":1,"stats":{"Line":4}},{"line":212,"address":[765344],"length":1,"stats":{"Line":2}},{"line":213,"address":[765374],"length":1,"stats":{"Line":3}}],"covered":37,"coverable":40},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","tests","circuits.rs"],"content":"use mpc_core::{Circuit, Error, Gate};\n\n#[test]\nfn test_missing_output_gates() -\u003e Result\u003c(), Error\u003e {\n    let program = Circuit::new(vec![Gate::InContrib, Gate::InEval, Gate::Xor(0, 1)], vec![]);\n\n    for in_a in vec![true, false] {\n        for in_b in vec![true, false] {\n            let input_a = vec![in_a];\n            let input_b = vec![in_b];\n\n            let result = mpc_core::simulate(\u0026program, \u0026input_a, \u0026input_b);\n\n            assert_eq!(result, Err(Error::InvalidCircuit));\n        }\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_invalid_gates() -\u003e Result\u003c(), Error\u003e {\n    let invalid_xor = Circuit::new(\n        vec![Gate::InContrib, Gate::InEval, Gate::Xor(0, 500)],\n        vec![2],\n    );\n    let invalid_and = Circuit::new(\n        vec![Gate::InContrib, Gate::InEval, Gate::And(0, 500)],\n        vec![2],\n    );\n    let invalid_not = Circuit::new(vec![Gate::InContrib, Gate::InEval, Gate::Not(500)], vec![2]);\n\n    for program in [invalid_xor, invalid_and, invalid_not] {\n        for in_a in vec![true, false] {\n            for in_b in vec![true, false] {\n                let input_a = vec![in_a];\n                let input_b = vec![in_b];\n\n                let result = mpc_core::simulate(\u0026program, \u0026input_a, \u0026input_b);\n                assert_eq!(result, Err(Error::InvalidCircuit));\n            }\n        }\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_invalid_output_gates() -\u003e Result\u003c(), Error\u003e {\n    let program = Circuit::new(\n        vec![Gate::InContrib, Gate::InEval, Gate::Xor(0, 1)],\n        vec![3],\n    );\n\n    for in_a in vec![true, false] {\n        for in_b in vec![true, false] {\n            let input_a = vec![in_a];\n            let input_b = vec![in_b];\n\n            let result = mpc_core::simulate(\u0026program, \u0026input_a, \u0026input_b);\n\n            assert_eq!(result, Err(Error::InvalidCircuit));\n        }\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_invalid_input_len() -\u003e Result\u003c(), Error\u003e {\n    let program = Circuit::new(\n        vec![Gate::InContrib, Gate::InEval, Gate::Xor(0, 1)],\n        vec![2],\n    );\n\n    for input_a in [vec![], vec![true], vec![true, false]] {\n        for input_b in [vec![], vec![true], vec![true, false]] {\n            let result = mpc_core::simulate(\u0026program, \u0026input_a, \u0026input_b);\n\n            if input_a.len() == 1 \u0026\u0026 input_b.len() == 1 {\n                assert!(result.is_ok());\n            } else {\n                assert_eq!(result, Err(Error::InsufficientInput));\n            }\n        }\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_max_gates_exceeded() -\u003e Result\u003c(), Error\u003e {\n    let max_gates = (u32::MAX \u003e\u003e 4) as usize;\n    let mut gates = Vec::with_capacity(max_gates + 3);\n    gates.push(Gate::InContrib);\n    gates.push(Gate::InEval);\n    for i in 0..max_gates + 1 {\n        gates.push(Gate::Xor(0, i as u32))\n    }\n    let program = Circuit::new(gates, vec![2]);\n    assert_eq!(program.validate(), Err(Error::MaxCircuitSizeExceeded));\n    Ok(())\n}\n\n#[test]\nfn test_max_and_gates_exceeded() -\u003e Result\u003c(), Error\u003e {\n    let max_and_gates = (u32::MAX \u003e\u003e 8) as usize;\n    let mut gates = Vec::with_capacity(max_and_gates + 3);\n    gates.push(Gate::InContrib);\n    gates.push(Gate::InEval);\n    for i in 0..max_and_gates + 1 {\n        gates.push(Gate::And(0, i as u32))\n    }\n    let program = Circuit::new(gates, vec![2]);\n    assert_eq!(program.validate(), Err(Error::MaxCircuitSizeExceeded));\n    Ok(())\n}\n\n#[test]\nfn test_xor() -\u003e Result\u003c(), Error\u003e {\n    let program = Circuit::new(\n        vec![Gate::InContrib, Gate::InEval, Gate::Xor(0, 1)],\n        vec![2],\n    );\n\n    for in_a in vec![true, false] {\n        for in_b in vec![true, false] {\n            let input_a = vec![in_a];\n            let input_b = vec![in_b];\n\n            let result = mpc_core::simulate(\u0026program, \u0026input_a, \u0026input_b)?;\n\n            assert_eq!(result, vec![in_a ^ in_b]);\n        }\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_not_simple() -\u003e Result\u003c(), Error\u003e {\n    let program = Circuit::new(\n        vec![\n            Gate::InContrib,\n            Gate::InEval,\n            Gate::Not(0),\n            Gate::Not(1),\n            Gate::Not(2),\n            Gate::Not(3),\n        ],\n        vec![2, 3, 4, 5],\n    );\n\n    for in_a in vec![true, false] {\n        for in_b in vec![true, false] {\n            let input_a = vec![in_a];\n            let input_b = vec![in_b];\n\n            let result = mpc_core::simulate(\u0026program, \u0026input_a, \u0026input_b)?;\n\n            assert_eq!(result, vec![!in_a, !in_b, in_a, in_b]);\n        }\n    }\n    Ok(())\n}\n\n#[test]\nfn test_not() -\u003e Result\u003c(), Error\u003e {\n    let program = Circuit::new(\n        vec![\n            Gate::InContrib,\n            Gate::InEval,\n            Gate::Xor(0, 1),\n            // gate 3 : !not(xor)\n            Gate::Not(2),\n            Gate::Not(0),\n            Gate::Not(1),\n            // gate 6: Xor(!a, b)\n            Gate::Xor(4, 1),\n            // gate 7: Xor(a, !b)\n            Gate::Xor(0, 5),\n            // gate 8: !Xor(a, !b)\n            Gate::Not(7),\n            Gate::And(0, 1),\n            // gate 10: NAND(a, b)\n            Gate::Not(9),\n        ],\n        vec![2, 3, 6, 7, 8, 10],\n    );\n\n    for in_a in vec![true, false] {\n        for in_b in vec![true, false] {\n            let input_a = vec![in_a];\n            let input_b = vec![in_b];\n\n            let result = mpc_core::simulate(\u0026program, \u0026input_a, \u0026input_b)?;\n\n            assert_eq!(\n                result,\n                vec![\n                    in_a ^ in_b,\n                    !(in_a ^ in_b),\n                    (!in_a) ^ in_b,\n                    in_a ^ (!in_b),\n                    !(in_a ^ (!in_b)),\n                    !(in_a \u0026 in_b)\n                ]\n            );\n        }\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_and_xor() -\u003e Result\u003c(), Error\u003e {\n    let program = Circuit::new(\n        vec![\n            Gate::InContrib,\n            Gate::InEval,\n            Gate::Xor(0, 1),\n            Gate::And(1, 0),\n        ],\n        vec![2, 3],\n    );\n\n    for in_a in vec![true, false] {\n        for in_b in vec![true, false] {\n            let input_a = vec![in_a];\n            let input_b = vec![in_b];\n\n            let result = mpc_core::simulate(\u0026program, \u0026input_a, \u0026input_b)?;\n\n            assert_eq!(result, vec![in_a ^ in_b, in_a \u0026 in_b]);\n        }\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_and_deep() -\u003e Result\u003c(), Error\u003e {\n    let program = Circuit::new(\n        vec![\n            Gate::InContrib,\n            Gate::InContrib,\n            Gate::InEval,\n            Gate::InEval,\n            Gate::And(0, 2),\n            Gate::And(1, 3),\n            Gate::And(4, 5),\n            Gate::Xor(4, 5),\n        ],\n        vec![4, 5, 6, 7],\n    );\n\n    for bitvec in 0..16 {\n        let a0 = test_bit(bitvec, 0);\n        let a1 = test_bit(bitvec, 1);\n        let b0 = test_bit(bitvec, 2);\n        let b1 = test_bit(bitvec, 3);\n\n        let input_a = vec![a0, a1];\n        let input_b = vec![b0, b1];\n\n        let result = mpc_core::simulate(\u0026program, \u0026input_a, \u0026input_b)?;\n\n        assert_eq!(\n            result,\n            vec![a0 \u0026 b0, a1 \u0026 b1, a0 \u0026 b0 \u0026 a1 \u0026 b1, (a0 \u0026 b0) ^ (a1 \u0026 b1)],\n            \"a0={}, a1={}, b0={}, b1={}\",\n            a0,\n            a1,\n            b0,\n            b1\n        );\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_large_and() -\u003e Result\u003c(), Error\u003e {\n    const N_AND_GATES: usize = 5;\n    const N_RESULT_BITS: usize = N_AND_GATES;\n\n    let mut and_gates: Vec\u003cGate\u003e = (0..N_AND_GATES).map(|_| Gate::And(0, 1)).collect();\n    let mut input_gates: Vec\u003cGate\u003e = vec![Gate::InContrib, Gate::InEval];\n\n    input_gates.append(\u0026mut and_gates);\n\n    let program = Circuit::new(input_gates, (2..(N_RESULT_BITS as u32 + 2)).collect());\n\n    for bitvec in 3..4 {\n        let a0 = test_bit(bitvec, 0);\n        let b0 = test_bit(bitvec, 1);\n\n        let input_a = vec![a0];\n        let input_b = vec![b0];\n\n        let result = mpc_core::simulate(\u0026program, \u0026input_a, \u0026input_b)?;\n\n        assert_eq!(\n            result,\n            Vec::from([a0 \u0026 b0; N_RESULT_BITS]),\n            \"Test: a0={:?} b0={:?}\",\n            a0,\n            b0\n        );\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_insufficient_input() {\n    let program = Circuit::new(\n        vec![Gate::InContrib, Gate::InEval, Gate::Xor(0, 1)],\n        vec![2],\n    );\n\n    assert_eq!(\n        mpc_core::simulate(\u0026program, \u0026[], \u0026[]),\n        Err(Error::InsufficientInput)\n    );\n    assert_eq!(\n        mpc_core::simulate(\u0026program, \u0026[true], \u0026[]),\n        Err(Error::InsufficientInput)\n    );\n    assert_eq!(\n        mpc_core::simulate(\u0026program, \u0026[], \u0026[true]),\n        Err(Error::InsufficientInput)\n    );\n}\n\n#[test]\nfn test_unsupported_program() {\n    let program = Circuit::new(vec![Gate::Xor(0, 0)], vec![0]);\n\n    assert_eq!(\n        mpc_core::simulate(\u0026program, \u0026[], \u0026[]),\n        Err(Error::InvalidCircuit)\n    );\n}\n\nfn test_bit(value: i32, idx: u8) -\u003e bool {\n    (value \u0026 (1 \u003c\u003c idx)) != 0\n}\n","traces":[{"line":346,"address":[312768],"length":1,"stats":{"Line":2}},{"line":347,"address":[312833,312791],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","tests","credit_scoring.rs"],"content":"use mpc_garble_interop::{\n    check_program, compile_program, deserialize_output, serialize_input, Role,\n};\n\n#[test]\nfn compute_score() -\u003e Result\u003c(), String\u003e {\n    let credit_scoring = include_str!(\"credit_scoring_setup/credit_scoring.garble.rs\");\n    println!(\"Parsing and type-checking...\");\n    let typed_prg = check_program(credit_scoring)?;\n\n    println!(\"Compiling...\");\n    let circuit = compile_program(\u0026typed_prg, \"compute_score\")?;\n\n    println!(\"Running program...\");\n    let credit_scorer_input = serialize_input(\n        Role::Contributor,\n        \u0026typed_prg,\n        \u0026circuit.fn_def,\n        SCORING_ALGORITHM,\n    )?;\n\n    let user_input = serialize_input(Role::Evaluator, \u0026typed_prg, \u0026circuit.fn_def, USER)?;\n\n    let result = mpc_core::simulate(\u0026circuit.gates, \u0026credit_scorer_input, \u0026user_input).unwrap();\n\n    let score = deserialize_output(\u0026typed_prg, \u0026circuit.fn_def, \u0026result)?;\n\n    assert_eq!(score.to_string(), \"Score::Good(85)\");\n\n    Ok(())\n}\n\nconst SCORING_ALGORITHM: \u0026str = \"\nScoringAlgorithm {\n    age_score: [\n        MatchClause::Range(\n            Range {\n                min: 0i64,\n                max: 18i64,\n            },\n            Points { inc: 0i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 18i64,\n                max: 35i64,\n            },\n            Points { inc: 50i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 35i64,\n                max: 65i64,\n            },\n            Points { inc: 100i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 65i64,\n                max: 120i64,\n            },\n            Points { inc: 50i32 },\n        ),\n    ],\n    income_score: [\n        MatchClause::Range(\n            Range {\n                min: 2000i64,\n                max: 5000i64,\n            },\n            Points { inc: 50i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 5000i64,\n                max: 10000i64,\n            },\n            Points { inc: 100i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 10000i64,\n                max: 999999999i64,\n            },\n            Points { inc: 200i32 },\n        ),\n        MatchClause::None,\n    ],\n    account_balance_score: [\n        MatchClause::Range(\n            Range {\n                min: -999999999i64,\n                max: 0i64,\n            },\n            Points { inc: -100i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 0i64,\n                max: 5000i64,\n            },\n            Points { inc: 0i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 5000i64,\n                max: 10000i64,\n            },\n            Points { inc: 50i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 10000i64,\n                max: 999999999i64,\n            },\n            Points { inc: 200i32 },\n        ),\n    ],\n    current_loans_score: [\n        MatchClause::Range(\n            Range {\n                min: 500000i64,\n                max: 100000000i64,\n            },\n            Points { inc: 0i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 100000i64,\n                max: 500000i64,\n            },\n            Points { inc: 150i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 0i64,\n                max: 100000i64,\n            },\n            Points { inc: 300i32 },\n        ),\n        MatchClause::None,\n    ],\n    credit_card_score: [\n        MatchClause::Range(\n            Range {\n                min: 0i64,\n                max: 10000i64,\n            },\n            Points { inc: 100i32 },\n        ),\n        MatchClause::None,\n        MatchClause::None,\n        MatchClause::None,\n    ],\n    bankruptcy_score: [\n        MatchClause::Bool(true, Points { inc: -100i32 }),\n        MatchClause::Bool(false, Points { inc: 50i32 }),\n    ],\n    loan_payment_history_score: [\n        MatchClause::Range(\n            Range {\n                min: 0i64,\n                max: 3i64,\n            },\n            Points { inc: 0i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 3i64,\n                max: 6i64,\n            },\n            Points { inc: -100i32 },\n        ),\n        MatchClause::None,\n        MatchClause::None,\n    ],\n    credit_payment_history_score: [\n        MatchClause::Range(\n            Range {\n                min: 0i64,\n                max: 1i64,\n            },\n            Points { inc: 0i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 1i64,\n                max: 3i64,\n            },\n            Points { inc: -100i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 3i64,\n                max: 6i64,\n            },\n            Points { inc: -200i32 },\n        ),\n        MatchClause::None,\n    ],\n    surety_income_score: [\n        MatchClause::Range(\n            Range {\n                min: 0i64,\n                max: 1000i64,\n            },\n            Points { inc: -50i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 1000i64,\n                max: 5000i64,\n            },\n            Points { inc: 0i32 },\n        ),\n        MatchClause::Range(\n            Range {\n                min: 5000i64,\n                max: 10000i64,\n            },\n            Points { inc: 100i32 },\n        ),\n        MatchClause::None,\n    ],\n    score_limits: ScoreLimits {\n        min: 0i32,\n        max: 1000i32,\n    },\n}\";\n\nconst USER: \u0026str = \"\nUser {\n    age: 37u8,\n    income: 5500u32,\n    account_balance: 25000i64,\n    current_loans: 60000u64,\n    credit_card_limit: 1000u32,\n    ever_bankrupt: false,\n    loan_payment_failures: 0u8,\n    credit_payment_failures: 2u8,\n    surety_income: 5000u32,\n}\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_core","tests","credit_scoring_setup","credit_scoring.garble.rs"],"content":"pub fn compute_score(scoring_algorithm: ScoringAlgorithm, user: User) -\u003e Score {\n  let User {\n      age,\n      income,\n      account_balance,\n      current_loans,\n      credit_card_limit,\n      ever_bankrupt,\n      loan_payment_failures,\n      credit_payment_failures,\n      surety_income,\n  } = user;\n  let ScoringAlgorithm {\n      age_score,\n      income_score,\n      account_balance_score,\n      current_loans_score,\n      credit_card_score,\n      bankruptcy_score,\n      loan_payment_history_score,\n      credit_payment_history_score,\n      surety_income_score,\n      score_limits,\n  } = scoring_algorithm;\n\n  let age_points = compute_age_points(age, age_score);\n\n  let income_points = compute_income_points(income, income_score);\n\n  let account_balance_points =\n      compute_account_balance_points(account_balance, account_balance_score);\n\n  let current_loans_points = compute_current_loans_points(current_loans, current_loans_score);\n\n  let credit_card_points = compute_credit_card_points(credit_card_limit, credit_card_score);\n\n  let bankruptcy_points = compute_bankruptcy_points(ever_bankrupt, bankruptcy_score);\n\n  let loan_payment_history_points =\n      compute_loan_payment_history_points(loan_payment_failures, loan_payment_history_score);\n\n  let credit_payment_history_points = compute_credit_payment_history_points(\n      credit_payment_failures,\n      credit_payment_history_score,\n  );\n\n  let surety_income_points = compute_surety_income_points(surety_income, surety_income_score);\n\n  let total_points = age_points\n      + income_points\n      + account_balance_points\n      + current_loans_points\n      + credit_card_points\n      + bankruptcy_points\n      + loan_payment_history_points\n      + credit_payment_history_points\n      + surety_income_points;\n\n  compute_final_score(total_points, score_limits);\n}\n\nfn compute_age_points(age: u8, age_score: [MatchClause; 4]) -\u003e i32 {\n  let mut age_points = 0i32;\n  for clause in age_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n              if age as i64 \u003e= min \u0026\u0026 (age as i64) \u003c max {\n                  age_points = age_points + inc\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  age_points\n}\n\nfn compute_income_points(income: u32, income_score: [MatchClause; 4]) -\u003e i32 {\n  let mut income_points = 0i32;\n  for clause in income_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n              if income as i64 \u003e= min \u0026\u0026 (income as i64) \u003c max {\n                  income_points = income_points + inc\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  income_points\n}\n\nfn compute_account_balance_points(\n  account_balance: i64,\n  account_balance_score: [MatchClause; 4],\n) -\u003e i32 {\n  let mut account_balance_points = 0i32;\n  for clause in account_balance_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n              if account_balance \u003e= min \u0026\u0026 account_balance \u003c max {\n                  account_balance_points = account_balance_points + inc\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  account_balance_points\n}\n\nfn compute_current_loans_points(current_loans: u64, current_loans_score: [MatchClause; 4]) -\u003e i32 {\n  let mut current_loans_points = 0i32;\n  for clause in current_loans_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n              if current_loans as i64 \u003e= min \u0026\u0026 (current_loans as i64) \u003c max {\n                  current_loans_points = current_loans_points + inc\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  current_loans_points\n}\n\nfn compute_credit_card_points(credit_card_limit: u32, credit_card_score: [MatchClause; 4]) -\u003e i32 {\n  let mut credit_card_points = 0i32;\n  for clause in credit_card_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n              if credit_card_limit as i64 \u003e= min \u0026\u0026 (credit_card_limit as i64) \u003c max {\n                  credit_card_points = credit_card_points + inc;\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  credit_card_points\n}\n\nfn compute_bankruptcy_points(ever_bankrupt: bool, bankruptcy_score: [MatchClause; 2]) -\u003e i32 {\n  let mut bankruptcy_points = 0i32;\n  for clause in bankruptcy_score {\n      match clause {\n          MatchClause::Bool(boolean, points) =\u003e {\n              let Points { inc } = points;\n              if ever_bankrupt == boolean {\n                  bankruptcy_points = bankruptcy_points + inc;\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  bankruptcy_points\n}\n\nfn compute_loan_payment_history_points(\n  loan_payment_failures: u8,\n  loan_payment_history_score: [MatchClause; 4],\n) -\u003e i32 {\n  let mut loan_payment_history_points = 0i32;\n\n  for clause in loan_payment_history_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n\n              if loan_payment_failures as i64 \u003e= min \u0026\u0026 (loan_payment_failures as i64) \u003c max {\n                  loan_payment_history_points = loan_payment_history_points + inc\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  loan_payment_history_points\n}\n\nfn compute_credit_payment_history_points(\n  credit_payment_failures: u8,\n  credit_payment_history_score: [MatchClause; 4],\n) -\u003e i32 {\n  let mut credit_payment_history_points = 0i32;\n  for clause in credit_payment_history_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n\n              if credit_payment_failures as i64 \u003e= min \u0026\u0026 (credit_payment_failures as i64) \u003c max {\n                  credit_payment_history_points = credit_payment_history_points + inc\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  credit_payment_history_points\n}\n\nfn compute_surety_income_points(surety_income: u32, surety_income_score: [MatchClause; 4]) -\u003e i32 {\n  let mut surety_income_points = 0i32;\n\n  for clause in surety_income_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n\n              if surety_income as i64 \u003e= min \u0026\u0026 (surety_income as i64) \u003c max {\n                  surety_income_points = surety_income_points + inc\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  surety_income_points\n}\n\nfn compute_final_score(total_points: i32, score_limits: ScoreLimits) -\u003e Score {\n  if total_points \u003c= score_limits.min {\n      Score::Bad(0u8)\n  } else if total_points \u003e= score_limits.max {\n      Score::Good(100u8)\n  } else {\n      let score = (total_points * 100i32) / score_limits.max;\n      if score \u003c 50i32 {\n          Score::Bad(score as u8)\n      } else {\n          Score::Good(score as u8)\n      }\n  }\n}\n\nstruct User {\n  age: u8,\n  income: u32,\n  account_balance: i64,\n  current_loans: u64,\n  credit_card_limit: u32,\n  ever_bankrupt: bool,\n  loan_payment_failures: u8,\n  credit_payment_failures: u8,\n  surety_income: u32,\n}\n\nstruct ScoringAlgorithm {\n  age_score: [MatchClause; 4],\n  income_score: [MatchClause; 4],\n  account_balance_score: [MatchClause; 4],\n  current_loans_score: [MatchClause; 4],\n  credit_card_score: [MatchClause; 4],\n  bankruptcy_score: [MatchClause; 2],\n  loan_payment_history_score: [MatchClause; 4],\n  credit_payment_history_score: [MatchClause; 4],\n  surety_income_score: [MatchClause; 4],\n  score_limits: ScoreLimits,\n}\n\nenum MatchClause {\n  Range(Range, Points),\n  Bool(bool, Points),\n  None,\n}\n\nstruct Range {\n  min: i64,\n  max: i64,\n}\n\nstruct Points {\n  inc: i32,\n}\n\nstruct ScoreLimits {\n  min: i32,\n  max: i32,\n}\n\nenum Score {\n  Good(u8),\n  Bad(u8),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_garble_interop","src","lib.rs"],"content":"//! Interoperability between the mpc_core MPC engine and the Garble language.\n//!\n//! This crate provides helper functions for translating between the mpc_core MPC engine circuit\n//! representation and the Garble language circuit representation and types.\n\n#![deny(unsafe_code)]\n#![deny(missing_docs)]\n#![deny(rustdoc::broken_intra_doc_links)]\n\npub use garble_lang::{ast::Type, literal::*, TypedFnDef, TypedProgram};\n\n/// A mpc_core circuit together with its associated Garble types.\n#[derive(Debug, Clone)]\npub struct TypedCircuit {\n    /// Boolean circuit executable by the mpc_core engine.\n    pub gates: mpc_core::Circuit,\n    /// Typed Garble function corresponding to the mpc_core circuit.\n    pub fn_def: TypedFnDef,\n    /// Number of gates in the circuit as a formatted string.\n    ///\n    /// E.g. \"79k gates (XOR: 44k, NOT: 13k, AND: 21k)\"\n    pub info_about_gates: String,\n}\n\n/// The role of a party in the MPC execution (evaluator or contributor).\n#[derive(Debug, Clone, Copy)]\npub enum Role {\n    /// The party that contributes its input to the MPC protocol.\n    Contributor,\n    /// The party that evaluates the circuit and the output.\n    Evaluator,\n}\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, String\u003e;\n\n/// Scans, parses and type-checks a Garble program.\npub fn check_program(program: \u0026str) -\u003e Result\u003cTypedProgram\u003e {\n    garble_lang::check(program).map_err(|e| e.prettify(program))\n}\n\n/// Compiles the (type-checked) program, producing a circuit of gates.\n///\n/// Assumes that the input program has been correctly type-checked and **panics** if\n/// incompatible types are found that should have been caught by the type-checker.\npub fn compile_program(prg: \u0026TypedProgram, fn_name: \u0026str) -\u003e Result\u003cTypedCircuit\u003e {\n    let (circuit, fn_def) = prg.compile(fn_name).map_err(|e| format!(\"{:?}\", e))?;\n    let info_about_gates = circuit.report_gates();\n    if circuit.input_gates.len() != 2 {\n        return Err(\"The main function is not a 2-Party function\".to_string());\n    }\n\n    // Garble script semantics are as follows: input at index `i` implicitly belongs to party `i`\n    // In our case, party `0` is `Party A` in mpc_core terms; likewise, party `1` is `Party B`\n    let input_party_a = circuit.input_gates.first().copied().unwrap_or(0);\n    let input_party_b = circuit.input_gates.get(1).copied().unwrap_or(0);\n\n    let mut gates: Vec\u003cmpc_core::Gate\u003e =\n        Vec::with_capacity(circuit.gates.len() + input_party_a + input_party_b);\n\n    // here we simply resize to `clone` the respective input gates into the vec...\n    gates.resize(input_party_a, mpc_core::Gate::InContrib);\n    gates.resize(input_party_a + input_party_b, mpc_core::Gate::InEval);\n\n    // as Garble and mpc_core are independent code bases right now, we must currently map\n    // between the 2 type systems in this rather straight-forward way.\n    for gate in circuit.gates {\n        gates.push(match gate {\n            garble_lang::circuit::Gate::Xor(lhs, rhs) =\u003e {\n                mpc_core::Gate::Xor(lhs as mpc_core::GateIndex, rhs as mpc_core::GateIndex)\n            }\n            garble_lang::circuit::Gate::And(lhs, rhs) =\u003e {\n                mpc_core::Gate::And(lhs as mpc_core::GateIndex, rhs as mpc_core::GateIndex)\n            }\n            garble_lang::circuit::Gate::Not(source) =\u003e {\n                mpc_core::Gate::Not(source as mpc_core::GateIndex)\n            }\n        })\n    }\n\n    let output_gates = circuit\n        .output_gates\n        .iter()\n        .map(|i| *i as mpc_core::GateIndex)\n        .collect();\n    let program = mpc_core::Circuit::new(gates, output_gates);\n\n    Ok(TypedCircuit {\n        gates: program,\n        fn_def: fn_def.clone(),\n        info_about_gates,\n    })\n}\n\n/// Returns the Garble type of the input associated with the specified role.\n///\n/// In the case of the contributor, the result will be the type of the _first_ function parameter.\n/// In the case of the evaluator, the result will be the type of the _second_ function parameter.\npub fn input_type(role: Role, fn_def: \u0026TypedFnDef) -\u003e \u0026'_ Type {\n    match role {\n        Role::Contributor =\u003e \u0026fn_def.params[0].ty,\n        Role::Evaluator =\u003e \u0026fn_def.params[1].ty,\n    }\n}\n\n/// Parses an input string as a Garble literal.\npub fn parse_input(\n    role: Role,\n    prg: \u0026TypedProgram,\n    fn_def: \u0026TypedFnDef,\n    input: \u0026str,\n) -\u003e Result\u003cLiteral\u003e {\n    let input_ty = input_type(role, fn_def);\n    Literal::parse(prg, input_ty, input).map_err(|e| e.prettify(input))\n}\n\n/// Parses an input string as a Garble literal and encodes it as input bits for the mpc_core engine.\npub fn serialize_input(\n    role: Role,\n    prg: \u0026TypedProgram,\n    fn_def: \u0026TypedFnDef,\n    input: \u0026str,\n) -\u003e Result\u003cVec\u003cbool\u003e\u003e {\n    let input_ty = input_type(role, fn_def);\n    let input = Literal::parse(prg, input_ty, input).map_err(|e| e.prettify(input))?;\n    let const_sizes = std::collections::HashMap::new();\n    Ok(input.as_bits(prg, \u0026const_sizes))\n}\n\n/// Decodes output bits from the mpc_core engine as a Garble literal.\npub fn deserialize_output(\n    prg: \u0026TypedProgram,\n    fn_def: \u0026TypedFnDef,\n    output: \u0026[bool],\n) -\u003e Result\u003cLiteral\u003e {\n    let output_ty = \u0026fn_def.ty;\n    let const_sizes = std::collections::HashMap::new();\n    Literal::from_result_bits(prg, output_ty, output, \u0026const_sizes).map_err(|e| e.prettify(\"\"))\n}\n","traces":[{"line":37,"address":[706816],"length":1,"stats":{"Line":1}},{"line":38,"address":[706859],"length":1,"stats":{"Line":1}},{"line":45,"address":[709169,709163,706912],"length":1,"stats":{"Line":1}},{"line":46,"address":[706959],"length":1,"stats":{"Line":1}},{"line":47,"address":[707344],"length":1,"stats":{"Line":1}},{"line":48,"address":[707415,707491],"length":1,"stats":{"Line":2}},{"line":49,"address":[707532,709405],"length":1,"stats":{"Line":0}},{"line":54,"address":[707497,707582],"length":1,"stats":{"Line":2}},{"line":55,"address":[707691],"length":1,"stats":{"Line":1}},{"line":57,"address":[707832],"length":1,"stats":{"Line":1}},{"line":61,"address":[707992],"length":1,"stats":{"Line":1}},{"line":62,"address":[708091],"length":1,"stats":{"Line":1}},{"line":66,"address":[708377,708175],"length":1,"stats":{"Line":2}},{"line":67,"address":[709336,708437],"length":1,"stats":{"Line":2}},{"line":68,"address":[709184],"length":1,"stats":{"Line":1}},{"line":69,"address":[709216],"length":1,"stats":{"Line":1}},{"line":71,"address":[709243],"length":1,"stats":{"Line":1}},{"line":72,"address":[709275],"length":1,"stats":{"Line":1}},{"line":74,"address":[709302],"length":1,"stats":{"Line":1}},{"line":75,"address":[709318],"length":1,"stats":{"Line":1}},{"line":80,"address":[708502],"length":1,"stats":{"Line":1}},{"line":83,"address":[715536,715546],"length":1,"stats":{"Line":2}},{"line":85,"address":[708622],"length":1,"stats":{"Line":1}},{"line":87,"address":[708880],"length":1,"stats":{"Line":1}},{"line":88,"address":[708705],"length":1,"stats":{"Line":1}},{"line":89,"address":[708785],"length":1,"stats":{"Line":1}},{"line":90,"address":[708848],"length":1,"stats":{"Line":1}},{"line":98,"address":[709552],"length":1,"stats":{"Line":1}},{"line":99,"address":[709578,709664],"length":1,"stats":{"Line":2}},{"line":100,"address":[709634],"length":1,"stats":{"Line":1}},{"line":101,"address":[709596],"length":1,"stats":{"Line":1}},{"line":106,"address":[709680],"length":1,"stats":{"Line":0}},{"line":112,"address":[709763],"length":1,"stats":{"Line":0}},{"line":113,"address":[709804],"length":1,"stats":{"Line":0}},{"line":117,"address":[709856,710529,710535],"length":1,"stats":{"Line":1}},{"line":123,"address":[709942],"length":1,"stats":{"Line":1}},{"line":124,"address":[709983],"length":1,"stats":{"Line":1}},{"line":125,"address":[710312],"length":1,"stats":{"Line":1}},{"line":126,"address":[710377,710455],"length":1,"stats":{"Line":2}},{"line":130,"address":[710560,710784,710790],"length":1,"stats":{"Line":1}},{"line":135,"address":[710624],"length":1,"stats":{"Line":1}},{"line":136,"address":[710641],"length":1,"stats":{"Line":1}},{"line":137,"address":[710685,710744],"length":1,"stats":{"Line":2}}],"covered":39,"coverable":43},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","benches","circuits.rs"],"content":"use std::time::Instant;\n\nuse criterion::{criterion_group, criterion_main, Criterion};\nuse mpc_http_client::{compute, MpcData, MpcProgram};\n\nmod common;\n\nfn and_10(c: \u0026mut Criterion) {\n    let source = include_str!(\"./circuits_setup/program.garble.rs\");\n    compute_circuit(source, \"and\", 10, c);\n}\n\nfn and_100(c: \u0026mut Criterion) {\n    let source = include_str!(\"./circuits_setup/program.garble.rs\");\n    compute_circuit(source, \"and\", 100, c);\n}\n\nfn and_1000(c: \u0026mut Criterion) {\n    let source = include_str!(\"./circuits_setup/program.garble.rs\");\n    compute_circuit(source, \"and\", 1000, c);\n}\n\nfn and_10000(c: \u0026mut Criterion) {\n    let source = include_str!(\"./circuits_setup/program.garble.rs\");\n    compute_circuit(source, \"and\", 10000, c);\n}\n\nfn xor_10(c: \u0026mut Criterion) {\n    let source = include_str!(\"./circuits_setup/program.garble.rs\");\n    compute_circuit(source, \"xor\", 10, c);\n}\n\nfn xor_100(c: \u0026mut Criterion) {\n    let source = include_str!(\"./circuits_setup/program.garble.rs\");\n    compute_circuit(source, \"xor\", 100, c);\n}\n\nfn xor_1000(c: \u0026mut Criterion) {\n    let source = include_str!(\"./circuits_setup/program.garble.rs\");\n    compute_circuit(source, \"xor\", 1000, c);\n}\n\nfn xor_10000(c: \u0026mut Criterion) {\n    let source = include_str!(\"./circuits_setup/program.garble.rs\");\n    compute_circuit(source, \"xor\", 10000, c);\n}\n\nfn circuits_benchmark(c: \u0026mut Criterion) {\n    common::compile_server();\n\n    and_10(c);\n    and_100(c);\n    and_1000(c);\n    and_10000(c);\n    xor_10(c);\n    xor_100(c);\n    xor_1000(c);\n    xor_10000(c);\n}\n\ncriterion_group!(benches, circuits_benchmark);\ncriterion_main!(benches);\n\nfn compute_circuit(source: \u0026str, gates: \u0026str, num_gates: u16, c: \u0026mut Criterion) {\n    let contrib_input = \"_\".to_string();\n\n    let function = format!(\"{gates}_{num_gates}\");\n\n    let compilation_start = Instant::now();\n\n    let program =\n        MpcProgram::new(source.to_string(), function).expect(\"Could not parse source code\");\n\n    println!(\"Garble compilation took {:?}\", compilation_start.elapsed());\n\n    println!(\"Circuit has {}\", program.report_gates());\n\n    common::with_server(\"./benches/circuits_setup\", |connection_string| {\n        let bench_id = format!(\n            \"{} gates mpc_http_client {num_gates}\",\n            gates.to_uppercase()\n        );\n        c.bench_function(\u0026bench_id, |b| {\n            b.to_async(tokio::runtime::Runtime::new().unwrap())\n                .iter(|| async {\n                    let eval_input =\n                        MpcData::from_string(\u0026program, format!(\"[true; {num_gates}]\")).unwrap();\n\n                    compute(\n                        connection_string.clone(),\n                        contrib_input.clone(),\n                        program.clone(),\n                        eval_input,\n                    )\n                    .await\n                    .unwrap();\n                })\n        });\n        Ok(())\n    })\n    .unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","benches","circuits_setup","program.garble.rs"],"content":"pub fn and_10(a: bool, b: [bool; 10]) -\u003e bool {\n    let mut acc_and = a;\n    for i in b {\n        acc_and = acc_and \u0026 i\n    }\n    acc_and\n}\n\npub fn and_100(a: bool, b: [bool; 100]) -\u003e bool {\n    let mut acc_and = a;\n    for i in b {\n        acc_and = acc_and \u0026 i\n    }\n    acc_and\n}\n\npub fn and_1000(a: bool, b: [bool; 1000]) -\u003e bool {\n    let mut acc_and = a;\n    for i in b {\n        acc_and = acc_and \u0026 i\n    }\n    acc_and\n}\n\npub fn and_10000(a: bool, b: [bool; 10000]) -\u003e bool {\n    let mut acc_and = a;\n    for i in b {\n        acc_and = acc_and \u0026 i\n    }\n    acc_and\n}\n\npub fn xor_10(a: bool, b: [bool; 10]) -\u003e bool {\n    let mut acc_xor = a;\n    for i in b {\n        acc_xor = acc_xor ^ i\n    }\n    acc_xor\n}\n\npub fn xor_100(a: bool, b: [bool; 100]) -\u003e bool {\n    let mut acc_xor = a;\n    for i in b {\n        acc_xor = acc_xor ^ i\n    }\n    acc_xor\n}\n\npub fn xor_1000(a: bool, b: [bool; 1000]) -\u003e bool {\n    let mut acc_xor = a;\n    for i in b {\n        acc_xor = acc_xor ^ i\n    }\n    acc_xor\n}\n\npub fn xor_10000(a: bool, b: [bool; 10000]) -\u003e bool {\n    let mut acc_xor = a;\n    for i in b {\n        acc_xor = acc_xor ^ i\n    }\n    acc_xor\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","benches","common","mod.rs"],"content":"use assert_cmd::prelude::CommandCargoExt;\nuse rand::{thread_rng, Rng};\nuse std::process::{Child, Command, Stdio};\n\nconst SERVER_CRATE: \u0026str = \"mpc_http_server\";\n\npub fn compile_server() {\n    println!(\"Compiling mpc_http_server, this might take a few minutes\");\n    Command::new(\"cargo\")\n        .arg(\"build\")\n        .arg(\"--features=bin\")\n        .arg(\"--release\")\n        .current_dir(\"../mpc_http_server\")\n        .stdout(Stdio::inherit())\n        .stderr(Stdio::inherit())\n        .output()\n        .unwrap();\n    println!(\"Compilation finished\");\n}\n\npub fn with_server\u003cF\u003e(path: \u0026str, test: F) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e\nwhere\n    F: FnOnce(\u0026String) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e,\n{\n    let (server, connection_string) = start_server(path)?;\n    let res = test(\u0026connection_string);\n    let stop = stop_server(server);\n    stop.and(res)\n}\n\nfn start_server(path: \u0026str) -\u003e Result\u003c(Child, String), Box\u003cdyn std::error::Error\u003e\u003e {\n    let port: u16 = thread_rng().gen_range(8001..=9000);\n    let port_str = port.to_string();\n    let mut cmd = Command::cargo_bin(\u0026SERVER_CRATE)?;\n    let mut proc = cmd\n        .current_dir(path)\n        .env(\"ROCKET_PORT\", port_str)\n        .env(\"ROCKET_LOG_LEVEL\", \"off\")\n        .spawn()?;\n    let connection_string = format!(\"127.0.0.1:{port}\");\n    for _ in 0..50 {\n        if std::net::TcpStream::connect(\u0026connection_string).is_ok() {\n            return Ok((proc, format!(\"http://127.0.0.1:{port}\")));\n        }\n        std::thread::sleep(std::time::Duration::from_millis(20));\n    }\n\n    let _ = proc.kill();\n    Err(StartTimeoutError {}.into())\n}\n\nfn stop_server(mut c: Child) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    c.kill()?;\n    c.wait()?;\n    Ok(())\n}\n\n#[derive(Debug)]\nstruct StartTimeoutError {}\nimpl std::fmt::Display for StartTimeoutError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.write_str(\"Timeout while strating mpc HTTP Server\")\n    }\n}\n\nimpl std::error::Error for StartTimeoutError {}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","benches","credit_scoring.rs"],"content":"use std::time::Instant;\n\nuse criterion::{criterion_group, criterion_main, Criterion};\nuse mpc_http_client::{compute, MpcData, MpcProgram};\n\nmod common;\n\nfn credit_scoring_benchmark(c: \u0026mut Criterion) {\n    common::compile_server();\n\n    let credit_scorer_input = \"scoring_algorithm1\".to_string();\n\n    let credit_scoring_prg =\n        include_str!(\"../../mpc_http_client/tests/credit_scoring_setup/program.garble.rs\")\n            .to_string();\n\n    let function = \"compute_score\".to_string();\n\n    let compilation_start = Instant::now();\n\n    let program =\n        MpcProgram::new(credit_scoring_prg, function).expect(\"Could not parse source code\");\n\n    println!(\"Garble compilation took {:?}\", compilation_start.elapsed());\n\n    println!(\"Circuit has {}\", program.report_gates());\n\n    common::with_server(\"./tests/credit_scoring_setup\", |connection_string| {\n        c.bench_function(\"credit scoring mpc_http_client\", |b| {\n            b.to_async(tokio::runtime::Runtime::new().unwrap())\n                .iter(|| async {\n                    let user_input = MpcData::from_string(\u0026program, USER.to_string()).unwrap();\n\n                    compute(\n                        connection_string.to_string().clone(),\n                        credit_scorer_input.clone(),\n                        program.clone(),\n                        user_input,\n                    )\n                    .await\n                    .unwrap();\n                })\n        });\n        Ok(())\n    })\n    .unwrap()\n}\n\ncriterion_group!(benches, credit_scoring_benchmark);\ncriterion_main!(benches);\n\nconst USER: \u0026str = \"User {\n    age: 37u8,\n    income: 5500u32,\n    account_balance: 25000i64,\n    current_loans: 60000u64,\n    credit_card_limit: 1000u32,\n    ever_bankrupt: false,\n    loan_payment_failures: 0u8,\n    credit_payment_failures: 2u8,\n    surety_income: 5000u32,\n}\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","benches","multiplications.rs"],"content":"use std::time::Instant;\n\nuse criterion::{criterion_group, criterion_main, Criterion};\nuse mpc_http_client::{compute, MpcData, MpcProgram};\n\nmod common;\n\nfn mul_1(c: \u0026mut Criterion) {\n    let source = include_str!(\"./multiplications_setup/program.garble.rs\");\n    compute_circuit(source, 1, c);\n}\n\nfn mul_10(c: \u0026mut Criterion) {\n    let source = include_str!(\"./multiplications_setup/program.garble.rs\");\n    compute_circuit(source, 10, c);\n}\n\nfn multiplications_benchmark(c: \u0026mut Criterion) {\n    common::compile_server();\n\n    mul_1(c);\n    mul_10(c);\n}\n\ncriterion_group!(benches, multiplications_benchmark);\ncriterion_main!(benches);\n\nfn compute_circuit(source: \u0026str, num_mul: u64, c: \u0026mut Criterion) {\n    let contrib_input = \"_\".to_string();\n\n    let function = format!(\"mul_{num_mul}\");\n\n    let compilation_start = Instant::now();\n\n    let program =\n        MpcProgram::new(source.to_string(), function).expect(\"Could not parse source code\");\n\n    println!(\"Garble compilation took {:?}\", compilation_start.elapsed());\n\n    println!(\"Circuit has {}\", program.report_gates());\n\n    common::with_server(\"./benches/multiplications_setup\", |connection_string| {\n        let bench_id = format!(\"mul_{num_mul} mpc_http_client\");\n\n        c.bench_function(\u0026bench_id, |b| {\n            b.to_async(tokio::runtime::Runtime::new().unwrap())\n                .iter(|| async {\n                    let eval_input = MpcData::from_string(\u0026program, \"42u64\".to_string()).unwrap();\n\n                    compute(\n                        connection_string.clone(),\n                        contrib_input.clone(),\n                        program.clone(),\n                        eval_input,\n                    )\n                    .await\n                    .unwrap();\n                })\n        });\n        Ok(())\n    })\n    .unwrap()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","benches","multiplications_setup","program.garble.rs"],"content":"pub fn mul_1(a: u64, b: u64) -\u003e u64 {\n    a * b\n}\n\npub fn mul_10(a: u64, b: u64) -\u003e u64 {\n    a * b * b * b * b * b * b * b * b * b * b\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","src","lib.rs"],"content":"//! HTTP client for the mpc_core SMPC engine.\n//!\n//! This crate provides an HTTP client acting as the `evaluator` and running the mpc_core Multi-Party\n//! Computation engine. An HTTP server is expected to act as the `contributor`.\n//!\n//! This crate provides a CLI client, as well as functions targeting WebAssembly to provide an easy\n//! integration of the mpc_core engine with JavaScript.\n//!\n//! This crate additionally includes an interactive notebook (provided by `index.html`) to run and\n//! test Garble programs during development.\n\n#![deny(unsafe_code)]\n#![deny(missing_docs)]\n#![deny(rustdoc::broken_intra_doc_links)]\n// otherwise wasm_bindgen causes a clippy warning, see\n// https://github.com/rustwasm/wasm-bindgen/issues/2774\n#![allow(clippy::unused_unit)]\n\nuse msg_queue::{MessageId, MsgQueue};\nuse rand_chacha::{rand_core::SeedableRng, ChaCha20Rng};\nuse reqwest::Response;\nuse serde::{Deserialize, Serialize};\nuse std::{collections::HashMap, fmt};\nuse mpc_core::{states::Msg, Circuit, CircuitBlake3Hash};\nuse mpc_garble_interop::{\n    check_program, compile_program, deserialize_output, parse_input, Role, TypedCircuit,\n};\npub use mpc_garble_interop::{Literal, VariantLiteral};\nuse url::Url;\n\n#[cfg(target_arch = \"wasm32\")]\nuse wasm_bindgen::{prelude::wasm_bindgen, JsValue};\n\nuse self::ValidationError::*;\n\nmod msg_queue;\n\n/// An MPC program that was type-checked and can be executed by the mpc_core engine.\n#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen)]\n#[derive(Debug, Clone)]\npub struct MpcProgram {\n    source_code: String,\n    function_name: String,\n    ast: mpc_garble_interop::TypedProgram,\n    circuit: mpc_garble_interop::TypedCircuit,\n}\n\n#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen)]\nimpl MpcProgram {\n    /// Type-checks the specified function, returning a compiled program.\n    #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen(constructor))]\n    pub fn new(source_code: String, function_name: String) -\u003e Result\u003cMpcProgram, Error\u003e {\n        let source_code = source_code.trim().to_string();\n        let ast = check_program(\u0026source_code).map_err(GarbleCompileTimeError)?;\n        let circuit = compile_program(\u0026ast, \u0026function_name).map_err(GarbleCompileTimeError)?;\n\n        if circuit.fn_def.params.len() != 2 {\n            return Err(ValidationError::GarbleProgramIsNoTwoPartyFunction.into());\n        }\n        Ok(Self {\n            source_code,\n            function_name,\n            ast,\n            circuit,\n        })\n    }\n\n    /// Returns the number of gates in the circuit as a formatted string.\n    ///\n    /// E.g. \"79k gates (XOR: 44k, NOT: 13k, AND: 21k)\"\n    pub fn report_gates(\u0026self) -\u003e String {\n        self.circuit.info_about_gates.to_string()\n    }\n}\n\n/// Stores data (either inputs or output) in an mpc_core-compatible format.\n#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen)]\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MpcData {\n    literal: Literal,\n}\n\n#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen)]\nimpl MpcData {\n    /// Parses and type-checks a Garble string literal as MpcData.\n    /// ```\n    /// // Garble program stored as a string.\n    /// let source_code = \"pub fn card_guess(house: Card, player: Card) -\u003e bool {\n    ///     house == player\n    /// }\n    ///\n    /// struct Card {\n    ///     suit: Suit,\n    ///     value: Value,\n    /// }\n    //\n    /// enum Suit {\n    ///     Diamonds,\n    ///     Clubs,\n    ///     Hearts,\n    ///     Spades,\n    /// }\n    ///\n    /// enum Value {\n    ///     Jack,\n    ///     Queen,\n    ///     King,\n    /// }\";\n    ///\n    /// let card_guess_program =\n    ///     mpc_core_http_client::MpcProgram::new(source_code.to_string(), \"card_guess\".to_string()).unwrap();\n    ///\n    /// let player_card_string = \"Card {suit: Suit::Diamonds, value: Value::Jack}\";\n    ///\n    /// let player_card =\n    ///     mpc_core_http_client::MpcData::from_string(\u0026card_guess_program, player_card_string.to_string())\n    ///         .unwrap();\n    ///\n    /// assert_eq!(\n    ///     player_card.to_literal_string(),\n    ///     \"Card {suit: Suit::Diamonds, value: Value::Jack}\"\n    /// );\n    /// ```\n    pub fn from_string(program: \u0026MpcProgram, input: String) -\u003e Result\u003cMpcData, Error\u003e {\n        let literal = parse_input(\n            Role::Evaluator,\n            \u0026program.ast,\n            \u0026program.circuit.fn_def,\n            \u0026input,\n        )\n        .map_err(GarbleCompileTimeError)?;\n        Ok(MpcData { literal })\n    }\n\n    /// Type-checks a Garble literal, returning it as MpcData.\n    /// ```\n    ///\n    /// use mpc_core_http_client::{Literal, VariantLiteral};\n    ///\n    /// let source_code = \"pub fn card_guess(house: Card, player: Card) -\u003e bool {\n    ///     house == player\n    /// }\n    ///\n    /// pub struct Card {\n    ///     suit: Suit,\n    ///     value: Value,\n    /// }\n    ///\n    /// enum Suit {\n    ///     Diamonds,\n    ///     Clubs,\n    ///     Hearts,\n    ///     Spades,\n    /// }\n    ///\n    /// enum Value {\n    ///     Jack,\n    ///     Queen,\n    ///     King,\n    /// }\";\n    ///\n    /// let player_card_literal = Literal::Struct(\n    ///     \"Card\".to_string(),\n    ///     vec![\n    ///         (\n    ///             \"suit\".to_string(),\n    ///             Literal::Enum(\n    ///                 \"Suit\".to_string(),\n    ///                 \"Diamonds\".to_string(),\n    ///                 VariantLiteral::Unit,\n    ///             ),\n    ///         ),\n    ///         (\n    ///             \"value\".to_string(),\n    ///             Literal::Enum(\n    ///                 \"Value\".to_string(),\n    ///                 \"Jack\".to_string(),\n    ///                 VariantLiteral::Unit,\n    ///             ),\n    ///         ),\n    ///     ],\n    /// );\n    ///\n    /// let card_guess_program =\n    ///     mpc_core_http_client::MpcProgram::new(source_code.to_string(), \"card_guess\".to_string()).unwrap();\n    ///\n    /// let player_card =\n    ///     mpc_core_http_client::MpcData::from_literal(\u0026card_guess_program, player_card_literal)\n    ///         .unwrap();\n    ///\n    /// assert_eq!(\n    ///     player_card.to_literal_string(),\n    ///     \"Card {suit: Suit::Diamonds, value: Value::Jack}\"\n    /// );\n    /// ```\n    #[cfg(not(target_arch = \"wasm32\"))]\n    pub fn from_literal(program: \u0026MpcProgram, literal: Literal) -\u003e Result\u003cMpcData, Error\u003e {\n        let expected_type =\n            mpc_garble_interop::input_type(Role::Evaluator, \u0026program.circuit.fn_def);\n        if !literal.is_of_type(\u0026program.ast, expected_type) {\n            return Err(Error::ValidationError(\n                ValidationError::GarbleCompileTimeError(format!(\n                    \"Input literal is not of the type {expected_type}\"\n                )),\n            ));\n        }\n        Ok(MpcData { literal })\n    }\n\n    /// Parses and type-checks a Garble literal in its JSON representation as MpcData.\n    /// ```\n    /// // Garble program stored as a string.\n    /// let source_code = \"pub fn card_guess(house: Card, player: Card) -\u003e bool {\n    ///     house == player\n    /// }\n    ///\n    /// struct Card {\n    ///     suit: Suit,\n    ///     value: Value,\n    /// }\n    ///\n    /// enum Suit {\n    ///     Diamonds,\n    ///     Clubs,\n    ///     Hearts,\n    ///     Spades,\n    /// }\n    ///\n    /// enum Value {\n    ///     Jack,\n    ///     Queen,\n    ///     King,\n    /// }\";\n    ///\n    /// let card_game_program =\n    ///     mpc_core_http_client::MpcProgram::new(source_code.to_string(), \"card_game\".to_string()).unwrap();\n    ///\n    /// let json_string = \"{\n    ///     \\\"Struct\\\": [\n    ///         \\\"Card\\\",\n    ///         [\n    ///             [\n    ///                 \\\"suit\\\",\n    ///                 {\n    ///                     \\\"Enum\\\": [\n    ///                         \\\"Suit\\\",\n    ///                         \\\"Diamonds\\\",\n    ///                         \\\"Unit\\\"\n    ///                     ]\n    ///                 }\n    ///             ],\n    ///             [\n    ///                 \\\"value\\\",\n    ///                 {\n    ///                     \\\"Enum\\\": [\n    ///                         \\\"Value\\\",\n    ///                         \\\"Jack\\\",\n    ///                         \\\"Unit\\\"\n    ///                     ]\n    ///                 }\n    ///             ]\n    ///         ]\n    ///     ]\n    /// }\";\n    ///\n    /// let js_value_literal = serde_json::from_str(json_string);\n    ///\n    /// let player_card = mpc_core_http_client::MpcData::from_object(\u0026card_guess_program, js_value_literal);\n    ///\n    /// assert_eq!(\n    ///     player_card.to_literal_string(),\n    ///     \"Card {suit: Suit::Diamonds, value: Value::Jack}\"\n    /// );\n    /// ```\n    ///\n    #[cfg(target_arch = \"wasm32\")]\n    pub fn from_object(program: \u0026MpcProgram, literal: JsValue) -\u003e Result\u003cMpcData, Error\u003e {\n        let literal: Literal =\n            serde_wasm_bindgen::from_value(literal).map_err(|e| Error::JsonError(e.to_string()))?;\n        let expected_type =\n            mpc_core_garble_interop::input_type(Role::Evaluator, \u0026program.circuit.fn_def);\n        if !literal.is_of_type(\u0026program.ast, \u0026expected_type) {\n            return Err(Error::ValidationError(\n                ValidationError::GarbleCompileTimeError(format!(\n                    \"Input literal is not of the type {expected_type}\"\n                )),\n            ));\n        }\n        Ok(MpcData { literal })\n    }\n\n    /// Returns MpcData as a Garble literal string.\n    ///\n    /// See [`MpcData::from_string`] for the format of the literal string returned here.\n    pub fn to_literal_string(\u0026self) -\u003e String {\n        format!(\"{}\", self.literal)\n    }\n\n    /// Returns MpcData as a Garble literal in its JSON representation.\n    ///\n    /// See [`MpcData::from_object`] for the format of the JsValue returned here.\n    #[cfg(target_arch = \"wasm32\")]\n    pub fn to_literal(\u0026self) -\u003e Result\u003cJsValue, serde_wasm_bindgen::Error\u003e {\n        serde_wasm_bindgen::to_value(\u0026self.literal)\n    }\n}\n\n/// Computes the specified program using Multi-Party Computation, keeping the input private.\n///\n/// A mpc_core server must be running at the specified url, to provide the contributor's input.\n///\n/// The client can send plaintext metadata to the server, to influence the server's choice of the\n/// input.\n#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen)]\npub async fn compute(\n    url: String,\n    plaintext_metadata: String,\n    program: MpcProgram,\n    input: MpcData,\n) -\u003e Result\u003cMpcData, Error\u003e {\n    let url = Url::parse(\u0026url)?;\n\n    let const_sizes = HashMap::new();\n    let my_input = input.literal.as_bits(\u0026program.ast, \u0026const_sizes);\n\n    let expected_input_len = program\n        .circuit\n        .gates\n        .gates()\n        .iter()\n        .filter(|\u0026gate| gate == \u0026mpc_core::Gate::InEval)\n        .count();\n\n    if expected_input_len != my_input.len() {\n        return Err(ValidationError::InvalidInput.into());\n    }\n\n    let client = mpc_coreClient::new(\u0026url);\n    let TypedCircuit { gates, fn_def, .. } = program.circuit;\n    let session = client\n        .new_session(\n            \u0026gates,\n            program.source_code.clone(),\n            program.function_name.clone(),\n            plaintext_metadata,\n        )\n        .await?;\n    let result = session.evaluate(gates, my_input).await?;\n    let literal =\n        deserialize_output(\u0026program.ast, \u0026fn_def, \u0026result).map_err(GarbleCompileTimeError)?;\n    Ok(MpcData { literal })\n}\n\ntype MessageLog = Vec\u003c(Msg, MessageId)\u003e;\n\n#[derive(Debug)]\nstruct mpc_coreClient {\n    url: Url,\n}\n\nstruct mpc_coreSession {\n    url: Url,\n    request_headers: HashMap\u003cString, String\u003e,\n}\n\n#[derive(Serialize, Debug)]\nstruct NewSession {\n    plaintext_metadata: String,\n    program: String,\n    function: String,\n    circuit_hash: CircuitBlake3Hash,\n    client_version: String,\n}\n\n#[derive(Deserialize, Debug, PartialEq, Eq)]\nstruct EngineCreationResult {\n    engine_id: String,\n    request_headers: HashMap\u003cString, String\u003e,\n    server_version: String,\n}\n\nimpl mpc_coreClient {\n    fn new(url: \u0026Url) -\u003e Self {\n        Self { url: url.clone() }\n    }\n\n    async fn new_session(\n        \u0026self,\n        circuit: \u0026Circuit,\n        source_code: String,\n        function: String,\n        plaintext_metadata: String,\n    ) -\u003e Result\u003cmpc_coreSession, Error\u003e {\n        let client_version = env!(\"CARGO_PKG_VERSION\").to_string();\n        let req = NewSession {\n            plaintext_metadata,\n            program: source_code,\n            function,\n            circuit_hash: circuit.blake3_hash(),\n            client_version: client_version.clone(),\n        };\n        let EngineCreationResult {\n            engine_id,\n            request_headers,\n            server_version: _server_version,\n        } = send_new_session(self.url.clone(), \u0026req).await?;\n        let url = self.url.join(\u0026engine_id)?;\n\n        Ok(mpc_coreSession {\n            url,\n            request_headers,\n        })\n    }\n}\n\nimpl mpc_coreSession {\n    async fn evaluate(self, circuit: Circuit, input: Vec\u003cbool\u003e) -\u003e Result\u003cVec\u003cbool\u003e, Error\u003e {\n        let mut context = MsgQueue::new();\n        let mut evaluator =\n            mpc_core::states::Evaluator::new(circuit, input, ChaCha20Rng::from_entropy())?;\n\n        let mut last_durably_received_offset: Option\u003cMessageId\u003e = None;\n        let mut steps_remaining = evaluator.steps();\n        loop {\n            let messages: Vec\u003c(\u0026Msg, MessageId)\u003e = context.msgs_iter().collect();\n            let (upstream_msgs, server_commited_offset) =\n                self.dialog(last_durably_received_offset, \u0026messages).await?;\n            if messages.last().map(|v| v.1) != server_commited_offset {\n                return Err(Error::MessageOffsetMismatch);\n            }\n\n            if let Some(last_durably_received_offset) = server_commited_offset {\n                context.flush_queue(last_durably_received_offset);\n            }\n\n            for (msg, server_offset) in \u0026upstream_msgs {\n                if *server_offset != last_durably_received_offset.map(|o| o + 1).unwrap_or(0) {\n                    return Err(Error::MessageOffsetMismatch);\n                }\n\n                if steps_remaining \u003e 0 {\n                    let (next_state, msg) = evaluator.run(msg)?;\n                    evaluator = next_state;\n                    steps_remaining -= 1;\n                    context.send(msg);\n                } else {\n                    return Ok(evaluator.output(msg)?);\n                }\n                last_durably_received_offset = Some(*server_offset);\n            }\n        }\n    }\n\n    async fn dialog(\n        \u0026self,\n        last_durably_received_offset: Option\u003cu32\u003e,\n        messages: \u0026[(\u0026Msg, MessageId)],\n    ) -\u003e Result\u003c(MessageLog, Option\u003cMessageId\u003e), Error\u003e {\n        send_msgs(\n            self.url.clone(),\n            \u0026self.request_headers,\n            last_durably_received_offset,\n            messages,\n        )\n        .await\n    }\n}\n\nasync fn send_new_session(url: Url, session: \u0026NewSession) -\u003e Result\u003cEngineCreationResult, Error\u003e {\n    let client = reqwest::Client::new();\n    let resp = client.post(url).json(session).send().await?;\n    let resp = resp_or_err(resp).await?;\n    Ok(resp.json::\u003cEngineCreationResult\u003e().await?)\n}\n\nasync fn send_msgs(\n    url: Url,\n    request_headers: \u0026HashMap\u003cString, String\u003e,\n    last_durably_received_offset: Option\u003cu32\u003e,\n    msgs: \u0026[(\u0026Msg, MessageId)],\n) -\u003e Result\u003c(MessageLog, Option\u003cMessageId\u003e), Error\u003e {\n    let client = reqwest::Client::new();\n    let body = bincode::serialize(\u0026(last_durably_received_offset, msgs))?;\n    let mut req = client.post(url).body(body);\n    for (k, v) in request_headers.iter() {\n        req = req.header(k, v);\n    }\n    let resp = req.send().await?;\n    let resp = resp_or_err(resp).await?;\n    Ok(bincode::deserialize(\u0026resp.bytes().await?)?)\n}\n\nasync fn resp_or_err(resp: Response) -\u003e Result\u003cResponse, Error\u003e {\n    if resp.status().is_success() {\n        Ok(resp)\n    } else {\n        let e = resp.text().await?;\n        let e = match serde_json::from_str::\u003cErrorJson\u003e(\u0026e) {\n            Ok(ErrorJson { error, args }) =\u003e format!(\"{error}: {args}\"),\n            Err(_) =\u003e e,\n        };\n        Err(Error::ServerError(e))\n    }\n}\n\n#[derive(Deserialize)]\nstruct ErrorJson {\n    error: String,\n    args: String,\n}\n\n/// Errors occurring during the validation or the execution of the MPC protocol.\n#[derive(Debug)]\npub enum Error {\n    /// An error occurred on the server side.\n    ServerError(String),\n    /// An error occurred while trying to send a request to the server.\n    ReqwestError(reqwest::Error),\n    /// The provided JSON is not a valid Garble literal.\n    JsonError(String),\n    /// The provided URL is invalid.\n    ParseError(url::ParseError),\n    /// The MPC program or the input is invalid.\n    ValidationError(ValidationError),\n    /// An error occurred during the client's execution of the MPC protocol.\n    mpc_coreError(mpc_core::Error),\n    /// A message could not be serialized/deserialized.\n    BincodeError,\n    /// The client's message id did not match the server's message id.\n    MessageOffsetMismatch,\n}\n\nimpl From\u003cbincode::Error\u003e for Error {\n    fn from(_: bincode::Error) -\u003e Self {\n        Self::BincodeError\n    }\n}\n\nimpl From\u003creqwest::Error\u003e for Error {\n    fn from(e: reqwest::Error) -\u003e Self {\n        Self::ReqwestError(e)\n    }\n}\n\nimpl From\u003curl::ParseError\u003e for Error {\n    fn from(e: url::ParseError) -\u003e Self {\n        Self::ParseError(e)\n    }\n}\n\nimpl From\u003cValidationError\u003e for Error {\n    fn from(e: ValidationError) -\u003e Self {\n        Self::ValidationError(e)\n    }\n}\n\nimpl From\u003cmpc_core::Error\u003e for Error {\n    fn from(e: mpc_core::Error) -\u003e Self {\n        Self::mpc_coreError(e)\n    }\n}\n\nimpl std::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Error::ValidationError(e) =\u003e write!(f, \"The MPC program or the input is invalid: {e}\"),\n            Error::ServerError(e) =\u003e write!(f, \"An error occurred on the server side: {e}\"),\n            Error::ReqwestError(e) =\u003e write!(\n                f,\n                \"An error occurred while trying to send a request to the server: {e}\"\n            ),\n            Error::JsonError(e) =\u003e {\n                write!(f, \"The provided JSON is not a valid Garble literal: {e}\")\n            }\n            Error::ParseError(e) =\u003e write!(f, \"The provided URL is invalid: {e}\"),\n            Error::mpc_coreError(e) =\u003e write!(\n                f,\n                \"An error occurred during the client's execution of the MPC protocol: {e}\"\n            ),\n            Error::BincodeError =\u003e write!(f, \"A message could not be serialized/deserialized.\"),\n            Error::MessageOffsetMismatch =\u003e write!(\n                f,\n                \"The client's message id did not match the server's message id.\"\n            ),\n        }\n    }\n}\n\nimpl std::error::Error for Error {}\n\n#[cfg(target_arch = \"wasm32\")]\nimpl From\u003cError\u003e for JsValue {\n    fn from(e: Error) -\u003e Self {\n        JsValue::from_str(\u0026format!(\"{e}\"))\n    }\n}\n\n/// An error that occurred during validation, before the MPC execution.\n#[derive(Debug, PartialEq, Eq)]\npub enum ValidationError {\n    /// The input does not match the circuit's expected input.\n    InvalidInput,\n    /// An error was found while scanning, parsing or type-checking the program.\n    GarbleCompileTimeError(String),\n    /// The Garble program has more or fewer than two parameters and thus is not a 2-Party program.\n    GarbleProgramIsNoTwoPartyFunction,\n}\n\nimpl fmt::Display for ValidationError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            InvalidInput =\u003e write!(f, \"The input does not match the circuit's expected input.\"),\n            GarbleCompileTimeError(e) =\u003e write!(f, \"Garble compile time error: {e}\"),\n            GarbleProgramIsNoTwoPartyFunction =\u003e write!(\n                f,\n                \"The Garble program has more or fewer than two parameters and thus is not a 2-Party program.\"\n            ),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","src","main.rs"],"content":"#![cfg(not(target_arch = \"wasm32\"))]\n\nuse anyhow::Context;\nuse clap::Parser;\nuse std::{io::Read, path::PathBuf};\nuse mpc_http_client::{compute, MpcData, MpcProgram};\n\n#[derive(Parser, Debug)]\n#[clap(author, version, about, long_about = None)]\nstruct Cli {\n    #[arg(value_parser, help = \"Path to a Garble program file\")]\n    program: PathBuf,\n\n    #[arg(\n        long,\n        required(true),\n        help = \"Name of the Garble function to be executed\"\n    )]\n    function: String,\n\n    #[arg(\n        long,\n        default_value = \"https://echo-server.sine.dev\",\n        help = \"Base URL of a remote mpc http server. \"\n    )]\n    url: url::Url,\n\n    #[arg(\n        long,\n        required(true),\n        help = \"Garble input literal for this (local) party\"\n    )]\n    input: String,\n\n    #[arg(\n        long,\n        required(true),\n        help = \"Metadata to send to the server (as plaintext) to influence the server's input\"\n    )]\n    metadata: String,\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let cli = Cli::parse();\n\n    let path = \u0026cli.program;\n\n    let mut source_code = String::new();\n    std::fs::File::open(path)\n        .with_context(|| format!(\"Could not open file `{}`\", path.display()))?\n        .read_to_string(\u0026mut source_code)\n        .with_context(|| format!(\"Could not read file `{}`\", path.display()))?;\n\n    let program = MpcProgram::new(source_code, cli.function)\n        .with_context(|| \"Not a valid 2-Party Garble program\".to_string())?;\n    let input = MpcData::from_string(\u0026program, cli.input)\n        .with_context(|| \"Not a valid Garble input\".to_string())?;\n\n    let result = compute(cli.url.to_string(), cli.metadata, program, input).await?;\n    println!(\"{}\", result.to_literal_string());\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","src","msg_queue.rs"],"content":"use std::collections::{vec_deque, VecDeque};\n\npub(crate) type MessageId = u32;\n\n#[derive(Clone)]\npub(crate) struct MsgQueue {\n    send_q: VecDeque\u003cVec\u003cu8\u003e\u003e,\n    msg_counter: usize,\n}\n\nimpl MsgQueue {\n    pub(crate) fn new() -\u003e Self {\n        Self {\n            send_q: VecDeque::with_capacity(100),\n            msg_counter: 0,\n        }\n    }\n\n    // flushes the queue until excluding {last_durably_received_offset}.\n    //\n    // after this operation, the logical message id of each queued message will be **strictly bigger than** the given offset\n    pub(crate) fn flush_queue(\u0026mut self, last_durably_received_offset: MessageId) -\u003e usize {\n        let last_durably_received_offset = last_durably_received_offset as usize;\n\n        let first_offset = self.msg_counter - self.send_q.len();\n        let mut offset = first_offset;\n\n        while offset \u003c= last_durably_received_offset \u0026\u0026 !self.send_q.is_empty() {\n            self.send_q.pop_front();\n            offset += 1;\n        }\n\n        // return how many elements were removed\n        offset - first_offset\n    }\n\n    pub(crate) fn send(\u0026mut self, msg: Vec\u003cu8\u003e) {\n        self.msg_counter += 1;\n        self.send_q.push_back(msg);\n    }\n}\n\npub struct MsgIter\u003c'a\u003e(vec_deque::Iter\u003c'a, Vec\u003cu8\u003e\u003e, MessageId);\n\nimpl\u003c'a\u003e Iterator for MsgIter\u003c'a\u003e {\n    type Item = (\u0026'a Vec\u003cu8\u003e, MessageId);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.0.next().map(|msg| {\n            self.1 += 1;\n            (msg, self.1 - 1)\n        })\n    }\n}\n\nimpl MsgQueue {\n    pub fn msgs_iter(\u0026self) -\u003e MsgIter\u003c'_\u003e {\n        let message_id = self.msg_counter - self.send_q.len();\n        MsgIter(self.send_q.iter(), message_id as MessageId)\n    }\n}\n\n#[test]\nfn test_flush_queue() {\n    let c = MsgQueue {\n        send_q: Default::default(),\n        msg_counter: Default::default(),\n    };\n\n    {\n        assert_eq!(0, c.clone().flush_queue(0));\n        assert_eq!(0, c.clone().flush_queue(1));\n        assert_eq!(0, c.clone().flush_queue(10));\n    }\n    {\n        let mut c = c;\n\n        c.send(bincode::serialize(\u0026vec![(0, false)]).unwrap());\n        assert_eq!(1, c.clone().flush_queue(0));\n\n        c.flush_queue(0);\n        assert_eq!(None, c.send_q.pop_front());\n\n        c.send(bincode::serialize(\u0026vec![(1, false)]).unwrap());\n        assert_eq!(0, c.clone().flush_queue(0));\n        assert_eq!(1, c.clone().flush_queue(1));\n        assert_eq!(\n            Some(bincode::serialize(\u0026vec![(1, false)]).unwrap()),\n            c.send_q.pop_front()\n        );\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","tests","cli.rs"],"content":"#![cfg(not(target_arch = \"wasm32\"))]\n\nuse assert_cmd::prelude::*; // Add methods on commands\nuse predicates::prelude::*; // Used for writing assertions\nuse rand::{prelude::*, random, thread_rng};\nuse std::process::{Child, Command, Stdio}; // Run programs\n\nconst CRATE_NAME: \u0026str = \"mpc_http_client\";\nconst SERVER_CRATE: \u0026str = \"mpc_http_server\";\nconst SERVER_URL: \u0026str = \"http://localhost:8000\";\n\n#[test]\nfn file_doesnt_exist() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    new_command(SERVER_URL, \"foobar\", \"main\", \"\", \"\")?\n        .assert()\n        .failure()\n        .stderr(predicate::str::contains(\"Could not open file\"));\n\n    Ok(())\n}\n\n#[test]\nfn invalid_url() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let url = \"localhost\";\n    new_command(url, \"foobar\", \"main\", \"\", \"\")?\n        .assert()\n        .failure()\n        .stderr(predicate::str::contains(format!(\n            \"invalid value \\'{url}\\' for '--url \u003cURL\u003e'\"\n        )));\n\n    Ok(())\n}\n\n#[test]\nfn test_too_many_parties() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    new_command(SERVER_URL, \"tests/.manyparties.garble.rs\", \"main\", \"\", \"\")?\n        .assert()\n        .failure()\n        .stderr(predicate::str::contains(\"not a 2-Party function\"));\n\n    Ok(())\n}\n\n#[test]\nfn integration_test_and() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    with_server(|connection_string| {\n        for _ in 0..3 {\n            let party_a: u8 = random();\n            let party_b: u8 = random();\n\n            let mut cmd = new_command(\n                connection_string,\n                \"tests/.add.garble.rs\",\n                \"main\",\n                \u0026format!(\"{party_a}u8\"),\n                \u0026format!(\"{party_b}u8\"),\n            )?;\n\n            if party_a as u16 + party_b as u16 \u003e u8::MAX as u16 {\n                cmd.assert()\n                    .failure()\n                    .stderr(predicate::str::contains(\"Panic due to Overflow\"));\n            } else {\n                cmd.assert()\n                    .success()\n                    .stdout(predicate::str::contains(format!(\"{}\", party_a + party_b)));\n            }\n        }\n\n        Ok(())\n    })\n}\n\n#[test]\nfn integration_test_div_by_zero() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    with_server(|url| {\n        let party_b: u8 = random();\n\n        let mut cmd = new_command(\n            url,\n            \"tests/.div.garble.rs\",\n            \"main\",\n            \"0u8\",\n            \u0026format!(\"{party_b}u8\"),\n        )?;\n\n        cmd.assert().failure().stderr(predicate::str::contains(\n            \"Panic due to Division By Zero on line 2:5\",\n        ));\n\n        Ok(())\n    })\n}\n\nfn new_command(\n    url: \u0026str,\n    program: \u0026str,\n    function: \u0026str,\n    input: \u0026str,\n    metadata: \u0026str,\n) -\u003e Result\u003cCommand, Box\u003cdyn std::error::Error\u003e\u003e {\n    let mut cmd = Command::cargo_bin(CRATE_NAME)?;\n    cmd.arg(program)\n        .args([\"--function\", function, \"--url\", url])\n        .arg(\"--input\")\n        .arg(input)\n        .arg(\"--metadata\")\n        .arg(metadata);\n\n    Ok(cmd)\n}\n\nfn start_server() -\u003e Result\u003c(Child, String), Box\u003cdyn std::error::Error\u003e\u003e {\n    if cfg!(not(tarpaulin)) {\n        println!(\"Compiling mpc_http_server, this might take a few minutes\");\n        Command::new(\"cargo\")\n            .arg(\"build\")\n            .arg(\"--features=bin\")\n            .stdout(Stdio::inherit())\n            .stderr(Stdio::inherit())\n            .output()\n            .unwrap();\n        println!(\"Compilation finished\");\n    }\n    let port: u16 = thread_rng().gen_range(8001..=9000);\n    let port_str = port.to_string();\n    let mut cmd = Command::cargo_bin(SERVER_CRATE)?;\n    let mut proc = cmd\n        .env(\"ROCKET_PORT\", port_str)\n        .env(\"ROCKET_LOG_LEVEL\", \"off\")\n        .spawn()?;\n\n    let connection_string = format!(\"127.0.0.1:{port}\");\n    for _ in 0..50 {\n        if std::net::TcpStream::connect(\u0026connection_string).is_ok() {\n            return Ok((proc, format!(\"http://127.0.0.1:{port}\")));\n        }\n        std::thread::sleep(std::time::Duration::from_millis(20));\n    }\n\n    let _ = proc.kill();\n    Err(StartTimeoutError {}.into())\n}\n\nfn stop_server(mut c: Child) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    c.kill()?;\n    c.wait()?;\n    Ok(())\n}\n\nfn with_server\u003cF\u003e(test: F) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e\nwhere\n    F: FnOnce(\u0026String) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e,\n{\n    let (server, connection_string) = start_server()?;\n    let res = test(\u0026connection_string);\n    let stop = stop_server(server);\n    stop.and(res)\n}\n\n#[derive(Debug)]\nstruct StartTimeoutError {}\nimpl std::fmt::Display for StartTimeoutError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.write_str(\"Timeout while strating mpc_http_server\")\n    }\n}\n\nimpl std::error::Error for StartTimeoutError {}\n","traces":[{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","tests","credit_scoring.rs"],"content":"#![cfg(target_arch = \"wasm32\")]\n\nuse mpc_http_client::{compute, MpcData, MpcProgram};\nuse wasm_bindgen_test::wasm_bindgen_test;\n\n#[cfg(target_arch = \"wasm32\")]\nwasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);\n\n#[wasm_bindgen_test]\nasync fn test() {\n    console_log::init().expect(\"Could not init console_log\");\n    let url = \"http://127.0.0.1:8000\".to_string();\n\n    let metadata = \"scoring_algorithm1\".to_string();\n\n    let credit_scoring_prg = include_str!(\"credit_scoring_setup/program.garble.rs\").to_string();\n    let function = \"compute_score\".to_string();\n    let program =\n        MpcProgram::new(credit_scoring_prg, function).expect(\"Could not parse source code\");\n\n    let my_input =\n        MpcData::from_string(\u0026program, \"User {age: 37u8, income: 5500u32, account_balance: 25000i64, current_loans: 60000u64, credit_card_limit: 1000u32, ever_bankrupt: false, loan_payment_failures: 0u8, credit_payment_failures: 2u8, surety_income: 5000u32}\".to_string()).unwrap_or_else(|e| panic!(\"{e}\"));\n\n    let score = compute(url, metadata, program, my_input)\n        .await\n        .unwrap_or_else(|e| panic!(\"{e}\"));\n\n    assert_eq!(score.to_literal_string(), \"Score::Good(85u8)\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","tests","credit_scoring_setup","program.garble.rs"],"content":"pub fn compute_score(scoring_algorithm: ScoringAlgorithm, user: User) -\u003e Score {\n  let User {\n      age,\n      income,\n      account_balance,\n      current_loans,\n      credit_card_limit,\n      ever_bankrupt,\n      loan_payment_failures,\n      credit_payment_failures,\n      surety_income,\n  } = user;\n  let ScoringAlgorithm {\n      age_score,\n      income_score,\n      account_balance_score,\n      current_loans_score,\n      credit_card_score,\n      bankruptcy_score,\n      loan_payment_history_score,\n      credit_payment_history_score,\n      surety_income_score,\n      score_limits,\n  } = scoring_algorithm;\n\n  let age_points = compute_age_points(age, age_score);\n\n  let income_points = compute_income_points(income, income_score);\n\n  let account_balance_points =\n      compute_account_balance_points(account_balance, account_balance_score);\n\n  let current_loans_points = compute_current_loans_points(current_loans, current_loans_score);\n\n  let credit_card_points = compute_credit_card_points(credit_card_limit, credit_card_score);\n\n  let bankruptcy_points = compute_bankruptcy_points(ever_bankrupt, bankruptcy_score);\n\n  let loan_payment_history_points =\n      compute_loan_payment_history_points(loan_payment_failures, loan_payment_history_score);\n\n  let credit_payment_history_points = compute_credit_payment_history_points(\n      credit_payment_failures,\n      credit_payment_history_score,\n  );\n\n  let surety_income_points = compute_surety_income_points(surety_income, surety_income_score);\n\n  let total_points = age_points\n      + income_points\n      + account_balance_points\n      + current_loans_points\n      + credit_card_points\n      + bankruptcy_points\n      + loan_payment_history_points\n      + credit_payment_history_points\n      + surety_income_points;\n\n  compute_final_score(total_points, score_limits);\n}\n\nfn compute_age_points(age: u8, age_score: [MatchClause; 4]) -\u003e i32 {\n  let mut age_points = 0i32;\n  for clause in age_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n              if age as i64 \u003e= min \u0026\u0026 (age as i64) \u003c max {\n                  age_points = age_points + inc\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  age_points\n}\n\nfn compute_income_points(income: u32, income_score: [MatchClause; 4]) -\u003e i32 {\n  let mut income_points = 0i32;\n  for clause in income_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n              if income as i64 \u003e= min \u0026\u0026 (income as i64) \u003c max {\n                  income_points = income_points + inc\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  income_points\n}\n\nfn compute_account_balance_points(\n  account_balance: i64,\n  account_balance_score: [MatchClause; 4],\n) -\u003e i32 {\n  let mut account_balance_points = 0i32;\n  for clause in account_balance_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n              if account_balance \u003e= min \u0026\u0026 account_balance \u003c max {\n                  account_balance_points = account_balance_points + inc\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  account_balance_points\n}\n\nfn compute_current_loans_points(current_loans: u64, current_loans_score: [MatchClause; 4]) -\u003e i32 {\n  let mut current_loans_points = 0i32;\n  for clause in current_loans_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n              if current_loans as i64 \u003e= min \u0026\u0026 (current_loans as i64) \u003c max {\n                  current_loans_points = current_loans_points + inc\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  current_loans_points\n}\n\nfn compute_credit_card_points(credit_card_limit: u32, credit_card_score: [MatchClause; 4]) -\u003e i32 {\n  let mut credit_card_points = 0i32;\n  for clause in credit_card_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n              if credit_card_limit as i64 \u003e= min \u0026\u0026 (credit_card_limit as i64) \u003c max {\n                  credit_card_points = credit_card_points + inc;\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  credit_card_points\n}\n\nfn compute_bankruptcy_points(ever_bankrupt: bool, bankruptcy_score: [MatchClause; 2]) -\u003e i32 {\n  let mut bankruptcy_points = 0i32;\n  for clause in bankruptcy_score {\n      match clause {\n          MatchClause::Bool(boolean, points) =\u003e {\n              let Points { inc } = points;\n              if ever_bankrupt == boolean {\n                  bankruptcy_points = bankruptcy_points + inc;\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  bankruptcy_points\n}\n\nfn compute_loan_payment_history_points(\n  loan_payment_failures: u8,\n  loan_payment_history_score: [MatchClause; 4],\n) -\u003e i32 {\n  let mut loan_payment_history_points = 0i32;\n\n  for clause in loan_payment_history_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n\n              if loan_payment_failures as i64 \u003e= min \u0026\u0026 (loan_payment_failures as i64) \u003c max {\n                  loan_payment_history_points = loan_payment_history_points + inc\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  loan_payment_history_points\n}\n\nfn compute_credit_payment_history_points(\n  credit_payment_failures: u8,\n  credit_payment_history_score: [MatchClause; 4],\n) -\u003e i32 {\n  let mut credit_payment_history_points = 0i32;\n  for clause in credit_payment_history_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n\n              if credit_payment_failures as i64 \u003e= min \u0026\u0026 (credit_payment_failures as i64) \u003c max {\n                  credit_payment_history_points = credit_payment_history_points + inc\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  credit_payment_history_points\n}\n\nfn compute_surety_income_points(surety_income: u32, surety_income_score: [MatchClause; 4]) -\u003e i32 {\n  let mut surety_income_points = 0i32;\n\n  for clause in surety_income_score {\n      match clause {\n          MatchClause::Range(range, points) =\u003e {\n              let Range { min, max } = range;\n              let Points { inc } = points;\n\n              if surety_income as i64 \u003e= min \u0026\u0026 (surety_income as i64) \u003c max {\n                  surety_income_points = surety_income_points + inc\n              }\n          }\n          _ =\u003e {}\n      }\n  }\n  surety_income_points\n}\n\nfn compute_final_score(total_points: i32, score_limits: ScoreLimits) -\u003e Score {\n  if total_points \u003c= score_limits.min {\n      Score::Bad(0u8)\n  } else if total_points \u003e= score_limits.max {\n      Score::Good(100u8)\n  } else {\n      let score = (total_points * 100i32) / score_limits.max;\n      if score \u003c 50i32 {\n          Score::Bad(score as u8)\n      } else {\n          Score::Good(score as u8)\n      }\n  }\n}\n\nstruct User {\n  age: u8,\n  income: u32,\n  account_balance: i64,\n  current_loans: u64,\n  credit_card_limit: u32,\n  ever_bankrupt: bool,\n  loan_payment_failures: u8,\n  credit_payment_failures: u8,\n  surety_income: u32,\n}\n\nstruct ScoringAlgorithm {\n  age_score: [MatchClause; 4],\n  income_score: [MatchClause; 4],\n  account_balance_score: [MatchClause; 4],\n  current_loans_score: [MatchClause; 4],\n  credit_card_score: [MatchClause; 4],\n  bankruptcy_score: [MatchClause; 2],\n  loan_payment_history_score: [MatchClause; 4],\n  credit_payment_history_score: [MatchClause; 4],\n  surety_income_score: [MatchClause; 4],\n  score_limits: ScoreLimits,\n}\n\nenum MatchClause {\n  Range(Range, Points),\n  Bool(bool, Points),\n  None,\n}\n\nstruct Range {\n  min: i64,\n  max: i64,\n}\n\nstruct Points {\n  inc: i32,\n}\n\nstruct ScoreLimits {\n  min: i32,\n  max: i32,\n}\n\nenum Score {\n  Good(u8),\n  Bad(u8),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","tests","echo_server.rs"],"content":"#![cfg(target_arch = \"wasm32\")]\n\nuse mpc_http_client::{compute, MpcData, MpcProgram};\nuse wasm_bindgen_test::wasm_bindgen_test;\n\n#[cfg(target_arch = \"wasm32\")]\nwasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);\n\n#[wasm_bindgen_test]\nasync fn test() {\n    console_log::init().expect(\"Could not init console_log\");\n    let url = \"http://127.0.0.1:8000\";\n    let source_code = \"pub fn main(a: i32, b: u16) -\u003e i32 { a + (b as i32) }\".to_string();\n    let function = \"main\".to_string();\n    let program = MpcProgram::new(source_code, function).expect(\"Could not parse source code\");\n    let remote_input = \"2i32\";\n    let my_input =\n        MpcData::from_string(\u0026program, \"2u16\".to_string()).expect(\"Could not parse input\");\n    let output = compute(url.to_string(), remote_input.to_string(), program, my_input).await;\n    match output {\n        Ok(output) =\u003e assert_eq!(output.to_literal_string(), \"4\"),\n        Err(e) =\u003e panic!(\"{e:?}\"),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","tests","smart_cookie.rs"],"content":"#![cfg(target_arch = \"wasm32\")]\n\nuse std::include_str;\n\nuse js_sys::Reflect;\nuse mpc_http_client::{compute, MpcData, MpcProgram};\nuse wasm_bindgen::JsValue;\nuse wasm_bindgen_test::wasm_bindgen_test;\n\n#[cfg(target_arch = \"wasm32\")]\nwasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);\n\n#[wasm_bindgen_test]\nasync fn test_valid_signature() {\n    console_log::init().expect(\"Could not init console_log\");\n    let url = \"http://127.0.0.1:8000\";\n\n    let smart_cookie_prg = include_str!(\"smart_cookie_setup/program.garble.rs\");\n\n    let function = \"init\".to_string();\n    let program = MpcProgram::new(smart_cookie_prg.to_string(), function)\n        .expect(\"Could not parse source code\");\n    let metadata = \"_\";\n    let my_input =\n        MpcData::from_string(\u0026program, \"()\".to_string()).unwrap_or_else(|e| panic!(\"{e}\"));\n    let mut user_state = compute(url.to_string(), metadata.to_string(), program, my_input)\n        .await\n        .unwrap_or_else(|e| panic!(\"{e}\"));\n\n    let function = \"log_interest\".to_string();\n    let program = MpcProgram::new(smart_cookie_prg.to_string(), function)\n        .expect(\"Could not parse source code\");\n    let metadata = \"article4\";\n    let log_result = compute(\n        url.to_string(),\n        metadata.to_string(),\n        program.clone(),\n        user_state,\n    )\n    .await\n    .unwrap_or_else(|e| panic!(\"{e}\"))\n    .to_literal()\n    .unwrap_or_else(|e| panic!(\"{e}\"));\n    let log_result = Reflect::get(\u0026log_result, \u0026\"Enum\".into()).unwrap_or_else(|e| panic!(\"{e:?}\"));\n    let log_result_enum_name = Reflect::get_u32(\u0026log_result, 0).unwrap_or_else(|e| panic!(\"{e:?}\"));\n    assert_eq!(log_result_enum_name, JsValue::from(\"LogResult\"));\n    let log_result_enum_variant =\n        Reflect::get_u32(\u0026log_result, 1).unwrap_or_else(|e| panic!(\"{e:?}\"));\n    assert_eq!(log_result_enum_variant, JsValue::from(\"Ok\"));\n    let log_result = Reflect::get_u32(\u0026log_result, 2).unwrap_or_else(|e| panic!(\"{e:?}\"));\n    let log_result = Reflect::get(\u0026log_result, \u0026\"Tuple\".into()).unwrap_or_else(|e| panic!(\"{e:?}\"));\n    let log_result = Reflect::get_u32(\u0026log_result, 0).unwrap_or_else(|e| panic!(\"{e:?}\"));\n    user_state = MpcData::from_object(\u0026program, log_result).unwrap_or_else(|e| panic!(\"{e}\"));\n\n    let function = \"decide_ad\".to_string();\n    let program = MpcProgram::new(smart_cookie_prg.to_string(), function)\n        .expect(\"Could not parse source code\");\n    let metadata = \"_\";\n    let ad_decision = compute(url.to_string(), metadata.to_string(), program, user_state)\n        .await\n        .unwrap_or_else(|e| panic!(\"{e}\"));\n    assert!(ad_decision.to_literal_string().contains(\"Sports\"));\n}\n\n#[wasm_bindgen_test]\nasync fn test_invalid_signature() {\n    let url = \"http://127.0.0.1:8000\";\n\n    let smart_cookie_prg = include_str!(\"smart_cookie_setup/program.garble.rs\");\n\n    let function = \"init\".to_string();\n    let program = MpcProgram::new(smart_cookie_prg.to_string(), function)\n        .expect(\"Could not parse source code\");\n    let metadata = \"_\";\n    let my_input =\n        MpcData::from_string(\u0026program, \"()\".to_string()).unwrap_or_else(|e| panic!(\"{e}\"));\n    let user_state = compute(url.to_string(), metadata.to_string(), program, my_input)\n        .await\n        .unwrap_or_else(|e| panic!(\"{e}\"));\n\n    let function = \"log_interest\".to_string();\n    let program = MpcProgram::new(smart_cookie_prg.to_string(), function)\n        .expect(\"Could not parse source code\");\n    let metadata = \"article5\";\n    let log_result = compute(\n        url.to_string(),\n        metadata.to_string(),\n        program.clone(),\n        user_state,\n    )\n    .await\n    .unwrap_or_else(|e| panic!(\"{e}\"))\n    .to_literal()\n    .unwrap_or_else(|e| panic!(\"{e}\"));\n    let log_result = Reflect::get(\u0026log_result, \u0026\"Enum\".into()).unwrap_or_else(|e| panic!(\"{e:?}\"));\n    let log_result_enum_name = Reflect::get_u32(\u0026log_result, 0).unwrap_or_else(|e| panic!(\"{e:?}\"));\n    assert_eq!(log_result_enum_name, JsValue::from(\"LogResult\"));\n    let log_result_enum_variant =\n        Reflect::get_u32(\u0026log_result, 1).unwrap_or_else(|e| panic!(\"{e:?}\"));\n    assert_eq!(log_result_enum_variant, JsValue::from(\"InvalidSignature\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_client","tests","smart_cookie_setup","program.garble.rs"],"content":"pub fn init(website_key: SigningKey, state: ()) -\u003e UserState {\n    let logged_interest_counter = 0u8;\n    let interests = [UserInterest::None; 16];\n    let signed = sign(interests, website_key);\n    UserState {\n        signature: signed,\n        interests: interests,\n    }\n}\n\npub fn log_interest(website_visit: WebsiteVisit, state: UserState) -\u003e LogResult {\n    if is_signature_ok(state, website_visit.key) {\n        let interests = state.interests;\n        let user_interest = website_visit.interest;\n        let mut updated_interests = [UserInterest::None; 16];\n        updated_interests[0] = user_interest;\n        for i in 1usize..16usize {\n            updated_interests[i] = interests[i - 1usize];\n        }\n        let updated_signature = sign(updated_interests, website_visit.key);\n        let updated_state = UserState {\n            signature: updated_signature,\n            interests: updated_interests,\n        };\n        LogResult::Ok(updated_state)\n    } else {\n        LogResult::InvalidSignature\n    }\n}\n\npub fn decide_ad(website_key: SigningKey, state: UserState) -\u003e AdDecisionResult {\n    if is_signature_ok(state, website_key) {\n        let mut sums = [0u8; 6]; // for the 6 user interests\n        let interests = state.interests;\n        for interest in interests {\n            match interest {\n                UserInterest::None =\u003e {}\n                UserInterest::Luxury =\u003e sums[1] = sums[1] + 1u8,\n                UserInterest::Cars =\u003e sums[2] = sums[2] + 1u8,\n                UserInterest::Politics =\u003e sums[3] = sums[3] + 1u8,\n                UserInterest::Sports =\u003e sums[4] = sums[4] + 1u8,\n                UserInterest::Arts =\u003e sums[5] = sums[5] + 1u8,\n            }\n        }\n        let mut max_visits = 0u8;\n        let mut index_of_max_visited = 0usize;\n        for i in 0usize..6usize {\n            if sums[i] \u003e max_visits {\n                max_visits = sums[i];\n                index_of_max_visited = i;\n            }\n        }\n        let interest = match index_of_max_visited {\n            0u8 =\u003e UserInterest::None,\n            1u8 =\u003e UserInterest::Luxury,\n            2u8 =\u003e UserInterest::Cars,\n            3u8 =\u003e UserInterest::Politics,\n            4u8 =\u003e UserInterest::Sports,\n            5u8 =\u003e UserInterest::Arts,\n            _ =\u003e UserInterest::None,\n        };\n        AdDecisionResult::Ok(interest)\n    } else {\n        AdDecisionResult::InvalidSignature\n    }\n}\n\nstruct UserState {\n    signature: [u8; 16],\n    interests: [UserInterest; 16],\n}\n\nstruct WebsiteVisit {\n    interest: UserInterest,\n    key: SigningKey,\n}\n\nenum UserInterest {\n    None,\n    Luxury,\n    Cars,\n    Politics,\n    Sports,\n    Arts,\n}\n\nstruct SigningKey {\n    key: [u8; 16],\n}\n\nenum LogResult {\n    InvalidSignature,\n    Ok(UserState),\n}\n\nenum AdDecisionResult {\n    InvalidSignature,\n    Ok(UserInterest),\n}\n\nstruct MaxInterest {\n    index_of_variant: usize,\n    visits: u8,\n}\n\nfn interest_as_u8(interest: UserInterest) -\u003e u8 {\n    match interest {\n        UserInterest::None =\u003e 0u8,\n        UserInterest::Luxury =\u003e 1u8,\n        UserInterest::Cars =\u003e 2u8,\n        UserInterest::Politics =\u003e 3u8,\n        UserInterest::Sports =\u003e 4u8,\n        UserInterest::Arts =\u003e 5u8,\n        UserInterest::None =\u003e 6u8,\n    }\n}\n\nfn is_signature_ok(state: UserState, website_key: SigningKey) -\u003e bool {\n    state.signature == sign(state.interests, website_key);\n}\n\nfn sign(interests: [UserInterest; 16], website_key: SigningKey) -\u003e [u8; 16] {\n    let mut bytes = [0u8; 16];\n    for i in 0usize..16usize {\n        bytes[i] = interest_as_u8(interests[i]);\n    }\n    let st = absorb(bytes);\n    let st = absorb_cont(st, website_key.key);\n    let hash = squeeze(st);\n    hash\n}\n\nfn absorb(bin: [u8; 16]) -\u003e [u8; 48] {\n    let st = [0u8; 48];\n    down(st, bin, 1u8)\n}\n\nfn absorb_cont(st: [u8; 48], bin: [u8; 16]) -\u003e [u8; 48] {\n    let st1 = u8_to_u32_arr(st);\n    let st2 = permute(st1);\n    let st3 = u32_to_u8_arr(st2);\n    down(st3, bin, 0u8)\n}\n\nfn down(mut st: [u8; 48], bin: [u8; 16], cd: u8) -\u003e [u8; 48] {\n    st = add_bytes(st, bin);\n    st = add_byte(st, 1u8, 16usize);\n    st = add_byte(st, cd, 47usize);\n    st\n}\n\nfn swap(st: [u32; 12], a: usize, b: usize) -\u003e [u32; 12] {\n    let mut st_updated = st;\n    st_updated[a] = st[b];\n    st_updated[b] = st[a];\n    st_updated\n}\n\nfn round(mut st: [u32; 12], round_key: u32) -\u003e [u32; 12] {\n    let mut e = [0u32; 4];\n    for i in 0usize..4usize {\n        e[i] = rotate_right(st[i] ^ st[i + 4usize] ^ st[i + 8usize], 18u8);\n        e[i] = e[i] ^ rotate_right(e[i], 9u8);\n    }\n\n    for i in 0usize..12usize {\n        st[i] = st[i] ^ e[(i + 3usize) % 4usize]\n    }\n\n    st = swap(st, 7usize, 4usize);\n    st = swap(st, 7usize, 5usize);\n    st = swap(st, 7usize, 6usize);\n    st[0] = st[0] ^ round_key;\n\n    for i in 0usize..4usize {\n        let a = st[i];\n        let b = st[i + 4usize];\n        let c = rotate_right(st[i + 8usize], 21u8);\n        st[i + 8usize] = rotate_right((b \u0026 !a) ^ c, 24u8);\n        st[i + 4usize] = rotate_right((a \u0026 !c) ^ b, 31u8);\n        st[i] = st[i] ^ (c \u0026 !b);\n    }\n\n    st = swap(st, 8usize, 10usize);\n    st = swap(st, 9usize, 11usize);\n    st\n}\n\nfn permute(mut st: [u32; 12]) -\u003e [u32; 12] {\n    let ROUND_KEYS = [\n        88u32, 56u32, 960u32, 208u32, 288u32, 20u32, 96u32, 44u32, 896u32, 240u32, 416u32, 18u32,\n    ];\n\n    for i in 0usize..12usize {\n        st = round(st, ROUND_KEYS[i])\n    }\n    st\n}\n\nfn squeeze(st: [u8; 48]) -\u003e [u8; 16] {\n    let mut st = u8_to_u32_arr(st);\n    st = permute(st);\n    [\n        st[0] as u8,\n        (st[0] \u003e\u003e 8u8) as u8,\n        (st[0] \u003e\u003e 16u8) as u8,\n        (st[0] \u003e\u003e 24u8) as u8,\n        st[1] as u8,\n        (st[1] \u003e\u003e 8u8) as u8,\n        (st[1] \u003e\u003e 16u8) as u8,\n        (st[1] \u003e\u003e 24u8) as u8,\n        st[2] as u8,\n        (st[2] \u003e\u003e 8u8) as u8,\n        (st[2] \u003e\u003e 16u8) as u8,\n        (st[2] \u003e\u003e 24u8) as u8,\n        st[3] as u8,\n        (st[3] \u003e\u003e 8u8) as u8,\n        (st[3] \u003e\u003e 16u8) as u8,\n        (st[3] \u003e\u003e 24u8) as u8,\n    ]\n}\n\nfn rotate_right(val: u32, rotation: u8) -\u003e u32 {\n    (val \u003e\u003e rotation) ^ (val \u003c\u003c (32u8 - rotation))\n}\n\nfn u8_to_u32_arr(st: [u8; 48]) -\u003e [u32; 12] {\n    let mut arr = [0u32; 12];\n    for i in 0usize..12usize {\n        arr[i] = u8_to_u32(st, i * 4usize)\n    }\n    arr\n}\n\nfn u32_to_u8_arr(st: [u32; 12]) -\u003e [u8; 48] {\n    let mut arr = [0u8; 48];\n    for i in 0usize..12usize {\n        arr[i * 4usize] = st[0] as u8;\n        arr[i * 4usize + 1usize] = (st[0] \u003e\u003e 8u8) as u8;\n        arr[i * 4usize + 2usize] = (st[0] \u003e\u003e 16u8) as u8;\n        arr[i * 4usize + 3usize] = (st[0] \u003e\u003e 24u8) as u8;\n    }\n    arr\n}\n\nfn u8_to_u32(st: [u8; 48], base_idx: usize) -\u003e u32 {\n    st[base_idx] as u32\n        ^ ((st[base_idx + 1usize] as u32) \u003c\u003c 8u8)\n        ^ ((st[base_idx + 2usize] as u32) \u003c\u003c 16u8)\n        ^ ((st[base_idx + 3usize] as u32) \u003c\u003c 24u8)\n}\n\nfn add_byte(mut st: [u8; 48], byte: u8, offset: usize) -\u003e [u8; 48] {\n    st[offset] = st[offset] ^ byte;\n    st\n}\n\nfn add_bytes(mut st: [u8; 48], chunk: [u8; 16]) -\u003e [u8; 48] {\n    for i in 0usize..16usize {\n        st = add_byte(st, chunk[i], i);\n    }\n    st\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_server","src","engine.rs"],"content":"#![allow(clippy::let_unit_value)]\n\nuse crate::{\n    msg_queue::MessageId,\n    requests::NewSession,\n    responses::Error,\n    state::{EngineRef, EngineRegistry},\n    types::{EngineCreationResult, HandleMpcRequestFn},\n};\nuse rand::Rng;\nuse rand_chacha::{rand_core::SeedableRng, ChaCha20Rng};\nuse rocket::{\n    data::ToByteUnit,\n    fairing::{AdHoc, Fairing, Info, Kind},\n    http::Header,\n    response::{status::Created, stream::ByteStream},\n    serde::{json::Json, Deserialize},\n    Data, Request, Response, State,\n};\nuse std::{\n    collections::HashSet,\n    sync::{Arc, Mutex},\n};\nuse url::{Host, Url};\n\n#[options(\"/\")]\npub(crate) fn preflight_response_create_session() {}\n\n#[post(\"/\", format = \"application/json\", data = \"\u003crequest\u003e\")]\npub(crate) fn create_session(\n    r: \u0026State\u003cEngineRegistry\u003e,\n    request: Json\u003cNewSession\u003e,\n) -\u003e Result\u003cCreated\u003cJson\u003cEngineCreationResult\u003e\u003e, Error\u003e {\n    let server_version = env!(\"CARGO_PKG_VERSION\").to_string();\n    if request.client_version != server_version {\n        return Err(Error::IncompatibleVersions {\n            client_version: request.client_version.clone(),\n            server_version,\n        });\n    }\n    let invocation = crate::types::MpcRequest {\n        plaintext_metadata: request.plaintext_metadata.clone(),\n        program: request.program.clone(),\n        function: request.function.clone(),\n    };\n    let handled = r\n        .handle_input(invocation)\n        .map_err(Error::MpcRequestRejected)?;\n    let circuit_hash = handled.circuit.blake3_hash();\n    if circuit_hash != request.circuit_hash {\n        return Err(Error::CircuitHashMismatch);\n    }\n\n    let mut rng = ChaCha20Rng::from_entropy();\n    let engine_id = uuid::Builder::from_random_bytes(rng.gen()).into_uuid();\n    let engine_id = engine_id.to_string();\n    let er = Arc::new(Mutex::new(EngineRef::new(\n        rng,\n        handled.circuit,\n        handled.input_from_server,\n    )?));\n    let inserted = r.insert_engine(engine_id.clone(), er);\n\n    if !inserted {\n        return Err(Error::DuplicateEngineId { engine_id });\n    }\n\n    let body = EngineCreationResult {\n        engine_id: engine_id.clone(),\n        request_headers: handled.request_headers,\n        server_version,\n    };\n\n    let c = Created::new(uri!(dialog(engine_id)).to_string()).body(Json(body));\n    Ok(c)\n}\n\n#[options(\"/\u003c_engine_id\u003e\")]\npub(crate) fn preflight_response_delete_session(_engine_id: String) {}\n\n#[delete(\"/\u003cengine_id\u003e\")]\npub(crate) fn delete_session(engine_id: String, r: \u0026State\u003cEngineRegistry\u003e) -\u003e Result\u003c(), Error\u003e {\n    let removed = r.drop_engine(\u0026engine_id);\n    if removed {\n        Ok(())\n    } else {\n        Err(Error::NoSuchEngineId { engine_id })\n    }\n}\n\n#[post(\"/\u003cengine_id\u003e\", data = \"\u003cmessages\u003e\")]\npub(crate) async fn dialog(\n    engine_id: String,\n    messages: Data\u003c'_\u003e,\n    registry: \u0026State\u003cEngineRegistry\u003e,\n) -\u003e Result\u003cByteStream![Vec\u003cu8\u003e], Error\u003e {\n    let stream = messages.open(20.mebibytes());\n    let (last_durably_received_offset, messages): (Option\u003cu32\u003e, Vec\u003c(Vec\u003cu8\u003e, MessageId)\u003e) =\n        bincode::deserialize(\u0026stream.into_bytes().await.unwrap())?;\n\n    let engine = registry.lookup(\u0026engine_id)?;\n    let mut engine = engine.lock().unwrap();\n\n    if let Some(offset) = last_durably_received_offset {\n        engine.flush_queue(offset);\n    }\n    for (msg, offset) in messages {\n        engine.process_message(\u0026msg, offset)?;\n    }\n\n    let result = (\n        engine.dump_messages(),\n        engine.last_durably_received_client_event_offset(),\n    );\n\n    if engine.is_done() {\n        registry.drop_engine(\u0026engine_id);\n    }\n\n    let (msgs, message_id) = result;\n    let serialized = bincode::serialize(\u0026(msgs, message_id))?;\n    Ok(ByteStream! { yield serialized; })\n}\n\npub fn stage(handle_input: HandleMpcRequestFn) -\u003e AdHoc {\n    AdHoc::on_ignite(\"Engine Context\", |rocket| async {\n        rocket\n            .mount(\n                \"/\",\n                routes![\n                    preflight_response_create_session,\n                    preflight_response_delete_session,\n                    create_session,\n                    delete_session,\n                    dialog\n                ],\n            )\n            .manage(EngineRegistry::new(handle_input))\n    })\n}\n\npub(crate) struct Cors;\n\n#[rocket::async_trait]\nimpl Fairing for Cors {\n    fn info(\u0026self) -\u003e Info {\n        Info {\n            name: \"Add CORS headers to responses\",\n            kind: Kind::Response,\n        }\n    }\n\n    async fn on_response\u003c'r\u003e(\u0026self, request: \u0026'r Request\u003c'_\u003e, response: \u0026mut Response\u003c'r\u003e) {\n        #[derive(Debug, Deserialize)]\n        #[serde(crate = \"rocket::serde\")]\n        struct CorsConfig {\n            origins: HashSet\u003cString\u003e,\n        }\n\n        let config = request.rocket().figment().extract::\u003cCorsConfig\u003e();\n        if let Ok(config) = config {\n            let request_origin = request.headers().get_one(\"origin\");\n\n            if let Some(origin) = request_origin {\n                if let Ok(url) = Url::parse(origin) {\n                    if config.origins.contains(url.as_str())\n                        || url.host() == Some(Host::Domain(\"127.0.0.1\"))\n                        || url.host() == Some(Host::Domain(\"localhost\"))\n                    {\n                        response.set_header(Header::new(\"Access-Control-Allow-Origin\", origin));\n                    }\n                }\n            }\n        } else {\n            response.set_header(Header::new(\"Access-Control-Allow-Origin\", \"*\"));\n        }\n\n        response.set_header(Header::new(\n            \"Access-Control-Allow-Methods\",\n            \"POST, GET, PATCH, OPTIONS\",\n        ));\n        response.set_header(Header::new(\"Access-Control-Allow-Headers\", \"*\"));\n        response.set_header(Header::new(\"Access-Control-Allow-Credentials\", \"true\"));\n    }\n}\n","traces":[{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_server","src","lib.rs"],"content":"//! HTTP server for secure multi-party computation.\n//!\n//! This crate provides an HTTP server acting as the `contributor` and running the secure computation\n//! engine. A connecting HTTP client is expected to act as the `evaluator`.\n//!\n//! This crate can be used as either a library or a binary.\n//!\n//! As a library, it provides a [`build`] function, which can be used to construct a server with\n//! custom logic for choosing its input.\n//!\n//! In order to use this crate as a binary, the crate must be compiled with the `bin` feature. The\n//! server binary supports two modes of execution:\n//!\n//! 1. Without configuration: Acts as a simple 'echo server' and expects the contributor's input \n//!    to be supplied by the client (as plaintext metadata).\n//!\n//! 2. With static configuration: Provided during server startup, as `config.json` or\n//!    `config.toml`, describing which function and contributor input to use based on the\n//!    plaintext metadata supplied by the client. These must be stored in the directory from which the\n//!    server is started. The directory must also contain a file named `program.rs`\n//!    with the program to run on the secure computation engine.\n//!\n//! As the server is based on the [Rocket](https://rocket.rs) framework, it is possible to\n//! configure it according to the official [Rocket\n//! documentation](https://rocket.rs/v0.5-rc/guide/configuration/#configuration).\n//!\n//! Example configuration through env vars:\n//!\n//! ```sh\n//! # make the server listen at port 8080\n//! ROCKET_PORT=8080 mpc_server\n//!\n//! # listen at 127.0.0.1 for HTTP requests\n//! ROCKET_ADDRESS=127.0.0.1 mpc_server\n//! ```\n\n#![deny(unsafe_code)]\n#![deny(missing_docs)]\n#![deny(rustdoc::broken_intra_doc_links)]\n\nuse engine::{stage, Cors};\nuse rocket::{Build, Rocket};\npub use types::{HandleMpcRequestFn, MpcRequest, MpcSession};\n\n#[macro_use]\nextern crate rocket;\n\nmod engine;\nmod msg_queue;\nmod requests;\nmod responses;\nmod state;\nmod types;\n\n#[cfg(test)]\nmod tests;\n\n/// Starts a secure computation server, responding to requests using the specified custom handler logic.\npub fn build(handler: HandleMpcRequestFn) -\u003e Rocket\u003cBuild\u003e {\n    rocket::build().attach(stage(handler)).attach(Cors)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_server","src","main.rs"],"content":"use std::{collections::HashMap, fs::read_to_string, path::Path};\n\nuse figment::{\n    providers::{Env, Format, Json, Toml},\n    Figment,\n};\nuse serde::Deserialize;\nuse mpc_garble_interop::{check_program, compile_program, serialize_input, Role};\nuse mpc_http_server::{build, MpcRequest, MpcSession};\n\nuse std::{env, iter::zip};\n\n#[macro_use]\nextern crate rocket;\n\ntype ProgramFilePath = String;\ntype ProgramFnName = String;\ntype PlaintextMetadata = String;\ntype OwnInput = String;\n\n#[derive(Debug, Clone, Deserialize)]\nstruct HandlerConfig {\n    handlers: HashMap\u003cProgramFnName, HashMap\u003cPlaintextMetadata, OwnInput\u003e\u003e,\n}\n\n#[launch]\nfn rocket() -\u003e _ {\n    println!(\n        \"Starting server in {}...\",\n        env::current_dir().unwrap().display().to_string()\n    );\n\n    let default = HashMap::\u003cProgramFilePath, HashMap\u003cPlaintextMetadata, OwnInput\u003e\u003e::new();\n    let config: HandlerConfig = Figment::from((\"handlers\", default))\n        .merge(Json::file(\"mpc.json\"))\n        .merge(Toml::file(\"mpc.toml\"))\n        .merge(Env::prefixed(\"mpc_\"))\n        .extract()\n        .unwrap();\n\n    let mut request_headers = HashMap::new();\n\n    // fly.io specific logic to allow reconnecting to the same instance:\n    set_fly_instance_id(\u0026mut request_headers);\n\n    if config.handlers.is_empty() {\n        println!(\"No configured handlers, starting simple echo server instead...\");\n        let handler = move |r: MpcRequest| -\u003e Result\u003cMpcSession, String\u003e {\n            let prg = check_program(\u0026r.program)?;\n            let circuit = compile_program(\u0026prg, \u0026r.function)?;\n            let input = serialize_input(\n                Role::Contributor,\n                \u0026prg,\n                \u0026circuit.fn_def,\n                \u0026r.plaintext_metadata,\n            )?;\n            Ok(MpcSession {\n                circuit: circuit.gates,\n                input_from_server: input,\n                request_headers: request_headers.clone(),\n            })\n        };\n        build(Box::new(handler))\n    } else {\n        println!(\"Starting server based on configured handlers...\");\n        let path = Path::new(\"program.garble.rs\");\n        let source_code =\n            read_to_string(\u0026path).unwrap_or_else(|_| panic!(\"could not read file {path:?}\"));\n        let source_code = source_code.trim().to_string();\n        let program = check_program(\u0026source_code)\n            .unwrap_or_else(|e| panic!(\"{path:?} is not a valid program:\\n{e}\"));\n        let mut handlers_with_circuit = HashMap::with_capacity(config.handlers.capacity());\n        for (fn_name, handlers) in config.handlers {\n            let circuit = compile_program(\u0026program, \u0026fn_name)\n                .unwrap_or_else(|e| panic!(\"{fn_name} in {path:?} cannot be compiled:\\n{e}\"));\n            let mut inputs = HashMap::with_capacity(handlers.len());\n            for (metadata, input) in handlers {\n                let input = serialize_input(Role::Contributor, \u0026program, \u0026circuit.fn_def, \u0026input)\n                    .unwrap_or_else(|e| panic!(\"Could not parse literal of handler {path:?}, {fn_name}, \\\"{metadata}\\\":\\n{e}\"));\n                inputs.insert(metadata, input);\n            }\n            handlers_with_circuit.insert(fn_name, (circuit.gates, inputs));\n        }\n        let handler = move |r: MpcRequest| -\u003e Result\u003cMpcSession, String\u003e {\n            let hash_of_source_code = blake3::hash(r.program.trim().as_bytes());\n            let server_program = source_code.chars();\n            let client_program = r.program.chars();\n            let mut differences = zip(client_program, server_program);\n            let mismatch_index = differences.position(|(a, b)| a != b);\n\n            if let Some(mismatch_index) = mismatch_index {\n                fn extract_snippet(code: \u0026str, index: usize) -\u003e String {\n                    let snippet: String = code.chars().skip(index).take(10).collect();\n                    let snippet = snippet.replace('\\\\', \"\\\\\\\\\").replace('\\n', \"\\\\n\");\n                    format!(\"'{snippet}...'\")\n                }\n\n                let client = extract_snippet(\u0026r.program, mismatch_index);\n                let server = extract_snippet(\u0026source_code, mismatch_index);\n\n                return Err(format!(\n                    \"Programs differ at character {mismatch_index}: {client}, {server}\"\n                ));\n            }\n\n            if let Some((circuit, handlers)) = handlers_with_circuit.get(\u0026r.function) {\n                if let Some(input) = handlers.get(\u0026r.plaintext_metadata) {\n                    Ok(MpcSession {\n                        circuit: circuit.clone(),\n                        input_from_server: input.clone(),\n                        request_headers: HashMap::new(),\n                    })\n                } else {\n                    Err(format!(\n                        \"could not find a handler for metadata '{}' (for the function '{}' in the program with hash {}):\\n{} \",\n                        r.plaintext_metadata, r.function, hash_of_source_code, r.program\n                        ))\n                }\n            } else {\n                Err(format!(\n                        \"could not find a handler for the function '{}' (in the program with hash {}):\\n{}\",\n                        r.function, hash_of_source_code, r.program\n                    ))\n            }\n        };\n        build(Box::new(handler))\n    }\n}\n\nfn set_fly_instance_id(request_headers: \u0026mut HashMap\u003cString, String\u003e) {\n    if let Ok(fly_alloc_id) = env::var(\"FLY_ALLOC_ID\") {\n        let fly_instance_id = fly_alloc_id.split(\"-\").collect::\u003cVec\u003c_\u003e\u003e()[0].to_string();\n        request_headers.insert(\"fly-force-instance-id\".to_string(), fly_instance_id);\n    }\n}\n\n#[test]\n\nfn test_fly_instance_id() {\n    env::set_var(\"FLY_ALLOC_ID\", \"b996131a-5bae-215b-d0f1-2d75d1a8812b\");\n    let mut headers = HashMap::new();\n    set_fly_instance_id(\u0026mut headers);\n    assert_eq!(headers.get(\"fly-force-instance-id\").unwrap(), \"b996131a\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_server","src","msg_queue.rs"],"content":"use std::collections::{vec_deque, VecDeque};\n\npub(crate) type MessageId = u32;\n\n#[derive(Clone)]\npub(crate) struct MsgQueue {\n    send_q: VecDeque\u003cVec\u003cu8\u003e\u003e,\n    msg_counter: usize,\n}\n\nimpl MsgQueue {\n    pub(crate) fn new() -\u003e Self {\n        Self {\n            send_q: VecDeque::with_capacity(8),\n            msg_counter: 0,\n        }\n    }\n\n    // flushes the queue until excluding {last_durably_received_offset}.\n    //\n    // after this operation, the logical message id of each queued message will be **strictly bigger than** the given offset\n    pub(crate) fn flush_queue(\u0026mut self, last_durably_received_offset: MessageId) -\u003e usize {\n        let last_durably_received_offset = last_durably_received_offset as usize;\n\n        let first_offset = self.msg_counter - self.send_q.len();\n        let mut offset = first_offset;\n\n        while offset \u003c= last_durably_received_offset \u0026\u0026 !self.send_q.is_empty() {\n            self.send_q.pop_front();\n            offset += 1;\n        }\n\n        // return how many elements were removed\n        offset - first_offset\n    }\n\n    pub(crate) fn send(\u0026mut self, msg: Vec\u003cu8\u003e) {\n        self.msg_counter += 1;\n        self.send_q.push_back(msg);\n    }\n}\n\npub struct MsgIter\u003c'a\u003e(vec_deque::Iter\u003c'a, Vec\u003cu8\u003e\u003e, MessageId);\n\nimpl\u003c'a\u003e Iterator for MsgIter\u003c'a\u003e {\n    type Item = (\u0026'a Vec\u003cu8\u003e, MessageId);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.0.next().map(|msg| {\n            self.1 += 1;\n            (msg, self.1 - 1)\n        })\n    }\n}\n\nimpl MsgQueue {\n    pub fn msgs_iter(\u0026self) -\u003e MsgIter\u003c'_\u003e {\n        let message_id = self.msg_counter - self.send_q.len();\n        MsgIter(self.send_q.iter(), message_id as MessageId)\n    }\n}\n\n#[test]\nfn test_flush_queue() {\n    let c = MsgQueue {\n        send_q: Default::default(),\n        msg_counter: Default::default(),\n    };\n\n    {\n        assert_eq!(0, c.clone().flush_queue(0));\n        assert_eq!(0, c.clone().flush_queue(1));\n        assert_eq!(0, c.clone().flush_queue(10));\n    }\n    {\n        let mut c = c;\n\n        c.send(bincode::serialize(\u0026vec![(0, false)]).unwrap());\n        assert_eq!(1, c.clone().flush_queue(0));\n\n        c.flush_queue(0);\n        assert_eq!(None, c.send_q.pop_front());\n\n        c.send(bincode::serialize(\u0026vec![(1, false)]).unwrap());\n        assert_eq!(0, c.clone().flush_queue(0));\n        assert_eq!(1, c.clone().flush_queue(1));\n        assert_eq!(\n            Some(bincode::serialize(\u0026vec![(1, false)]).unwrap()),\n            c.send_q.pop_front()\n        );\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_server","src","requests.rs"],"content":"use rocket::serde::{Deserialize, Serialize};\nuse mpc_core::CircuitBlake3Hash;\n\n#[derive(Serialize, Deserialize, Debug)]\n#[serde(crate = \"rocket::serde\")]\npub struct NewSession {\n    pub plaintext_metadata: String,\n    pub program: String,\n    pub function: String,\n    pub circuit_hash: CircuitBlake3Hash,\n    pub client_version: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_server","src","responses.rs"],"content":"use rocket::{\n    http::Status,\n    response::{self, Responder},\n    serde::{Deserialize, Serialize},\n};\nuse std::io::Cursor;\n\n#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]\n#[serde(crate = \"rocket::serde\")]\n#[serde(tag = \"error\", content = \"args\")]\npub(crate) enum Error {\n    CircuitHashMismatch,\n    UnexpectedWireFormat(String),\n    MpcRequestRejected(String),\n    DuplicateEngineId {\n        engine_id: String,\n    },\n    UnexpectedMessageId,\n    NoSuchEngineId {\n        engine_id: String,\n    },\n    Internal {\n        message: String,\n    },\n    Bincode,\n    Engine,\n    IncompatibleVersions {\n        client_version: String,\n        server_version: String,\n    },\n}\n\nimpl\u003c'r, 'o: 'r\u003e Responder\u003c'r, 'o\u003e for Error {\n    fn respond_to(self, _: \u0026'r rocket::Request\u003c'_\u003e) -\u003e response::Result\u003c'o\u003e {\n        let string =\n            serde_json::to_string(\u0026self).map_err(|_| rocket::http::Status::InternalServerError)?;\n\n        rocket::Response::build()\n            .header(rocket::http::ContentType::JSON)\n            .sized_body(string.len(), Cursor::new(string))\n            .status(self.status())\n            .ok()\n    }\n}\n\nimpl Error {\n    fn status(\u0026self) -\u003e Status {\n        match self {\n            Error::IncompatibleVersions { .. } =\u003e Status::BadRequest,\n            Error::CircuitHashMismatch =\u003e Status::BadRequest,\n            Error::UnexpectedWireFormat(_) =\u003e Status::BadRequest,\n            Error::MpcRequestRejected(_) =\u003e Status::BadRequest,\n            Error::DuplicateEngineId { .. } =\u003e Status::BadRequest,\n            Error::UnexpectedMessageId =\u003e Status::BadRequest,\n            Error::Bincode =\u003e Status::BadRequest,\n            Error::NoSuchEngineId { .. } =\u003e Status::NotFound,\n            Error::Internal { .. } =\u003e Status::InternalServerError,\n            Error::Engine =\u003e Status::InternalServerError,\n        }\n    }\n}\n\nimpl From\u003cbincode::Error\u003e for Error {\n    fn from(_: bincode::Error) -\u003e Self {\n        Self::Bincode\n    }\n}\n\nimpl From\u003cmpc_core::Error\u003e for Error {\n    fn from(_: mpc_core::Error) -\u003e Self {\n        Error::Engine\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_server","src","state.rs"],"content":"use std::{\n    collections::{hash_map::Entry, HashMap},\n    sync::{Arc, Mutex, RwLock},\n};\n\nuse rand_chacha::ChaCha20Rng;\nuse mpc_core::{\n    states::{Contributor, Msg},\n    Circuit,\n};\n\nuse crate::{\n    msg_queue::{MessageId, MsgQueue},\n    responses::Error,\n    types::{EngineId, HandleMpcRequestFn, MpcRequest, MpcSession},\n};\n\n/// reference to a (running) Engine\npub(crate) struct EngineRef {\n    last_durably_received_client_event_offset: Option\u003cMessageId\u003e,\n    mpc: Option\u003cContributor\u003cCircuit, Vec\u003cbool\u003e\u003e\u003e,\n    steps_remaining: u32,\n    context: MsgQueue,\n}\n\nimpl EngineRef {\n    pub fn new(rng: ChaCha20Rng, program: Circuit, input: Vec\u003cbool\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        let mut context = MsgQueue::new();\n        let (contrib, initial_msg) = Contributor::new(program, input, rng)?;\n        let steps_remaining = contrib.steps();\n        context.send(initial_msg);\n\n        Ok(Self {\n            context,\n            mpc: Some(contrib),\n            steps_remaining,\n            last_durably_received_client_event_offset: None,\n        })\n    }\n\n    pub fn process_message(\u0026mut self, msg: \u0026Msg, offset: MessageId) -\u003e Result\u003c(), Error\u003e {\n        if (self.last_durably_received_client_event_offset.is_none() \u0026\u0026 offset == 0)\n            || self.last_durably_received_client_event_offset == Some(offset - 1)\n        {\n            self.last_durably_received_client_event_offset = Some(offset);\n            if let Some(contrib) = self.mpc.take() {\n                let (next_state, reply) = contrib.run(msg)?;\n                self.mpc = Some(next_state);\n                self.context.send(reply);\n            }\n            Ok(())\n        } else {\n            Err(Error::UnexpectedMessageId)\n        }\n    }\n\n    pub fn last_durably_received_client_event_offset(\u0026self) -\u003e Option\u003cMessageId\u003e {\n        self.last_durably_received_client_event_offset\n    }\n\n    pub fn flush_queue(\u0026mut self, last_durably_received_offset: MessageId) {\n        self.context.flush_queue(last_durably_received_offset);\n    }\n\n    pub fn dump_messages(\u0026self) -\u003e Vec\u003c(\u0026Msg, MessageId)\u003e {\n        self.context.msgs_iter().map(|m| (m.0, m.1)).collect()\n    }\n\n    pub fn is_done(\u0026self) -\u003e bool {\n        self.steps_remaining == 0\n    }\n}\n\npub(crate) struct EngineRegistry {\n    registry: RwLock\u003cHashMap\u003cEngineId, Arc\u003cMutex\u003cEngineRef\u003e\u003e\u003e\u003e,\n    handler: HandleMpcRequestFn,\n}\n\nimpl EngineRegistry {\n    pub(crate) fn new(handler: HandleMpcRequestFn) -\u003e Self {\n        Self {\n            registry: RwLock::new(HashMap::new()),\n            handler,\n        }\n    }\n\n    pub(crate) fn insert_engine(\u0026self, engine_id: EngineId, engine: Arc\u003cMutex\u003cEngineRef\u003e\u003e) -\u003e bool {\n        let mut r = self.registry.write().unwrap();\n        if let Entry::Vacant(e) = r.entry(engine_id) {\n            e.insert(engine);\n            true\n        } else {\n            false\n        }\n    }\n\n    pub(crate) fn drop_engine(\u0026self, engine_id: \u0026EngineId) -\u003e bool {\n        let mut r = self.registry.write().unwrap();\n        r.remove(engine_id).is_some()\n    }\n\n    pub(crate) fn lookup(\u0026self, engine_id: \u0026EngineId) -\u003e Result\u003cArc\u003cMutex\u003cEngineRef\u003e\u003e, Error\u003e {\n        let r = self.registry.read().unwrap();\n        match r.get(engine_id).map(Arc::clone) {\n            Some(e) =\u003e Ok(e),\n            None =\u003e Err(Error::NoSuchEngineId {\n                engine_id: engine_id.clone(),\n            }),\n        }\n    }\n\n    pub(crate) fn handle_input(\u0026self, invocation: MpcRequest) -\u003e Result\u003cMpcSession, String\u003e {\n        self.handler.as_ref()(invocation)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_server","src","tests.rs"],"content":"#![allow(dead_code)]\n\nuse crate::{\n    build,\n    msg_queue::{MessageId, MsgQueue},\n    requests::NewSession,\n    types::{EngineCreationResult, MpcSession},\n    MpcRequest,\n};\nuse std::collections::HashMap;\n\nuse crate::engine;\n\nuse mpc_core::{\n    states::{Evaluator, Msg},\n    Circuit,\n};\nuse mpc_garble_interop::{\n    check_program, compile_program, deserialize_output, serialize_input, Role, TypedCircuit,\n};\nuse rand::SeedableRng;\nuse rand_chacha::ChaCha20Rng;\nuse rocket::{\n    http::Status,\n    local::blocking::{Client, LocalResponse},\n};\n\ntype MessageLog = Vec\u003c(mpc_core::states::Msg, crate::msg_queue::MessageId)\u003e;\n\n#[launch]\npub fn _rocket() -\u003e _ {\n    let handler = |r: MpcRequest| -\u003e Result\u003cMpcSession, String\u003e {\n        let prg = check_program(\u0026r.program)?;\n        let circuit = compile_program(\u0026prg, \u0026r.function)?;\n        let headers = HashMap::new();\n        let input = serialize_input(\n            Role::Contributor,\n            \u0026prg,\n            \u0026circuit.fn_def,\n            \u0026r.plaintext_metadata,\n        )?;\n        Ok(MpcSession {\n            circuit: circuit.gates,\n            input_from_server: input,\n            request_headers: headers,\n        })\n    };\n    build(Box::new(handler))\n}\n\n#[test]\nfn test_multiple_engines() {\n    let client = \u0026Client::tracked(_rocket()).unwrap();\n\n    let r1 = new_session(client, xor_and_program(), \"false\".to_string());\n    assert_eq!(r1.status(), Status::Created);\n\n    let r2 = new_session(client, xor_and_program(), \"false\".to_string());\n    assert_eq!(r2.status(), Status::Created);\n\n    assert_ne!(\n        r1.into_json::\u003cEngineCreationResult\u003e(),\n        r2.into_json::\u003cEngineCreationResult\u003e(),\n    );\n}\n\n#[test]\nfn test_delete_session() {\n    let client = \u0026Client::tracked(_rocket()).unwrap();\n\n    let r1 = new_session(client, xor_and_program(), \"false\".to_string());\n    assert_eq!(r1.status(), Status::Created);\n\n    let EngineCreationResult { engine_id, .. } = r1.into_json().unwrap();\n    let r3 = delete_session(client, \u0026engine_id);\n    assert_eq!(r3.status(), Status::Ok);\n\n    let r4 = new_session(client, xor_and_program(), \"false\".to_string());\n    assert_eq!(r4.status(), Status::Created);\n}\n\n#[test]\nfn test_protocol_xor_and() {\n    let client = \u0026Client::tracked(_rocket()).unwrap();\n    let program = xor_and_program();\n\n    for input_party_a in [false, true] {\n        for input_party_b in [false, true] {\n            let r1 = new_session(client, program.clone(), input_party_a.to_string());\n            assert_eq!(r1.status(), Status::Created);\n\n            let EngineCreationResult { engine_id, .. } = r1.into_json().unwrap();\n            let prg = check_program(\u0026program).unwrap();\n            let TypedCircuit { gates, fn_def, .. } = compile_program(\u0026prg, \"main\").unwrap();\n            let result = mpc_http_protocol(client, \u0026engine_id, gates, vec![input_party_b]);\n            let const_sizes = HashMap::new();\n            let result = deserialize_output(\u0026prg, \u0026fn_def, \u0026result)\n                .unwrap()\n                .as_bits(\u0026prg, \u0026const_sizes);\n            println!(\"{input_party_a}, {input_party_b} -\u003e {result:?}\");\n            assert_eq!(\n                result,\n                vec![input_party_a ^ input_party_b, input_party_a \u0026 input_party_b]\n            );\n        }\n    }\n\n    // create engine session\n}\n\n/// runs protocol with upstream\n///\n/// assumes upstream session was already created\nfn mpc_http_protocol(\n    client: \u0026Client,\n    engine_id: \u0026String,\n    program: Circuit,\n    input: Vec\u003cbool\u003e,\n) -\u003e Vec\u003cbool\u003e {\n    let mut context = MsgQueue::new();\n    let mut evaluator = Evaluator::new(program, input, ChaCha20Rng::from_entropy()).unwrap();\n\n    let mut last_durably_received_offset: Option\u003cMessageId\u003e = None;\n    let mut steps_remaining = evaluator.steps();\n    loop {\n        let messages: Vec\u003c(\u0026Msg, MessageId)\u003e = context.msgs_iter().collect();\n        let (upstream_msgs, server_commited_offset) =\n            dialog(client, engine_id, last_durably_received_offset, \u0026messages);\n        assert_eq!(messages.last().map(|v| v.1), server_commited_offset);\n\n        if let Some(last_durably_received_offset) = server_commited_offset {\n            context.flush_queue(last_durably_received_offset);\n        }\n\n        for (msg, server_offset) in \u0026upstream_msgs {\n            assert_eq!(\n                *server_offset,\n                last_durably_received_offset.map(|o| o + 1).unwrap_or(0)\n            );\n\n            if steps_remaining \u003e 0 {\n                let (next_state, msg) = evaluator.run(msg).unwrap();\n                evaluator = next_state;\n                steps_remaining -= 1;\n                context.send(msg);\n            } else {\n                return evaluator.output(msg).unwrap();\n            }\n            last_durably_received_offset = Some(*server_offset);\n        }\n    }\n}\n\nfn dialog\u003c'a\u003e(\n    client: \u0026'a Client,\n    engine_id: \u0026String,\n    last_durably_received_offset: Option\u003cu32\u003e,\n    messages: \u0026Vec\u003c(\u0026Msg, MessageId)\u003e,\n) -\u003e (MessageLog, Option\u003cMessageId\u003e) {\n    let dialog_uri = uri!(engine::dialog(engine_id));\n    let messages = bincode::serialize(\u0026(last_durably_received_offset, messages)).unwrap();\n    let res = client.post(dialog_uri).body(messages).dispatch();\n    assert_eq!(res.status(), Status::Ok);\n\n    bincode::deserialize(\u0026res.into_bytes().unwrap()).unwrap()\n}\n\nfn new_session\u003c'a\u003e(client: \u0026'a Client, program: String, input: String) -\u003e LocalResponse\u003c'a\u003e {\n    let prg = check_program(\u0026program).unwrap();\n    let circuit = compile_program(\u0026prg, \"main\").unwrap();\n    let create_sess_uri = uri!(engine::create_session());\n    let session = NewSession {\n        plaintext_metadata: input,\n        program,\n        function: \"main\".to_string(),\n        circuit_hash: circuit.gates.blake3_hash(),\n        client_version: env!(\"CARGO_PKG_VERSION\").to_string(),\n    };\n    client.post(create_sess_uri).json(\u0026session).dispatch()\n}\n\nfn xor_and_program() -\u003e String {\n    \"pub fn main(a: bool, b: bool) -\u003e (bool, bool) { (a ^ b, a \u0026 b) }\".to_string()\n}\n\nfn delete_session\u003c'a\u003e(client: \u0026'a Client, engine_id: \u0026String) -\u003e LocalResponse\u003c'a\u003e {\n    let delete_sess_uri = uri!(engine::delete_session(engine_id));\n    client.delete(delete_sess_uri).dispatch()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kaladin","rust","mpc_core","mpc_http_server","src","types.rs"],"content":"use std::collections::HashMap;\n\nuse mpc_core::Circuit;\nuse rocket::serde::{Deserialize, Serialize};\n\npub type EngineId = String;\n\n/// Custom logic to choose a server's circuit and input.\npub type HandleMpcRequestFn = Box\u003cdyn Fn(MpcRequest) -\u003e Result\u003cMpcSession, String\u003e + Send + Sync\u003e;\n\n/// Session information used by the server to start executing the MPC protocol.\n#[derive(Debug, Clone)]\npub struct MpcSession {\n    /// The circuit to execute using MPC.\n    pub circuit: Circuit,\n    /// The server's input, kept hidden from the client.\n    pub input_from_server: Vec\u003cbool\u003e,\n    /// Optional headers for the client, which the client should set for every request.\n    ///\n    /// This can be used to set headers which allow the server(s) to re-identify clients after the\n    /// initial request and to e.g. ensure that every request during the MPC execution is routed to\n    /// the same server instance.\n    pub request_headers: HashMap\u003cString, String\u003e,\n}\n\n/// A request by a client to start a Multi-Party Computation.\npub struct MpcRequest {\n    /// Plaintext freely chosen by the client to influence the server's choice of its input.\n    pub plaintext_metadata: String,\n    /// The Garble program to execute.\n    pub program: String,\n    /// The name of the function in the Garble program to execute using MPC.\n    pub function: String,\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]\n#[serde(crate = \"rocket::serde\")]\npub(crate) struct EngineCreationResult {\n    pub engine_id: String,\n    pub request_headers: HashMap\u003cString, String\u003e,\n    pub server_version: String,\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>